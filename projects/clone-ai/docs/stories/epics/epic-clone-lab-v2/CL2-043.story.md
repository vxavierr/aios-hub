# Story CL2-043: Monthly Report Generator

**Story ID:** CL2-043
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar o **Monthly Report Generator** - componente que gera relatórios mensais de evolução do sistema, incluindo mudanças aplicadas, impacto medido, e tendências.

### Problem Statement
O Clone Lab precisa de visibilidade sobre sua evolução ao longo do tempo. O Monthly Report Generator consolida dados do evolution log e metrics para produzir relatórios acionáveis.

---

## Acceptance Criteria

```gherkin
Given a month has passed
When report generation is triggered
Then a comprehensive monthly report is created

Given changes were applied during the month
When the report is generated
Then all changes are listed with their impact

Given trends can be calculated
When the report includes trends
Then improvement or degradation patterns are visible

Given a report is generated
When it is exported
Then it is available in markdown and JSON formats
```

---

## Technical Requirements

### Report Generator

```typescript
// packages/meta/src/reporting/monthly-report.ts

export interface MonthlyReport {
  id: string;
  period: ReportPeriod;
  generatedAt: Date;
  summary: ReportSummary;
  changes: ChangeSummary[];
  impact: ImpactSummary;
  trends: TrendSummary[];
  recommendations: ReportRecommendation[];
  nextMonth: NextMonthPlan;
}

export interface ReportPeriod {
  year: number;
  month: number;
  startDate: Date;
  endDate: Date;
}

export interface ReportSummary {
  totalChanges: number;
  autoApplied: number;
  humanApproved: number;
  rolledBack: number;
  overallHealthScore: number;
  improvementRate: number;       // % improvement vs previous month
}

export interface ChangeSummary {
  category: string;
  count: number;
  avgImpact: number;
  successRate: number;
  examples: ChangeExample[];
}

export interface ChangeExample {
  id: string;
  description: string;
  impact: number;
  date: Date;
}

export interface ImpactSummary {
  timeSavings: number;           // Total ms saved
  qualityImprovement: number;    // Points improved
  fidelityChange: number;        // Change in fidelity score
  errorReduction: number;        // % reduction in errors
}

export interface TrendSummary {
  metric: string;
  direction: 'improving' | 'stable' | 'declining';
  changePercent: number;
  forecast: number;              // Predicted value next month
}

export interface ReportRecommendation {
  priority: 'high' | 'medium' | 'low';
  title: string;
  description: string;
  expectedBenefit: string;
}

export interface NextMonthPlan {
  focusAreas: string[];
  proposedChanges: number;
  budget: {
    autoApplyLimit: number;
    humanReviewCapacity: number;
  };
}

export class MonthlyReportGenerator {
  private readonly evolutionLog: EvolutionLog;
  private readonly metricsCollector: MetricsCollector;
  private readonly assessmentEngine: SelfAssessmentEngine;

  constructor(
    evolutionLog: EvolutionLog,
    metricsCollector: MetricsCollector,
    assessmentEngine: SelfAssessmentEngine
  ) {
    this.evolutionLog = evolutionLog;
    this.metricsCollector = metricsCollector;
    this.assessmentEngine = assessmentEngine;
  }

  async generate(period?: ReportPeriod): Promise<MonthlyReport> {
    const reportPeriod = period || this.getLastMonthPeriod();

    // Gather data for the period
    const changes = await this.getChangesForPeriod(reportPeriod);
    const impacts = await this.getImpactsForPeriod(reportPeriod);
    const trends = await this.calculateTrends(reportPeriod);

    // Build summary
    const summary = await this.buildSummary(changes, impacts);

    // Build change summaries by category
    const changeSummaries = this.groupChangesByCategory(changes);

    // Build impact summary
    const impactSummary = this.calculateImpactSummary(impacts);

    // Generate recommendations
    const recommendations = await this.generateRecommendations(summary, trends);

    // Plan for next month
    const nextMonthPlan = await this.planNextMonth(summary, trends);

    return {
      id: `report-${reportPeriod.year}-${reportPeriod.month.toString().padStart(2, '0')}`,
      period: reportPeriod,
      generatedAt: new Date(),
      summary,
      changes: changeSummaries,
      impact: impactSummary,
      trends,
      recommendations,
      nextMonth: nextMonthPlan
    };
  }

  private getLastMonthPeriod(): ReportPeriod {
    const now = new Date();
    const firstDayOfThisMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    const lastDayOfLastMonth = new Date(firstDayOfThisMonth.getTime() - 1);
    const firstDayOfLastMonth = new Date(
      lastDayOfLastMonth.getFullYear(),
      lastDayOfLastMonth.getMonth(),
      1
    );

    return {
      year: lastDayOfLastMonth.getFullYear(),
      month: lastDayOfLastMonth.getMonth() + 1,
      startDate: firstDayOfLastMonth,
      endDate: lastDayOfLastMonth
    };
  }

  private async getChangesForPeriod(period: ReportPeriod): Promise<ChangeRecord[]> {
    const entries = await this.evolutionLog.query({
      types: ['change_applied'],
      startDate: period.startDate,
      endDate: period.endDate
    });

    return entries.map(e => ({
      id: e.metadata.changeId!,
      category: (e.data.improvement as any)?.category || 'unknown',
      appliedBy: (e.data.appliedBy as string) || 'unknown',
      impact: 0, // Will be populated from impact entries
      timestamp: e.timestamp
    }));
  }

  private async getImpactsForPeriod(period: ReportPeriod): Promise<ImpactRecord[]> {
    const entries = await this.evolutionLog.query({
      types: ['impact_measured'],
      startDate: period.startDate,
      endDate: period.endDate
    });

    return entries.map(e => ({
      changeId: e.metadata.changeId!,
      overallScore: (e.data.overallScore as number) || 0,
      verdict: (e.data.verdict as string) || 'neutral',
      metrics: (e.data.metrics as any[]) || []
    }));
  }

  private async calculateTrends(period: ReportPeriod): Promise<TrendSummary[]> {
    const metrics = [
      'clone_fidelity_score',
      'clone_operation_duration_seconds',
      'mind_confidence_score',
      'validation_task_executions_total'
    ];

    const trends: TrendSummary[] = [];

    for (const metric of metrics) {
      // Get data for current and previous period
      const currentData = await this.metricsCollector.getAggregated(
        metric,
        { start: period.startDate, end: period.endDate },
        'avg'
      );

      const previousPeriod = this.getPreviousPeriod(period);
      const previousData = await this.metricsCollector.getAggregated(
        metric,
        { start: previousPeriod.startDate, end: previousPeriod.endDate },
        'avg'
      );

      const currentValue = currentData[0]?.value || 0;
      const previousValue = previousData[0]?.value || 0;

      const changePercent = previousValue !== 0
        ? ((currentValue - previousValue) / previousValue) * 100
        : 0;

      trends.push({
        metric,
        direction: changePercent > 2 ? 'improving' : changePercent < -2 ? 'declining' : 'stable',
        changePercent: Math.round(changePercent * 10) / 10,
        forecast: currentValue * (1 + changePercent / 100) // Simple linear forecast
      });
    }

    return trends;
  }

  private async buildSummary(
    changes: ChangeRecord[],
    impacts: ImpactRecord[]
  ): Promise<ReportSummary> {
    const totalChanges = changes.length;
    const autoApplied = changes.filter(c => c.appliedBy === 'auto').length;
    const humanApproved = totalChanges - autoApplied;
    const rolledBack = impacts.filter(i => i.verdict === 'negative').length;

    // Calculate average impact
    const avgImpact = impacts.length > 0
      ? impacts.reduce((sum, i) => sum + i.overallScore, 0) / impacts.length
      : 0;

    // Calculate improvement rate (simplified)
    const improvementRate = avgImpact > 0 ? Math.min(avgImpact * 2, 50) : 0;

    return {
      totalChanges,
      autoApplied,
      humanApproved,
      rolledBack,
      overallHealthScore: Math.round(70 + avgImpact), // Base 70 + improvement
      improvementRate: Math.round(improvementRate)
    };
  }

  private groupChangesByCategory(changes: ChangeRecord[]): ChangeSummary[] {
    const groups = new Map<string, ChangeRecord[]>();

    for (const change of changes) {
      const category = change.category;
      if (!groups.has(category)) {
        groups.set(category, []);
      }
      groups.get(category)!.push(change);
    }

    return Array.from(groups.entries()).map(([category, categoryChanges]) => ({
      category,
      count: categoryChanges.length,
      avgImpact: categoryChanges.reduce((sum, c) => sum + c.impact, 0) / categoryChanges.length,
      successRate: categoryChanges.filter(c => c.impact > 0).length / categoryChanges.length,
      examples: categoryChanges.slice(0, 3).map(c => ({
        id: c.id,
        description: `Change ${c.id}`,
        impact: c.impact,
        date: c.timestamp
      }))
    }));
  }

  private calculateImpactSummary(impacts: ImpactRecord[]): ImpactSummary {
    let timeSavings = 0;
    let qualityImprovement = 0;
    let fidelityChange = 0;
    let errorReduction = 0;

    for (const impact of impacts) {
      for (const metric of impact.metrics) {
        if (metric.name.includes('duration')) {
          timeSavings += Math.abs(metric.change);
        }
        if (metric.name.includes('quality') || metric.name.includes('confidence')) {
          qualityImprovement += metric.change;
        }
        if (metric.name.includes('fidelity')) {
          fidelityChange += metric.change;
        }
        if (metric.name.includes('error')) {
          errorReduction += Math.abs(metric.change);
        }
      }
    }

    return {
      timeSavings: Math.round(timeSavings),
      qualityImprovement: Math.round(qualityImprovement),
      fidelityChange: Math.round(fidelityChange * 10) / 10,
      errorReduction: Math.round(errorReduction)
    };
  }

  async exportMarkdown(report: MonthlyReport): Promise<string> {
    return `# Clone Lab Evolution Report

## Period: ${report.period.year}-${report.period.month.toString().padStart(2, '0')}

Generated: ${report.generatedAt.toISOString()}

---

## Summary

| Metric | Value |
|--------|-------|
| Total Changes | ${report.summary.totalChanges} |
| Auto-Applied | ${report.summary.autoApplied} |
| Human Approved | ${report.summary.humanApproved} |
| Rolled Back | ${report.summary.rolledBack} |
| Health Score | ${report.summary.overallHealthScore} |
| Improvement Rate | ${report.summary.improvementRate}% |

---

## Impact Summary

- **Time Savings**: ${report.impact.timeSavings}ms
- **Quality Improvement**: ${report.impact.qualityImprovement} points
- **Fidelity Change**: ${report.impact.fidelityChange > 0 ? '+' : ''}${report.impact.fidelityChange}%
- **Error Reduction**: ${report.impact.errorReduction}%

---

## Trends

| Metric | Direction | Change |
|--------|-----------|--------|
${report.trends.map(t => `| ${t.metric} | ${t.direction} | ${t.changePercent}% |`).join('\n')}

---

## Recommendations

${report.recommendations.map(r => `
### ${r.priority.toUpperCase()}: ${r.title}

${r.description}

**Expected Benefit**: ${r.expectedBenefit}
`).join('\n')}

---

## Next Month Plan

**Focus Areas**: ${report.nextMonth.focusAreas.join(', ')}

**Proposed Changes**: ${report.nextMonth.proposedChanges}

**Auto-Apply Budget**: ${report.nextMonth.budget.autoApplyLimit} changes

---

*Generated by Clone Lab Meta-Cognition System*
`;
  }

  async exportJSON(report: MonthlyReport): Promise<string> {
    return JSON.stringify(report, null, 2);
  }
}
```

### Report Scheduler

```typescript
// packages/meta/src/reporting/scheduler.ts

export class ReportScheduler {
  private readonly generator: MonthlyReportGenerator;
  private readonly storage: ReportStorage;
  private scheduledJob: NodeJS.Timeout | null = null;

  constructor(generator: MonthlyReportGenerator, storage: ReportStorage) {
    this.generator = generator;
    this.storage = storage;
  }

  start(): void {
    // Schedule report generation on 1st of each month at 2 AM
    const scheduleNext = () => {
      const now = new Date();
      const next = new Date(now.getFullYear(), now.getMonth() + 1, 1, 2, 0, 0);
      const delay = next.getTime() - now.getTime();

      this.scheduledJob = setTimeout(async () => {
        await this.generateAndSave();
        scheduleNext();
      }, delay);
    };

    scheduleNext();
  }

  stop(): void {
    if (this.scheduledJob) {
      clearTimeout(this.scheduledJob);
      this.scheduledJob = null;
    }
  }

  async generateAndSave(): Promise<MonthlyReport> {
    const report = await this.generator.generate();

    // Save in multiple formats
    await this.storage.save(report);
    await this.storage.saveMarkdown(
      report.id,
      await this.generator.exportMarkdown(report)
    );
    await this.storage.saveJSON(
      report.id,
      await this.generator.exportJSON(report)
    );

    return report;
  }
}
```

---

## Business Value

O Monthly Report Generator fornece **visibilidade da evolução** do sistema, permitindo acompanhamento de melhorias e planejamento futuro.

**Benefícios:**
- Visibilidade mensal da evolução
- Base para decisões estratégicas
- Histórico de melhorias
- Planejamento informado para próximo mês

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Report generation fails | Low | Low | Retry + manual trigger |
| Data gaps | Medium | Low | Handle missing data gracefully |
| Large data volume | Medium | Low | Aggregation + sampling |

---

## Scope

### In Scope
- MonthlyReportGenerator class
- Markdown and JSON export
- Trend calculation
- Recommendation generation
- Report scheduler

### Out of Scope
- Email delivery
- Dashboard visualization
- Real-time reports

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-029 (Metrics Collector) | Package | Pending |
| CL2-041 (Evolution Log) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Report Storage Location

```
reports/
├── 2026/
│   ├── 01/
│   │   ├── report-2026-01.json
│   │   └── report-2026-01.md
│   └── 02/
│       ├── report-2026-02.json
│       └── report-2026-02.md
└── index.json
```

### Report Template Sections

1. **Header** - Period, generation date
2. **Summary** - Key metrics
3. **Changes** - By category
4. **Impact** - Aggregated impact
5. **Trends** - Direction and forecast
6. **Recommendations** - Prioritized
7. **Next Month** - Plan and budget

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/reporting/monthly-report.ts` | Create | Pending |
| `packages/meta/src/reporting/scheduler.ts` | Create | Pending |
| `packages/meta/src/reporting/types.ts` | Create | Pending |
| `packages/meta/src/reporting/index.ts` | Create | Pending |
| `packages/meta/src/reporting/__tests__/monthly-report.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Report generated with all sections
- [ ] Markdown export works
- [ ] JSON export works
- [ ] Trends calculated correctly
- [ ] Recommendations generated
- [ ] Scheduler works
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Report generated with all sections
- [ ] Markdown export works
- [ ] JSON export works
- [ ] Trends calculated correctly
- [ ] Recommendations generated
- [ ] Scheduler works
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
