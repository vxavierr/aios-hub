# Story CL2-039: Pattern Learner

**Story ID:** CL2-039
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Pattern Learner** - componente que aprende com a execução do sistema, identificando padrões que correlacionam com sucesso ou falha.

### Problem Statement
O Clone Lab gera muitos dados de execução. O Pattern Learner analisa estes dados para identificar padrões que podem informar futuras melhorias e otimizações.

---

## Acceptance Criteria

```gherkin
Given the system has execution history
When pattern learning is triggered
Then correlations are identified between actions and outcomes

Given a pattern is discovered
When it has high confidence
Then it is stored for future reference

Given multiple patterns exist
When recommendations are needed
Then patterns with positive correlation are prioritized

Given a pattern was wrong
When feedback is received
Then the pattern confidence is adjusted
```

---

## Technical Requirements

### Pattern Learner

```typescript
// packages/meta/src/learning/pattern-learner.ts

export interface Pattern {
  id: string;
  type: PatternType;
  description: string;
  conditions: PatternCondition[];
  outcome: PatternOutcome;
  confidence: number;            // 0-100
  occurrences: number;           // How often observed
  successRate: number;           // Success rate when applied
  lastSeen: Date;
  discoveredAt: Date;
}

export type PatternType =
  | 'correlation'    // X correlates with Y
  | 'causation'      // X causes Y
  | 'sequence'       // X followed by Y
  | 'cluster'        // X, Y, Z often occur together
  | 'anomaly';       // X is unusual

export interface PatternCondition {
  attribute: string;             // e.g., 'mind', 'task', 'checkpoint'
  operator: 'eq' | 'neq' | 'gt' | 'lt' | 'contains';
  value: string | number;
}

export interface PatternOutcome {
  attribute: string;
  direction: 'increase' | 'decrease';
  magnitude: number;             // Effect size
}

export class PatternLearner {
  private readonly history: ExecutionHistory;
  private readonly patternStore: PatternStore;
  private readonly minOccurrences: number;
  private readonly minConfidence: number;

  constructor(
    history: ExecutionHistory,
    patternStore: PatternStore,
    config: LearnerConfig
  ) {
    this.history = history;
    this.patternStore = patternStore;
    this.minOccurrences = config.minOccurrences || 5;
    this.minConfidence = config.minConfidence || 70;
  }

  async learn(): Promise<LearningResult> {
    const executions = await this.history.getRecentExecutions();
    const newPatterns: Pattern[] = [];
    const updatedPatterns: Pattern[] = [];

    // 1. Find correlations between conditions and outcomes
    const correlations = await this.findCorrelations(executions);
    for (const correlation of correlations) {
      const pattern = this.toPattern(correlation);
      if (pattern.confidence >= this.minConfidence) {
        newPatterns.push(pattern);
      }
    }

    // 2. Find sequential patterns
    const sequences = await this.findSequences(executions);
    for (const seq of sequences) {
      const pattern = this.toSequencePattern(seq);
      if (pattern.confidence >= this.minConfidence) {
        newPatterns.push(pattern);
      }
    }

    // 3. Find anomalies
    const anomalies = await this.findAnomalies(executions);
    for (const anomaly of anomalies) {
      const pattern = this.toAnomalyPattern(anomaly);
      newPatterns.push(pattern);
    }

    // 4. Update existing patterns with new data
    const existingPatterns = await this.patternStore.getAll();
    for (const pattern of existingPatterns) {
      const updated = await this.updatePattern(pattern, executions);
      if (updated) {
        updatedPatterns.push(updated);
      }
    }

    // 5. Store new and updated patterns
    await this.patternStore.saveAll([...newPatterns, ...updatedPatterns]);

    return {
      newPatterns: newPatterns.length,
      updatedPatterns: updatedPatterns.length,
      totalPatterns: await this.patternStore.count(),
      topPatterns: this.getTopPatterns([...newPatterns, ...updatedPatterns])
    };
  }

  private async findCorrelations(
    executions: ExecutionRecord[]
  ): Promise<CorrelationResult[]> {
    const correlations: CorrelationResult[] = [];

    // Attributes to analyze
    const attributes = [
      'mind',
      'task',
      'checkpoint',
      'source_type',
      'complexity'
    ];

    // Outcomes to correlate with
    const outcomes = [
      'fidelity_score',
      'execution_time',
      'success',
      'error_count'
    ];

    for (const attr of attributes) {
      for (const outcome of outcomes) {
        const result = this.calculateCorrelation(
          executions,
          e => e.attributes[attr],
          e => e.outcomes[outcome]
        );

        if (Math.abs(result.coefficient) > 0.3 && result.pValue < 0.05) {
          correlations.push({
            attribute: attr,
            outcome,
            coefficient: result.coefficient,
            pValue: result.pValue,
            direction: result.coefficient > 0 ? 'positive' : 'negative',
            occurrences: executions.length
          });
        }
      }
    }

    return correlations;
  }

  private async findSequences(
    executions: ExecutionRecord[]
  ): Promise<SequenceResult[]> {
    const sequences: SequenceResult[] = [];

    // Find common action sequences
    const sequenceCounts = new Map<string, number>();

    for (const execution of executions) {
      const actions = execution.actions.map(a => a.type).join(' -> ');

      // Extract subsequences of length 2-4
      for (let len = 2; len <= 4; len++) {
        for (let i = 0; i <= actions.length - len; i++) {
          const subseq = execution.actions.slice(i, i + len).map(a => a.type).join(' -> ');
          sequenceCounts.set(subseq, (sequenceCounts.get(subseq) || 0) + 1);
        }
      }
    }

    // Find sequences that correlate with success
    for (const [sequence, count] of sequenceCounts) {
      if (count < this.minOccurrences) continue;

      const withSequence = executions.filter(e =>
        e.actions.map(a => a.type).join(' -> ').includes(sequence)
      );

      const successRate = withSequence.filter(e => e.outcomes.success).length / withSequence.length;
      const baselineRate = executions.filter(e => e.outcomes.success).length / executions.length;

      if (Math.abs(successRate - baselineRate) > 0.1) {
        sequences.push({
          sequence,
          count,
          successRate,
          baselineRate,
          improvement: successRate - baselineRate
        });
      }
    }

    return sequences;
  }

  private async findAnomalies(
    executions: ExecutionRecord[]
  ): Promise<AnomalyResult[]> {
    const anomalies: AnomalyResult[] = [];

    // Calculate baseline statistics
    const baseline = this.calculateBaselines(executions);

    // Find executions that deviate significantly
    for (const execution of executions) {
      const deviations: string[] = [];

      // Check for deviations in key metrics
      if (execution.outcomes.execution_time > baseline.time.mean + 2 * baseline.time.std) {
        deviations.push('high_execution_time');
      }

      if (execution.outcomes.fidelity_score < baseline.fidelity.mean - 2 * baseline.fidelity.std) {
        deviations.push('low_fidelity');
      }

      if (execution.outcomes.error_count > baseline.errors.mean + 2 * baseline.errors.std) {
        deviations.push('high_errors');
      }

      if (deviations.length > 0) {
        anomalies.push({
          executionId: execution.id,
          deviations,
          attributes: execution.attributes,
          timestamp: execution.timestamp
        });
      }
    }

    return anomalies;
  }

  private calculateCorrelation(
    data: ExecutionRecord[],
    getX: (e: ExecutionRecord) => any,
    getY: (e: ExecutionRecord) => number
  ): CorrelationCalculation {
    // Pearson correlation coefficient
    const pairs = data.map(e => ({ x: getX(e), y: getY(e) }));
    const numericPairs = pairs.filter(p => typeof p.x === 'number');

    if (numericPairs.length < 10) {
      return { coefficient: 0, pValue: 1 };
    }

    const n = numericPairs.length;
    const sumX = numericPairs.reduce((s, p) => s + p.x, 0);
    const sumY = numericPairs.reduce((s, p) => s + p.y, 0);
    const sumXY = numericPairs.reduce((s, p) => s + p.x * p.y, 0);
    const sumX2 = numericPairs.reduce((s, p) => s + p.x * p.x, 0);
    const sumY2 = numericPairs.reduce((s, p) => s + p.y * p.y, 0);

    const numerator = n * sumXY - sumX * sumY;
    const denominator = Math.sqrt(
      (n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY)
    );

    const coefficient = denominator !== 0 ? numerator / denominator : 0;

    // Simplified p-value calculation
    const t = coefficient * Math.sqrt((n - 2) / (1 - coefficient * coefficient));
    const pValue = 2 * (1 - this.tDistributionCDF(Math.abs(t), n - 2));

    return { coefficient, pValue };
  }
}
```

### Pattern Store

```typescript
// packages/meta/src/learning/pattern-store.ts

export class PatternStore {
  private readonly storage: Storage;

  constructor(storage: Storage) {
    this.storage = storage;
  }

  async save(pattern: Pattern): Promise<void> {
    await this.storage.set(`pattern:${pattern.id}`, pattern);
  }

  async saveAll(patterns: Pattern[]): Promise<void> {
    await Promise.all(patterns.map(p => this.save(p)));
  }

  async get(id: string): Promise<Pattern | null> {
    return this.storage.get(`pattern:${id}`);
  }

  async getAll(): Promise<Pattern[]> {
    const keys = await this.storage.keys('pattern:*');
    const patterns = await Promise.all(keys.map(k => this.storage.get(k)));
    return patterns.filter(Boolean) as Pattern[];
  }

  async getByType(type: PatternType): Promise<Pattern[]> {
    const all = await this.getAll();
    return all.filter(p => p.type === type);
  }

  async getHighConfidence(threshold: number = 80): Promise<Pattern[]> {
    const all = await this.getAll();
    return all.filter(p => p.confidence >= threshold);
  }

  async count(): Promise<number> {
    const keys = await this.storage.keys('pattern:*');
    return keys.length;
  }

  async delete(id: string): Promise<void> {
    await this.storage.delete(`pattern:${id}`);
  }
}
```

### Pattern Application

```typescript
// packages/meta/src/learning/pattern-applicator.ts

export class PatternApplicator {
  private readonly patternStore: PatternStore;

  constructor(patternStore: PatternStore) {
    this.patternStore = patternStore;
  }

  async getApplicablePatterns(context: ExecutionContext): Promise<Pattern[]> {
    const allPatterns = await this.patternStore.getHighConfidence();

    return allPatterns.filter(pattern => {
      return pattern.conditions.every(condition => {
        const value = context.attributes[condition.attribute];
        return this.matchesCondition(value, condition);
      });
    });
  }

  private matchesCondition(value: any, condition: PatternCondition): boolean {
    switch (condition.operator) {
      case 'eq':
        return value === condition.value;
      case 'neq':
        return value !== condition.value;
      case 'gt':
        return value > condition.value;
      case 'lt':
        return value < condition.value;
      case 'contains':
        return String(value).includes(String(condition.value));
      default:
        return false;
    }
  }

  async suggestOptimizations(context: ExecutionContext): Promise<OptimizationSuggestion[]> {
    const patterns = await this.getApplicablePatterns(context);
    const suggestions: OptimizationSuggestion[] = [];

    for (const pattern of patterns) {
      if (pattern.outcome.direction === 'increase' && pattern.outcome.magnitude > 0.1) {
        suggestions.push({
          patternId: pattern.id,
          description: `Based on pattern: ${pattern.description}`,
          expectedBenefit: pattern.outcome.magnitude,
          confidence: pattern.confidence,
          apply: async () => {
            // Return action to apply this pattern
            return { type: 'apply_pattern', patternId: pattern.id };
          }
        });
      }
    }

    // Sort by expected benefit
    return suggestions.sort((a, b) => b.expectedBenefit - a.expectedBenefit);
  }
}
```

---

## Business Value

O Pattern Learner permite que o Clone Lab **aprenda com sua própria execução**, identificando o que funciona e o que não funciona.

**Benefícios:**
- Identificação de padrões de sucesso
- Detecção de anomalias
- Base para melhorias automáticas
- Conhecimento acumulado sobre o sistema

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| False correlations | Medium | Medium | Statistical significance testing |
| Overfitting to recent data | Medium | Low | Time-based sampling |
| Pattern obsolescence | Medium | Low | Confidence decay over time |

---

## Scope

### In Scope
- PatternLearner class
- Correlation analysis
- Sequence pattern detection
- Anomaly detection
- Pattern store
- Pattern applicator

### Out of Scope
- ML-based learning
- Real-time learning
- External pattern sharing

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-029 (Metrics Collector) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Statistical Significance

```typescript
// Minimum thresholds for pattern acceptance
const LEARNING_THRESHOLDS = {
  minOccurrences: 5,          // At least 5 observations
  minConfidence: 70,          // 70% confidence
  maxPValue: 0.05,            // Statistical significance
  minCorrelation: 0.3         // Minimum correlation coefficient
};
```

### Confidence Decay

```typescript
// Patterns lose confidence over time if not reinforced
function applyConfidenceDecay(pattern: Pattern, daysSinceLastSeen: number): number {
  const decayRate = 0.01; // 1% per day
  return Math.max(0, pattern.confidence * Math.pow(1 - decayRate, daysSinceLastSeen));
}
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/learning/pattern-learner.ts` | Create | Pending |
| `packages/meta/src/learning/pattern-store.ts` | Create | Pending |
| `packages/meta/src/learning/pattern-applicator.ts` | Create | Pending |
| `packages/meta/src/learning/statistics.ts` | Create | Pending |
| `packages/meta/src/learning/types.ts` | Create | Pending |
| `packages/meta/src/learning/index.ts` | Create | Pending |
| `packages/meta/src/learning/__tests__/pattern-learner.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Correlation analysis works
- [ ] Sequence patterns detected
- [ ] Anomalies identified
- [ ] Patterns stored correctly
- [ ] Applicator suggests optimizations
- [ ] Statistical significance verified
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Correlation analysis works
- [ ] Sequence patterns detected
- [ ] Anomalies identified
- [ ] Patterns stored correctly
- [ ] Applicator suggests optimizations
- [ ] Statistical significance verified
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
