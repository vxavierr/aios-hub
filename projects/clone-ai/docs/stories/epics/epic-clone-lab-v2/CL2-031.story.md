# Story CL2-031: Bottleneck Detector

**Story ID:** CL2-031
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Bottleneck Detector** - componente que identifica gargalos de performance no sistema Clone Lab, analisando tempos de execução e padrões de uso.

### Problem Statement
O Clone Lab precisa identificar onde está perdendo tempo para otimizar a performance. O Bottleneck Detector analisa métricas de tempo para encontrar componentes que estão limitando a velocidade do sistema.

---

## Acceptance Criteria

```gherkin
Given the system has been running operations
When bottleneck detection is triggered
Then slow components are identified with severity levels

Given a mind is consistently slow
When detection runs
Then the specific mind is flagged as a bottleneck

Given multiple bottlenecks exist
When prioritization occurs
Then bottlenecks are ranked by impact on overall performance

Given a bottleneck is identified
When root cause analysis runs
Then potential causes are suggested
```

---

## Technical Requirements

### Bottleneck Detector

```typescript
// packages/meta/src/analysis/bottleneck-detector.ts

export interface Bottleneck {
  id: string;
  component: string;            // Component identifier
  type: 'mind' | 'task' | 'checkpoint' | 'pipeline' | 'storage';
  severity: 'low' | 'medium' | 'high' | 'critical';
  averageDuration: number;      // ms
  expectedDuration: number;     // ms (baseline)
  impact: number;               // % impact on total time
  occurrences: number;          // How often it occurs
  trend: 'improving' | 'stable' | 'worsening';
  rootCauses: RootCauseHint[];
  detectedAt: Date;
}

export interface RootCauseHint {
  type: string;
  description: string;
  likelihood: number;           // 0-100
  suggestedAction: string;
}

export class BottleneckDetector {
  private readonly metricsCollector: MetricsCollector;
  private readonly thresholds: BottleneckThresholds;

  constructor(
    metricsCollector: MetricsCollector,
    config: DetectorConfig
  ) {
    this.metricsCollector = metricsCollector;
    this.thresholds = config.thresholds;
  }

  async detect(timeRange?: TimeRange): Promise<Bottleneck[]> {
    const range = timeRange || this.getDefaultRange();
    const bottlenecks: Bottleneck[] = [];

    // Analyze minds
    const mindBottlenecks = await this.detectMindBottlenecks(range);
    bottlenecks.push(...mindBottlenecks);

    // Analyze validation tasks
    const taskBottlenecks = await this.detectTaskBottlenecks(range);
    bottlenecks.push(...taskBottlenecks);

    // Analyze checkpoints
    const checkpointBottlenecks = await this.detectCheckpointBottlenecks(range);
    bottlenecks.push(...checkpointBottlenecks);

    // Analyze pipeline phases
    const pipelineBottlenecks = await this.detectPipelineBottlenecks(range);
    bottlenecks.push(...pipelineBottlenecks);

    // Sort by impact
    return this.prioritize(bottlenecks);
  }

  private async detectMindBottlenecks(range: TimeRange): Promise<Bottleneck[]> {
    const bottlenecks: Bottleneck[] = [];
    const mindIds = ['tim', 'daniel', 'brene', 'barbara', 'charlie', 'constantin', 'quinn', 'victoria'];

    for (const mindId of mindIds) {
      const metrics = await this.metricsCollector.getAggregated(
        'mind_analysis_duration_seconds',
        range,
        'avg',
        { mind_id: mindId }
      );

      if (metrics.length === 0) continue;

      const avgDuration = metrics[0].value * 1000; // Convert to ms
      const baseline = this.thresholds.mindBaseline[mindId] || 5000;

      if (avgDuration > baseline * this.thresholds.slowMultiplier) {
        bottlenecks.push({
          id: `mind-${mindId}`,
          component: `mind/${mindId}`,
          type: 'mind',
          severity: this.calculateSeverity(avgDuration, baseline),
          averageDuration: avgDuration,
          expectedDuration: baseline,
          impact: await this.calculateImpact(mindId, avgDuration),
          occurrences: await this.getOccurrenceCount('mind', mindId, range),
          trend: await this.getTrend('mind', mindId, range),
          rootCauses: await this.analyzeRootCauses('mind', mindId, metrics),
          detectedAt: new Date()
        });
      }
    }

    return bottlenecks;
  }

  private calculateSeverity(actual: number, expected: number): Bottleneck['severity'] {
    const ratio = actual / expected;

    if (ratio >= 5) return 'critical';
    if (ratio >= 3) return 'high';
    if (ratio >= 2) return 'medium';
    return 'low';
  }

  private async analyzeRootCauses(
    type: string,
    component: string,
    metrics: AggregatedMetric[]
  ): Promise<RootCauseHint[]> {
    const causes: RootCauseHint[] = [];

    // Check for high variance (inconsistent performance)
    const variance = this.calculateVariance(metrics);
    if (variance > 0.5) {
      causes.push({
        type: 'inconsistent_performance',
        description: 'Performance varies significantly between runs',
        likelihood: 70,
        suggestedAction: 'Investigate external dependencies or caching issues'
      });
    }

    // Check for increasing trend (degrading over time)
    const trend = this.calculateTrend(metrics);
    if (trend > 0.1) {
      causes.push({
        type: 'degrading_performance',
        description: 'Performance is getting worse over time',
        likelihood: 60,
        suggestedAction: 'Check for memory leaks or growing data volumes'
      });
    }

    // Type-specific analysis
    if (type === 'mind') {
      causes.push({
        type: 'complex_input',
        description: 'Input data may be unusually complex',
        likelihood: 40,
        suggestedAction: 'Analyze input patterns and consider pre-processing'
      });
    }

    return causes;
  }
}
```

### Thresholds Configuration

```typescript
// packages/meta/src/analysis/bottleneck-config.ts

export interface BottleneckThresholds {
  slowMultiplier: number;        // Times baseline to be "slow"
  criticalMultiplier: number;    // Times baseline to be "critical"
  mindBaseline: Record<string, number>;  // Expected durations per mind
  taskBaseline: Record<string, number>;  // Expected durations per task category
  checkpointBaseline: Record<string, number>;
}

export const DEFAULT_THRESHOLDS: BottleneckThresholds = {
  slowMultiplier: 1.5,
  criticalMultiplier: 3.0,

  mindBaseline: {
    tim: 3000,        // Extraction is usually fast
    daniel: 5000,
    brene: 4000,
    barbara: 6000,    // Cognitive analysis is complex
    charlie: 8000,    // Synthesis is most complex
    constantin: 5000,
    quinn: 4000,
    victoria: 5000
  },

  taskBaseline: {
    extraction: 500,
    behavioral: 1000,
    values: 800,
    cognitive: 1200,
    synthesis: 1500,
    implementation: 1000,
    quality: 800
  },

  checkpointBaseline: {
    'cp-1': 5000,     // Source validation
    'cp-2': 8000,     // Analysis review
    'cp-3': 10000,    // DNA approval
    'cp-4': 15000,    // Prompt testing
    'cp-5': 8000,     // Clone acceptance
    'cp-6': 5000      // Fidelity confirmation
  }
};
```

### Bottleneck Report

```typescript
// packages/meta/src/analysis/bottleneck-report.ts

export class BottleneckReportGenerator {
  generate(bottlenecks: Bottleneck[]): BottleneckReport {
    const summary = this.generateSummary(bottlenecks);
    const byType = this.groupByType(bottlenecks);
    const recommendations = this.generateRecommendations(bottlenecks);

    return {
      generatedAt: new Date(),
      summary,
      bottlenecks,
      byType,
      recommendations,
      totalImpact: this.calculateTotalImpact(bottlenecks)
    };
  }

  private generateSummary(bottlenecks: Bottleneck[]): ReportSummary {
    return {
      total: bottlenecks.length,
      critical: bottlenecks.filter(b => b.severity === 'critical').length,
      high: bottlenecks.filter(b => b.severity === 'high').length,
      medium: bottlenecks.filter(b => b.severity === 'medium').length,
      low: bottlenecks.filter(b => b.severity === 'low').length,
      worstOffender: bottlenecks[0]?.component || 'none',
      estimatedTimeSavings: this.estimateTimeSavings(bottlenecks)
    };
  }

  private estimateTimeSavings(bottlenecks: Bottleneck[]): number {
    // Calculate potential time savings if bottlenecks were fixed
    return bottlenecks.reduce((total, b) => {
      const savingsPerOccurrence = b.averageDuration - b.expectedDuration;
      return total + (savingsPerOccurrence * b.occurrences);
    }, 0);
  }
}
```

---

## Business Value

O Bottleneck Detector é essencial para **otimização de performance** - identifica onde o sistema está lento para que melhorias possam ser aplicadas.

**Benefícios:**
- Identificação proativa de problemas de performance
- Priorização baseada em impacto real
- Dicas de causa raiz para agilizar correções
- Estimativa de tempo recuperável

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| False positives | Medium | Low | Adjustable thresholds |
| Overhead in detection | Low | Low | Async analysis |
| Baselines outdated | Medium | Medium | Auto-adjust baselines |

---

## Scope

### In Scope
- BottleneckDetector class
- Detection for minds, tasks, checkpoints, pipeline
- Root cause analysis hints
- Report generator
- Configurable thresholds

### Out of Scope
- Auto-optimization
- Real-time alerting
- Distributed tracing

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-029 (Metrics Collector) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Baseline Update Strategy

```typescript
// Auto-adjust baselines weekly based on actual performance
async function updateBaselines(): Promise<void> {
  const recentMetrics = await getRecentMetrics(7); // Last 7 days
  const newBaseline = calculateP50(recentMetrics);
  await saveBaseline(component, newBaseline);
}
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/analysis/bottleneck-detector.ts` | Create | Pending |
| `packages/meta/src/analysis/bottleneck-config.ts` | Create | Pending |
| `packages/meta/src/analysis/bottleneck-report.ts` | Create | Pending |
| `packages/meta/src/analysis/types.ts` | Create | Pending |
| `packages/meta/src/analysis/index.ts` | Create | Pending |
| `packages/meta/src/analysis/__tests__/bottleneck-detector.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] BottleneckDetector identifies slow components
- [ ] Severity calculated correctly
- [ ] Root cause hints generated
- [ ] Prioritization by impact works
- [ ] Report generator produces useful reports
- [ ] Thresholds configurable
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] BottleneckDetector identifies slow components
- [ ] Severity calculated correctly
- [ ] Root cause hints generated
- [ ] Prioritization by impact works
- [ ] Report generator produces useful reports
- [ ] Thresholds configurable
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
