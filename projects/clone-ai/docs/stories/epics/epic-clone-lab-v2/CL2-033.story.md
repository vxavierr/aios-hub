# Story CL2-033: Recommendation Engine

**Story ID:** CL2-033
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Recommendation Engine** - componente que agrega insights de assessment, bottlenecks e optimization para gerar recomendações priorizadas e acionáveis.

### Problem Statement
O Clone Lab gera muitos insights de diferentes componentes (assessment, bottlenecks, optimizer). O Recommendation Engine consolida estes insights em recomendações claras, priorizadas e acionáveis.

---

## Acceptance Criteria

```gherkin
Given multiple insights exist from various sources
When recommendations are generated
Then they are consolidated and deduplicated

Given recommendations exist
When prioritization occurs
Then recommendations are ranked by impact and urgency

Given a recommendation is selected
When implementation details are requested
Then clear action steps are provided

Given a recommendation is applied
When tracking is needed
Then the recommendation is linked to the improvement
```

---

## Technical Requirements

### Recommendation Engine

```typescript
// packages/meta/src/recommendations/engine.ts

export interface Recommendation {
  id: string;
  title: string;
  description: string;
  category: RecommendationCategory;
  priority: Priority;
  impact: ImpactAssessment;
  effort: EffortEstimate;
  sources: InsightSource[];       // Where this came from
  actions: Action[];
  relatedRecommendations: string[];
  status: 'pending' | 'approved' | 'in_progress' | 'completed' | 'rejected';
  createdAt: Date;
  updatedAt: Date;
}

export type RecommendationCategory =
  | 'performance' | 'quality' | 'reliability'
  | 'maintainability' | 'security' | 'usability';

export interface Priority {
  score: number;              // 0-100 composite score
  urgency: 'immediate' | 'short_term' | 'medium_term' | 'long_term';
  importance: 'critical' | 'high' | 'medium' | 'low';
}

export interface ImpactAssessment {
  score: number;              // 0-100
  metrics: {
    timeSaving?: number;
    qualityImprovement?: number;
    reliabilityImprovement?: number;
    riskReduction?: number;
  };
  affectedComponents: string[];
}

export interface Action {
  id: string;
  description: string;
  type: 'code_change' | 'config_change' | 'process_change' | 'documentation';
  estimatedEffort: string;    // e.g., "2 hours", "1 day"
  dependencies: string[];
  verification: string;       // How to verify completion
}

export class RecommendationEngine {
  private readonly assessmentEngine: SelfAssessmentEngine;
  private readonly bottleneckDetector: BottleneckDetector;
  private readonly processOptimizer: ProcessOptimizer;

  constructor(
    assessmentEngine: SelfAssessmentEngine,
    bottleneckDetector: BottleneckDetector,
    processOptimizer: ProcessOptimizer
  ) {
    this.assessmentEngine = assessmentEngine;
    this.bottleneckDetector = bottleneckDetector;
    this.processOptimizer = processOptimizer;
  }

  async generateRecommendations(): Promise<RecommendationSet> {
    // Gather insights from all sources
    const assessment = await this.assessmentEngine.assess();
    const bottlenecks = await this.bottleneckDetector.detect();
    const optimizations = await this.processOptimizer.analyze();

    // Convert to recommendation candidates
    const candidates: RecommendationCandidate[] = [
      ...this.fromAssessment(assessment),
      ...this.fromBottlenecks(bottlenecks),
      ...this.fromOptimizations(optimizations)
    ];

    // Consolidate and deduplicate
    const consolidated = this.consolidate(candidates);

    // Prioritize
    const prioritized = this.prioritize(consolidated);

    return {
      generatedAt: new Date(),
      recommendations: prioritized,
      summary: this.generateSummary(prioritized),
      quickWins: this.identifyQuickWins(prioritized),
      highImpact: this.identifyHighImpact(prioritized)
    };
  }

  private fromAssessment(assessment: SelfAssessmentResult): RecommendationCandidate[] {
    return assessment.issues.map(issue => ({
      title: this.generateTitle(issue),
      description: issue.description,
      category: this.mapCategory(issue.category),
      impact: {
        score: issue.severity === 'high' ? 80 : issue.severity === 'medium' ? 50 : 20,
        metrics: {},
        affectedComponents: [issue.category]
      },
      sources: [{ type: 'assessment', id: assessment.id }],
      raw: issue
    }));
  }

  private fromBottlenecks(bottlenecks: Bottleneck[]): RecommendationCandidate[] {
    return bottlenecks.map(b => ({
      title: `Address bottleneck in ${b.component}`,
      description: `${b.component} is ${Math.round(b.averageDuration / b.expectedDuration)}x slower than expected`,
      category: 'performance' as RecommendationCategory,
      impact: {
        score: Math.min(100, b.impact),
        metrics: { timeSaving: (b.averageDuration - b.expectedDuration) * b.occurrences },
        affectedComponents: [b.component]
      },
      sources: [{ type: 'bottleneck', id: b.id }],
      raw: b
    }));
  }

  private fromOptimizations(optimizations: OptimizationAnalysis): RecommendationCandidate[] {
    return optimizations.opportunities.map(o => ({
      title: this.generateOptimizationTitle(o),
      description: o.description,
      category: this.mapOptimizationCategory(o.type),
      impact: {
        score: Math.min(100, o.impact.timeSaving / 10),
        metrics: { timeSaving: o.impact.timeSaving },
        affectedComponents: [o.target]
      },
      sources: [{ type: 'optimization', id: o.id }],
      autoApplicable: o.autoApplicable,
      raw: o
    }));
  }

  private consolidate(candidates: RecommendationCandidate[]): Recommendation[] {
    const groups = this.groupSimilar(candidates);

    return groups.map(group => {
      if (group.length === 1) {
        return this.toRecommendation(group[0]);
      }

      // Merge similar recommendations
      return this.mergeRecommendations(group);
    });
  }

  private prioritize(recommendations: Recommendation[]): Recommendation[] {
    return recommendations.sort((a, b) => {
      // Sort by priority score descending
      return b.priority.score - a.priority.score;
    });
  }

  calculatePriorityScore(rec: Recommendation): number {
    const weights = {
      impact: 0.4,
      urgency: 0.3,
      effort: 0.2,
      autoApplicable: 0.1
    };

    const urgencyScore = {
      immediate: 100,
      short_term: 75,
      medium_term: 50,
      long_term: 25
    };

    const effortScore = {
      trivial: 100,
      small: 75,
      medium: 50,
      large: 25,
      xlarge: 10
    };

    return Math.round(
      rec.impact.score * weights.impact +
      (urgencyScore[rec.priority.urgency] || 50) * weights.urgency +
      (effortScore[rec.effort.estimate] || 50) * weights.effort +
      (rec.sources.some(s => s.type === 'optimization') ? 10 : 0) * weights.autoApplicable
    );
  }
}
```

### Recommendation Actions

```typescript
// packages/meta/src/recommendations/actions.ts

export class RecommendationActionGenerator {
  generateActions(recommendation: Recommendation): Action[] {
    const actions: Action[] = [];

    switch (recommendation.category) {
      case 'performance':
        actions.push(...this.generatePerformanceActions(recommendation));
        break;
      case 'quality':
        actions.push(...this.generateQualityActions(recommendation));
        break;
      case 'reliability':
        actions.push(...this.generateReliabilityActions(recommendation));
        break;
      default:
        actions.push(...this.generateGenericActions(recommendation));
    }

    return actions;
  }

  private generatePerformanceActions(rec: Recommendation): Action[] {
    return [
      {
        id: `${rec.id}-action-1`,
        description: `Profile ${rec.affectedComponents[0]} to identify slow operations`,
        type: 'process_change',
        estimatedEffort: '2 hours',
        dependencies: [],
        verification: 'Profiling report generated'
      },
      {
        id: `${rec.id}-action-2`,
        description: 'Implement identified optimizations',
        type: 'code_change',
        estimatedEffort: '4 hours',
        dependencies: [`${rec.id}-action-1`],
        verification: 'Performance test shows improvement'
      },
      {
        id: `${rec.id}-action-3`,
        description: 'Add performance regression test',
        type: 'code_change',
        estimatedEffort: '1 hour',
        dependencies: [`${rec.id}-action-2`],
        verification: 'Test passes in CI'
      }
    ];
  }
}
```

---

## Business Value

O Recommendation Engine é o **agregador de insights** - transforma dados crus em recomendações acionáveis que desenvolvedores podem implementar.

**Benefícios:**
- Consolida insights de múltiplas fontes
- Priorização automática por impacto
- Planos de ação detalhados
- Base para auto-improvement

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Too many recommendations | High | Low | Limit + prioritization |
| Recommendations overlap | Medium | Low | Deduplication logic |
| Stale recommendations | Medium | Medium | Time-based filtering |

---

## Scope

### In Scope
- RecommendationEngine class
- Insight consolidation and deduplication
- Priority scoring
- Action generation
- Quick wins and high impact identification

### Out of Scope
- Auto-application of recommendations
- ML-based recommendations
- Recommendation scheduling

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-030 (Self-Assessment) | Package | Pending |
| CL2-031 (Bottleneck Detector) | Package | Pending |
| CL2-032 (Process Optimizer) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Priority Score Formula

```typescript
// Higher is more important
priorityScore = (impactScore * 0.4) +
                (urgencyScore * 0.3) +
                ((100 - effortScore) * 0.2) +
                (isAutoApplicable ? 10 : 0);
```

### Quick Win Definition

```typescript
// Quick win: High impact, low effort
const isQuickWin = (rec: Recommendation) =>
  rec.impact.score > 50 && effortScore(rec) < 30;
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/recommendations/engine.ts` | Create | Pending |
| `packages/meta/src/recommendations/actions.ts` | Create | Pending |
| `packages/meta/src/recommendations/types.ts` | Create | Pending |
| `packages/meta/src/recommendations/index.ts` | Create | Pending |
| `packages/meta/src/recommendations/__tests__/engine.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Recommendations generated from all sources
- [ ] Similar recommendations consolidated
- [ ] Priority scoring works correctly
- [ ] Actions generated for recommendations
- [ ] Quick wins identified
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Recommendations generated from all sources
- [ ] Similar recommendations consolidated
- [ ] Priority scoring works correctly
- [ ] Actions generated for recommendations
- [ ] Quick wins identified
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
