# Story CL2-037: Change Applier

**Story ID:** CL2-037
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Change Applier** - componente responsável por aplicar mudanças aprovadas de forma segura, capturando estados before/after e integrando com o sistema de rollback.

### Problem Statement
O Clone Lab precisa de uma forma segura de aplicar mudanças automáticas. O Change Applier aplica mudanças, captura estados para rollback, e registra tudo no evolution log.

---

## Acceptance Criteria

```gherkin
Given a change is approved
When the applier applies it
Then the change is made and logged with before/after states

Given a change requires file modification
When the applier processes it
Then a backup is created before modification

Given a change fails to apply
When the applier handles the error
Then the system is restored to previous state

Given multiple changes are queued
When the applier processes them
Then they are applied in order with proper isolation
```

---

## Technical Requirements

### Change Applier

```typescript
// packages/meta/src/change-applier/applier.ts

export interface AppliedChange {
  id: string;
  improvement: ImprovementCandidate;
  appliedAt: Date;
  appliedBy: 'auto' | 'human';
  beforeState: ChangeState;
  afterState: ChangeState;
  restorePoint: RestorePoint;
  status: 'applied' | 'failed' | 'rolled_back';
  error?: string;
}

export interface ChangeState {
  files: FileSnapshot[];
  config: ConfigSnapshot;
  timestamp: Date;
}

export interface FileSnapshot {
  path: string;
  content: string;
  hash: string;
  exists: boolean;
}

export interface RestorePoint {
  id: string;
  createdAt: Date;
  type: 'full' | 'incremental';
  data: Buffer | string;        // Path to restore data
}

export class ChangeApplier {
  private readonly fileSystem: FileSystemAccess;
  private readonly evolutionLog: EvolutionLog;
  private readonly snapshotManager: SnapshotManager;

  constructor(
    fileSystem: FileSystemAccess,
    evolutionLog: EvolutionLog,
    snapshotManager: SnapshotManager
  ) {
    this.fileSystem = fileSystem;
    this.evolutionLog = evolutionLog;
    this.snapshotManager = snapshotManager;
  }

  async apply(improvement: ImprovementCandidate): Promise<AppliedChange> {
    const changeId = generateId();

    // 1. Capture before state
    const beforeState = await this.captureState(improvement.target);

    // 2. Create restore point
    const restorePoint = await this.createRestorePoint(improvement);

    try {
      // 3. Apply the change based on category
      await this.applyChange(improvement);

      // 4. Capture after state
      const afterState = await this.captureState(improvement.target);

      // 5. Verify change was applied
      await this.verifyChange(improvement, beforeState, afterState);

      // 6. Log the successful change
      const applied: AppliedChange = {
        id: changeId,
        improvement,
        appliedAt: new Date(),
        appliedBy: improvement.autoApplicable ? 'auto' : 'human',
        beforeState,
        afterState,
        restorePoint,
        status: 'applied'
      };

      await this.evolutionLog.logChange(applied);

      return applied;

    } catch (error) {
      // Rollback on failure
      await this.rollback(restorePoint);

      const failed: AppliedChange = {
        id: changeId,
        improvement,
        appliedAt: new Date(),
        appliedBy: improvement.autoApplicable ? 'auto' : 'human',
        beforeState,
        afterState: beforeState, // No change
        restorePoint,
        status: 'failed',
        error: error.message
      };

      await this.evolutionLog.logChange(failed);

      throw new ChangeApplicationError(
        `Failed to apply change: ${error.message}`,
        { improvement, restorePoint }
      );
    }
  }

  private async captureState(target: string): Promise<ChangeState> {
    const files: FileSnapshot[] = [];

    // Determine files to snapshot based on target
    const filePaths = await this.resolveTargetFiles(target);

    for (const filePath of filePaths) {
      const exists = await this.fileSystem.exists(filePath);
      const snapshot: FileSnapshot = {
        path: filePath,
        content: exists ? await this.fileSystem.read(filePath) : '',
        hash: exists ? await this.fileSystem.hash(filePath) : '',
        exists
      };
      files.push(snapshot);
    }

    return {
      files,
      config: await this.captureConfig(),
      timestamp: new Date()
    };
  }

  private async createRestorePoint(improvement: ImprovementCandidate): Promise<RestorePoint> {
    return this.snapshotManager.createRestorePoint({
      id: `rp-${improvement.id}`,
      targets: [improvement.target],
      reason: `Pre-change restore point for ${improvement.id}`
    });
  }

  private async applyChange(improvement: ImprovementCandidate): Promise<void> {
    switch (improvement.category) {
      case 'remove':
        await this.applyRemoval(improvement);
        break;
      case 'add':
        await this.applyAddition(improvement);
        break;
      case 'modify':
        await this.applyModification(improvement);
        break;
      case 'optimize':
        await this.applyOptimization(improvement);
        break;
      default:
        throw new Error(`Unknown change category: ${improvement.category}`);
    }
  }

  private async applyRemoval(improvement: ImprovementCandidate): Promise<void> {
    const targetPath = this.resolvePath(improvement.target);

    // Check if target exists
    if (!(await this.fileSystem.exists(targetPath))) {
      console.warn(`Target does not exist: ${targetPath}`);
      return;
    }

    // Move to trash/backups instead of deleting
    const backupPath = this.getBackupPath(improvement.target);
    await this.fileSystem.move(targetPath, backupPath);
  }

  private async applyAddition(improvement: ImprovementCandidate): Promise<void> {
    const targetPath = this.resolvePath(improvement.target);
    const content = improvement.content || this.generateDefaultContent(improvement);

    await this.fileSystem.write(targetPath, content);
  }

  private async applyModification(improvement: ImprovementCandidate): Promise<void> {
    const targetPath = this.resolvePath(improvement.target);

    if (!(await this.fileSystem.exists(targetPath))) {
      throw new Error(`Cannot modify non-existent file: ${targetPath}`);
    }

    // Apply patch or full replacement
    if (improvement.patch) {
      await this.applyPatch(targetPath, improvement.patch);
    } else if (improvement.content) {
      await this.fileSystem.write(targetPath, improvement.content);
    }
  }

  private async applyOptimization(improvement: ImprovementCandidate): Promise<void> {
    // Optimizations are often code transformations
    const targetPath = this.resolvePath(improvement.target);
    const currentContent = await this.fileSystem.read(targetPath);

    // Apply optimization transformation
    const optimized = await this.transformForOptimization(
      currentContent,
      improvement
    );

    await this.fileSystem.write(targetPath, optimized);
  }

  private async rollback(restorePoint: RestorePoint): Promise<void> {
    console.log(`Rolling back to restore point: ${restorePoint.id}`);
    await this.snapshotManager.restore(restorePoint);
  }
}
```

### Batch Applier

```typescript
// packages/meta/src/change-applier/batch-applier.ts

export class BatchChangeApplier {
  private readonly applier: ChangeApplier;
  private readonly config: BatchConfig;

  constructor(applier: ChangeApplier, config: BatchConfig) {
    this.applier = applier;
    this.config = config;
  }

  async applyBatch(
    improvements: ImprovementCandidate[]
  ): Promise<BatchResult> {
    const results: AppliedChange[] = [];
    const failed: Array<{ improvement: ImprovementCandidate; error: Error }> = [];

    // Sort by dependencies
    const sorted = this.sortByDependencies(improvements);

    for (const improvement of sorted) {
      try {
        // Check if dependencies succeeded
        if (!this.dependenciesSatisfied(improvement, results)) {
          failed.push({
            improvement,
            error: new Error('Dependencies not satisfied')
          });
          continue;
        }

        // Apply with cooldown between changes
        const result = await this.applier.apply(improvement);
        results.push(result);

        // Cooldown between changes
        await this.delay(this.config.cooldownMs);

      } catch (error) {
        failed.push({ improvement, error });

        // Stop on first failure if configured
        if (this.config.stopOnFirstFailure) {
          break;
        }
      }
    }

    return {
      applied: results,
      failed,
      successRate: results.length / improvements.length
    };
  }

  private sortByDependencies(
    improvements: ImprovementCandidate[]
  ): ImprovementCandidate[] {
    // Topological sort based on dependencies
    const graph = new DependencyGraph<ImprovementCandidate>();

    for (const imp of improvements) {
      graph.addNode(imp.id, imp);
    }

    // Add dependency edges
    for (const imp of improvements) {
      for (const dep of imp.dependencies || []) {
        graph.addEdge(dep, imp.id);
      }
    }

    return graph.topologicalSort();
  }
}
```

### File System Access

```typescript
// packages/meta/src/change-applier/file-system.ts

export interface FileSystemAccess {
  read(path: string): Promise<string>;
  write(path: string, content: string): Promise<void>;
  exists(path: string): Promise<boolean>;
  move(source: string, destination: string): Promise<void>;
  hash(path: string): Promise<string>;
  list(dir: string): Promise<string[]>;
}

export class NodeFileSystemAccess implements FileSystemAccess {
  private readonly fs = require('fs').promises;
  private readonly path = require('path');

  async read(path: string): Promise<string> {
    return this.fs.readFile(path, 'utf-8');
  }

  async write(path: string, content: string): Promise<void> {
    // Ensure directory exists
    const dir = this.path.dirname(path);
    await this.fs.mkdir(dir, { recursive: true });

    // Write file
    await this.fs.writeFile(path, content, 'utf-8');
  }

  async exists(path: string): Promise<boolean> {
    try {
      await this.fs.access(path);
      return true;
    } catch {
      return false;
    }
  }

  async move(source: string, destination: string): Promise<void> {
    const destDir = this.path.dirname(destination);
    await this.fs.mkdir(destDir, { recursive: true });
    await this.fs.rename(source, destination);
  }

  async hash(path: string): Promise<string> {
    const crypto = require('crypto');
    const content = await this.read(path);
    return crypto.createHash('sha256').update(content).digest('hex');
  }
}
```

---

## Business Value

O Change Applier é o **executor seguro** de mudanças - aplica melhorias mantendo a capacidade de rollback e auditabilidade completa.

**Benefícios:**
- Aplicação segura de mudanças
- Estados before/after para auditoria
- Restore points automáticos
- Rollback automático em falhas

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Partial application failure | Medium | High | Transaction-like rollback |
| File corruption | Low | Critical | Backup before change |
| Concurrent modification | Low | Medium | File locking |

---

## Scope

### In Scope
- ChangeApplier class
- BatchChangeApplier
- FileSystemAccess interface
- State capture and restore
- Error handling and rollback

### Out of Scope
- Distributed change application
- Real-time file watching
- External system integration

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-041 (Evolution Log) | Package | Pending |
| CL2-042 (Snapshot System) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Backup Path Convention

```typescript
function getBackupPath(target: string): string {
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  return `.backups/${target}.${timestamp}.bak`;
}
```

### Cooldown Strategy

```typescript
const BATCH_CONFIG = {
  cooldownMs: 1000,           // 1s between changes
  stopOnFirstFailure: false,   // Continue on failure
  maxBatchSize: 10            // Max changes per batch
};
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/change-applier/applier.ts` | Create | Pending |
| `packages/meta/src/change-applier/batch-applier.ts` | Create | Pending |
| `packages/meta/src/change-applier/file-system.ts` | Create | Pending |
| `packages/meta/src/change-applier/types.ts` | Create | Pending |
| `packages/meta/src/change-applier/index.ts` | Create | Pending |
| `packages/meta/src/change-applier/__tests__/applier.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Changes applied correctly by category
- [ ] Before/after states captured
- [ ] Restore points created
- [ ] Rollback works on failure
- [ ] Batch application works
- [ ] Evolution log integration works
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Changes applied correctly by category
- [ ] Before/after states captured
- [ ] Restore points created
- [ ] Rollback works on failure
- [ ] Batch application works
- [ ] Evolution log integration works
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
