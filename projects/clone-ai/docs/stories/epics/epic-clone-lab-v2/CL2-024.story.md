# Story CL2-024: CP-3 DNA Approval Checkpoint

**Story ID:** CL2-024
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 2 - Validation
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar o **Checkpoint 3 (CP-3)** - DNA Approval, que revisa o DNA sintetizado da personalidade e solicita aprovacao antes de gerar prompts.

### Problem Statement
O DNA da personalidade eh o nucleo do clone e requer aprovacao humana para garantir que representa fielmente a pessoa sendo clonada.

---

## Acceptance Criteria

```gherkin
Given synthesized personality DNA
When CP-3 evaluates the DNA
Then it returns an assessment of DNA quality

Given DNA with missing dimensions
When CP-3 evaluates
Then it identifies gaps and recommends fixes

Given DNA ready for approval
When human reviews
Then clear presentation of DNA components is available

Given DNA approved
When the checkpoint completes
Then prompt generation can proceed
```

---

## Technical Requirements

### Checkpoint Implementation

```typescript
// packages/validation/src/checkpoints/cp-3-dna-approval.ts

import { ICheckpoint, CheckpointDefinition, CheckpointContext, CheckpointResult, CheckpointDetail } from './checkpoint.interface';

export class CP3DNAApproval implements ICheckpoint {
  readonly definition: CheckpointDefinition = {
    id: 'CP-3',
    name: 'DNA Approval',
    description: 'Reviews and approves the synthesized personality DNA before prompt generation',
    triggerPhase: 'synthesis',
    requiredApprovals: 1,
    autoApproveConditions: [
      'allDnaDimensionsPresent',
      'synthesisCoherenceScore >= 80',
      'noCriticalParadoxes',
      'fidelityProjection >= 70'
    ],
    timeout: 24 * 60 * 60 * 1000  // 24 hours (important decision)
  };

  async evaluate(context: CheckpointContext): Promise<CheckpointResult> {
    const details: CheckpointDetail[] = [];
    const recommendations: string[] = [];

    const dna = context.dna;
    if (!dna) {
      return {
        checkpointId: this.definition.id,
        status: 'failed',
        score: 0,
        summary: 'DNA not available for review',
        details: [{
          category: 'DNA Availability',
          status: 'fail',
          message: 'Personality DNA has not been synthesized'
        }],
        recommendations: ['Run DNA synthesis before this checkpoint'],
        timestamp: new Date()
      };
    }

    // 1. DNA Completeness
    const completenessAssessment = this.assessCompleteness(dna);
    details.push({
      category: 'DNA Completeness',
      status: completenessAssessment.status,
      message: completenessAssessment.message,
      evidence: `Dimensions present: ${completenessAssessment.dimensionsPresent}/${completenessAssessment.totalDimensions}`
    });

    // 2. Behavioral Profile
    const behavioralAssessment = this.assessBehavioralProfile(dna);
    details.push({
      category: 'Behavioral Profile',
      status: behavioralAssessment.status,
      message: behavioralAssessment.message,
      evidence: behavioralAssessment.summary
    });

    // 3. Values & Beliefs
    const valuesAssessment = this.assessValuesProfile(dna);
    details.push({
      category: 'Values & Beliefs',
      status: valuesAssessment.status,
      message: valuesAssessment.message,
      evidence: `Core values: ${valuesAssessment.valuesCount}, Beliefs: ${valuesAssessment.beliefsCount}`
    });

    // 4. Cognitive Profile
    const cognitiveAssessment = this.assessCognitiveProfile(dna);
    details.push({
      category: 'Cognitive Profile',
      status: cognitiveAssessment.status,
      message: cognitiveAssessment.message,
      evidence: cognitiveAssessment.summary
    });

    // 5. Voice & Style
    const voiceAssessment = this.assessVoiceProfile(dna);
    details.push({
      category: 'Voice & Style',
      status: voiceAssessment.status,
      message: voiceAssessment.message,
      evidence: voiceAssessment.characteristics.slice(0, 5).join(', ')
    });

    // 6. Coherence Check
    const coherenceAssessment = this.assessCoherence(dna, context);
    details.push({
      category: 'DNA Coherence',
      status: coherenceAssessment.status,
      message: coherenceAssessment.message,
      evidence: `Coherence score: ${coherenceAssessment.coherenceScore}%`
    });

    // 7. Fidelity Projection
    const fidelityAssessment = this.assessFidelityProjection(context);
    details.push({
      category: 'Fidelity Projection',
      status: fidelityAssessment.status,
      message: fidelityAssessment.message,
      evidence: `Projected fidelity: ${fidelityAssessment.projectedFidelity}%`
    });

    // Calculate overall score
    const score = this.calculateScore([
      completenessAssessment,
      behavioralAssessment,
      valuesAssessment,
      cognitiveAssessment,
      voiceAssessment,
      coherenceAssessment,
      fidelityAssessment
    ]);

    // Generate recommendations
    if (completenessAssessment.status !== 'pass') {
      recommendations.push('Complete missing DNA dimensions before proceeding');
    }
    if (coherenceAssessment.paradoxes && coherenceAssessment.paradoxes.length > 0) {
      recommendations.push(`Review ${coherenceAssessment.paradoxes.length} identified paradoxes in the DNA`);
    }
    if (fidelityAssessment.projectedFidelity < 70) {
      recommendations.push('Consider adding more source content to improve projected fidelity');
    }

    const hasFail = details.some(d => d.status === 'fail');
    const hasWarn = details.some(d => d.status === 'warn');

    return {
      checkpointId: this.definition.id,
      status: hasFail ? 'waiting_approval' : (hasWarn ? 'waiting_approval' : 'pending'),
      score,
      summary: this.generateSummary(score, details),
      details,
      recommendations,
      timestamp: new Date()
    };
  }

  canAutoApprove(result: CheckpointResult): boolean {
    // DNA approval should generally require human review
    // Only auto-approve if score is very high and no warnings
    const hasFail = result.details.some(d => d.status === 'fail');
    const hasWarn = result.details.some(d => d.status === 'warn');
    return result.score >= 90 && !hasFail && !hasWarn;
  }

  async getReviewData(context: CheckpointContext): Promise<Record<string, unknown>> {
    const dna = context.dna;
    return {
      dna: {
        behavioral: dna?.behavioral || {},
        values: dna?.values || {},
        cognitive: dna?.cognitive || {},
        voice: dna?.voice || {},
        knowledge: dna?.knowledge || {}
      },
      synthesisResults: this.getSynthesisSummaries(context),
      paradoxes: this.getParadoxes(context),
      confidence: this.calculateOverallConfidence(dna)
    };
  }

  validateApproval(approval: ApprovalInfo): boolean {
    return !!approval.approvedBy && !!approval.approvedAt && !!approval.comments;
  }

  private assessCompleteness(dna: PersonalityDNA): AssessmentResult {
    const requiredDimensions = ['behavioral', 'values', 'cognitive', 'voice', 'knowledge'];
    const presentDimensions = requiredDimensions.filter(dim => {
      const value = dna[dim as keyof PersonalityDNA];
      return value !== undefined && value !== null && Object.keys(value as object).length > 0;
    });

    const completeness = presentDimensions.length / requiredDimensions.length;

    return {
      status: completeness >= 1 ? 'pass' : (completeness >= 0.6 ? 'warn' : 'fail'),
      message: completeness >= 1
        ? 'All DNA dimensions are present'
        : 'Some DNA dimensions are missing',
      dimensionsPresent: presentDimensions.length,
      totalDimensions: requiredDimensions.length,
      score: completeness * 100
    };
  }

  private assessBehavioralProfile(dna: PersonalityDNA): AssessmentResult {
    const behavioral = dna.behavioral;
    if (!behavioral) {
      return { status: 'fail', message: 'Behavioral profile missing', score: 0, summary: 'N/A' };
    }

    const traits = behavioral.traits || [];
    const patterns = behavioral.patterns || [];
    const habits = behavioral.habits || [];

    const completeness = (traits.length + patterns.length + habits.length) / 30; // Expect ~10 of each
    const score = Math.min(100, completeness * 100);

    return {
      status: score >= 60 ? 'pass' : (score >= 40 ? 'warn' : 'fail'),
      message: score >= 60
        ? 'Behavioral profile is well developed'
        : 'Behavioral profile needs more depth',
      summary: `${traits.length} traits, ${patterns.length} patterns, ${habits.length} habits`,
      score
    };
  }

  private assessValuesProfile(dna: PersonalityDNA): AssessmentResult {
    const values = dna.values;
    if (!values) {
      return { status: 'fail', message: 'Values profile missing', score: 0, valuesCount: 0, beliefsCount: 0 };
    }

    const coreValues = values.core || [];
    const beliefs = values.beliefs || [];
    const priorities = values.priorities || [];

    const score = Math.min(100, (coreValues.length * 10) + (beliefs.length * 8) + (priorities.length * 5));

    return {
      status: coreValues.length >= 3 ? 'pass' : (coreValues.length >= 1 ? 'warn' : 'fail'),
      message: coreValues.length >= 3
        ? 'Values profile is comprehensive'
        : 'Values profile is limited',
      valuesCount: coreValues.length,
      beliefsCount: beliefs.length,
      score
    };
  }

  private assessCognitiveProfile(dna: PersonalityDNA): AssessmentResult {
    const cognitive = dna.cognitive;
    if (!cognitive) {
      return { status: 'fail', message: 'Cognitive profile missing', score: 0, summary: 'N/A' };
    }

    const mentalModels = cognitive.mentalModels || [];
    const reasoningStyle = cognitive.reasoningStyle;
    const thinkingPatterns = cognitive.thinkingPatterns || [];

    const hasReasoning = !!reasoningStyle;
    const modelScore = Math.min(50, mentalModels.length * 10);
    const reasoningScore = hasReasoning ? 30 : 0;
    const patternScore = Math.min(20, thinkingPatterns.length * 5);

    const score = modelScore + reasoningScore + patternScore;

    return {
      status: score >= 50 ? 'pass' : (score >= 30 ? 'warn' : 'fail'),
      message: hasReasoning && mentalModels.length >= 3
        ? 'Cognitive profile is well developed'
        : 'Cognitive profile needs more depth',
      summary: `${mentalModels.length} mental models, Reasoning: ${reasoningStyle || 'Unknown'}`,
      score
    };
  }

  private assessVoiceProfile(dna: PersonalityDNA): AssessmentResult {
    const voice = dna.voice;
    if (!voice) {
      return { status: 'fail', message: 'Voice profile missing', score: 0, characteristics: [] };
    }

    const characteristics = voice.characteristics || [];
    const tone = voice.tone;
    const vocabulary = voice.vocabulary || [];

    const charScore = Math.min(40, characteristics.length * 8);
    const toneScore = tone ? 30 : 0;
    const vocabScore = Math.min(30, vocabulary.length * 2);

    const score = charScore + toneScore + vocabScore;

    return {
      status: score >= 50 ? 'pass' : (score >= 30 ? 'warn' : 'fail'),
      message: characteristics.length >= 5
        ? 'Voice profile is distinctive'
        : 'Voice profile needs more characterization',
      characteristics,
      score
    };
  }

  private assessCoherence(dna: PersonalityDNA, context: CheckpointContext): AssessmentResult {
    // Get synthesis coherence result
    const syResults = this.getResultsByPrefix(context.taskResults, 'SY-');
    const coherenceResult = syResults.find(r => r.taskId === 'SY-008');
    const paradoxResult = syResults.find(r => r.taskId === 'SY-004');

    const coherenceScore = coherenceResult?.score || 0;
    const paradoxes = paradoxResult?.metadata?.paradoxes || [];

    return {
      status: coherenceScore >= 70 && paradoxes.length === 0
        ? 'pass'
        : (coherenceScore >= 50 && paradoxes.length <= 2 ? 'warn' : 'fail'),
      message: paradoxes.length === 0
        ? 'DNA is coherent with no paradoxes'
        : `${paradoxes.length} paradoxes identified in DNA`,
      coherenceScore,
      paradoxes,
      score: coherenceScore
    };
  }

  private assessFidelityProjection(context: CheckpointContext): AssessmentResult {
    const syResults = this.getResultsByPrefix(context.taskResults, 'SY-');
    const fidelityResult = syResults.find(r => r.taskId === 'SY-009');

    const projectedFidelity = fidelityResult?.score || fidelityResult?.metadata?.projectedFidelity || 0;

    return {
      status: projectedFidelity >= 70 ? 'pass' : (projectedFidelity >= 50 ? 'warn' : 'fail'),
      message: projectedFidelity >= 70
        ? 'Projected clone fidelity is good'
        : 'Projected clone fidelity needs improvement',
      projectedFidelity,
      score: projectedFidelity
    };
  }

  private calculateScore(assessments: AssessmentResult[]): number {
    return Math.round(
      assessments.reduce((sum, a) => sum + a.score, 0) / assessments.length
    );
  }

  private generateSummary(score: number, details: CheckpointDetail[]): string {
    const status = score >= 80 ? 'READY FOR APPROVAL' : (score >= 60 ? 'REVIEW RECOMMENDED' : 'NEEDS REVISION');
    const issues = details.filter(d => d.status === 'fail').length;
    const warnings = details.filter(d => d.status === 'warn').length;

    return `DNA Review: ${status} (Score: ${score}%). ${issues} issues, ${warnings} warnings.`;
  }

  private getResultsByPrefix(results: Map<TaskId, TaskResult>, prefix: string): TaskResult[] {
    const filtered: TaskResult[] = [];
    for (const [taskId, result] of results) {
      if (taskId.startsWith(prefix)) {
        filtered.push(result);
      }
    }
    return filtered;
  }

  private getSynthesisSummaries(context: CheckpointContext): unknown[] {
    return this.getResultsByPrefix(context.taskResults, 'SY-').map(r => ({
      taskId: r.taskId,
      score: r.score,
      summary: r.metadata?.summary
    }));
  }

  private getParadoxes(context: CheckpointContext): unknown[] {
    const syResults = this.getResultsByPrefix(context.taskResults, 'SY-');
    const paradoxResult = syResults.find(r => r.taskId === 'SY-004');
    return paradoxResult?.metadata?.paradoxes || [];
  }

  private calculateOverallConfidence(dna: PersonalityDNA | undefined): number {
    if (!dna) return 0;
    // Calculate average confidence across DNA components
    return 0.75; // Placeholder
  }
}

interface AssessmentResult {
  status: 'pass' | 'warn' | 'fail';
  message: string;
  score: number;
  [key: string]: unknown;
}
```

### File Structure

```
packages/validation/src/checkpoints/
├── cp-3-dna-approval.ts
└── __tests__/
    └── cp-3-dna-approval.test.ts
```

---

## Business Value

CP-3 eh o **checkpoint mais importante** do pipeline, pois o DNA eh a base de todo o clone. Aprovacao humana garante qualidade e precisao.

**Beneficios:**
- Validacao humana do DNA
- Identificacao de gaps
- Prevencao de DNA mal formado
- Documentacao de aprovacao

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Atraso na aprovacao | Medium | Medium | Timeout e escalacao |
| Rejeicao sem feedback claro | Low | High | Requisitar comentarios |
| Auto-aprovacao indevida | Low | Critical | Thresholds rigorosos |

---

## Scope

### In Scope
- CP-3 checkpoint implementation
- DNA completeness validation
- Coherence checking
- Unit tests

### Out of Scope
- Other checkpoints
- Checkpoint manager modifications
- CLI integration

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-017 (Synthesis Tasks) | Package | Pending |
| CL2-021 (Checkpoint Interface) | Package | Pending |
| CL2-022 (CP-1), CL2-023 (CP-2) | Package | Pending |

---

## Dev Notes

- This checkpoint should never auto-approve by default
- Require comments for approval
- Store approval history for audit

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/validation/src/checkpoints/cp-3-dna-approval.ts` | Create | Pending |
| `packages/validation/src/checkpoints/__tests__/cp-3-dna-approval.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Implements ICheckpoint correctly
- [ ] Evaluates DNA completeness
- [ ] Returns valid CheckpointResult
- [ ] Approval requires comments
- [ ] Unit tests pass (coverage > 80%)
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Evaluation returns correct status
- [ ] Score calculation is accurate
- [ ] Missing dimensions detected
- [ ] Paradoxes identified
- [ ] Edge cases handled

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
