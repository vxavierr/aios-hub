# Story CL2-032: Process Optimizer

**Story ID:** CL2-032
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Process Optimizer** - componente que analisa o pipeline de clone e sugere otimizações para melhorar eficiência, qualidade e velocidade.

### Problem Statement
O Clone Lab tem um pipeline complexo com 8 minds, 63 tasks e 6 checkpoints. O Process Optimizer analisa este pipeline para identificar oportunidades de otimização sem comprometer a qualidade.

---

## Acceptance Criteria

```gherkin
Given the pipeline has been running for some time
When optimization analysis is triggered
Then optimization opportunities are identified

Given tasks can run in parallel
When the optimizer analyzes dependencies
Then parallelization opportunities are suggested

Given a task consistently fails validation
When optimization runs
Then the task may be flagged for removal or modification

Given optimization suggestions exist
When they are reviewed
Then each suggestion includes impact and risk assessment
```

---

## Technical Requirements

### Process Optimizer

```typescript
// packages/meta/src/optimization/process-optimizer.ts

export interface OptimizationOpportunity {
  id: string;
  type: 'parallelization' | 'removal' | 'caching' | 'reordering' | 'batching';
  target: string;
  description: string;
  impact: {
    timeSaving: number;        // Estimated ms saved per operation
    qualityImpact: number;     // -100 to +100
    riskLevel: number;         // 0-100
  };
  autoApplicable: boolean;
  implementation: ImplementationStep[];
  dependencies: string[];      // Other optimizations needed first
}

export class ProcessOptimizer {
  private readonly metricsCollector: MetricsCollector;
  private readonly bottleneckDetector: BottleneckDetector;

  constructor(
    metricsCollector: MetricsCollector,
    bottleneckDetector: BottleneckDetector
  ) {
    this.metricsCollector = metricsCollector;
    this.bottleneckDetector = bottleneckDetector;
  }

  async analyze(): Promise<OptimizationAnalysis> {
    const opportunities: OptimizationOpportunity[] = [];

    // Analyze parallelization opportunities
    const parallelOps = await this.findParallelizationOpportunities();
    opportunities.push(...parallelOps);

    // Analyze removal opportunities (unused/ineffective)
    const removalOps = await this.findRemovalOpportunities();
    opportunities.push(...removalOps);

    // Analyze caching opportunities
    const cacheOps = await this.findCachingOpportunities();
    opportunities.push(...cacheOps);

    // Analyze reordering opportunities
    const reorderOps = await this.findReorderingOpportunities();
    opportunities.push(...reorderOps);

    // Analyze batching opportunities
    const batchOps = await this.findBatchingOpportunities();
    opportunities.push(...batchOps);

    return {
      timestamp: new Date(),
      opportunities: this.prioritize(opportunities),
      summary: this.generateSummary(opportunities),
      projectedImpact: this.calculateProjectedImpact(opportunities)
    };
  }

  private async findParallelizationOpportunities(): Promise<OptimizationOpportunity[]> {
    const opportunities: OptimizationOpportunity[] = [];

    // Check if validation tasks can run in parallel
    const tasksByCategory = await this.getTaskDependencies();
    for (const [category, tasks] of tasksByCategory) {
      const independentTasks = this.findIndependentTasks(tasks);
      if (independentTasks.length > 1) {
        opportunities.push({
          id: `parallel-tasks-${category}`,
          type: 'parallelization',
          target: `validation/tasks/${category}`,
          description: `${independentTasks.length} tasks in ${category} can run in parallel`,
          impact: {
            timeSaving: independentTasks.length * 200, // ~200ms per task
            qualityImpact: 0,
            riskLevel: 10
          },
          autoApplicable: true,
          implementation: [
            {
              step: 1,
              action: 'Update task executor to run tasks concurrently',
              files: ['packages/validation/src/executor.ts']
            },
            {
              step: 2,
              action: 'Add mutex for shared resources',
              files: ['packages/validation/src/context.ts']
            }
          ],
          dependencies: []
        });
      }
    }

    return opportunities;
  }

  private async findRemovalOpportunities(): Promise<OptimizationOpportunity[]> {
    const opportunities: OptimizationOpportunity[] = [];

    // Find tasks that haven't triggered in 30+ days
    const taskUsage = await this.getTaskUsageStats();
    for (const [taskId, stats] of taskUsage) {
      if (stats.daysSinceLastUse > 30 && stats.totalUses < 5) {
        opportunities.push({
          id: `remove-task-${taskId}`,
          type: 'removal',
          target: `validation/tasks/${taskId}`,
          description: `Task ${taskId} hasn't been used in ${stats.daysSinceLastUse} days`,
          impact: {
            timeSaving: 100, // Small saving in task registry
            qualityImpact: 0,
            riskLevel: 5
          },
          autoApplicable: true,
          implementation: [
            {
              step: 1,
              action: 'Remove task from registry',
              files: [`packages/validation/src/tasks/${taskId}.ts`]
            },
            {
              step: 2,
              action: 'Update registry index',
              files: ['packages/validation/src/registry.ts']
            }
          ],
          dependencies: []
        });
      }
    }

    // Find tasks with very low correlation to quality
    const taskCorrelations = await this.analyzeTaskQualityCorrelation();
    for (const [taskId, correlation] of taskCorrelations) {
      if (Math.abs(correlation) < 0.1) {
        opportunities.push({
          id: `review-task-${taskId}`,
          type: 'removal',
          target: `validation/tasks/${taskId}`,
          description: `Task ${taskId} has low correlation with quality (${correlation.toFixed(2)})`,
          impact: {
            timeSaving: 150,
            qualityImpact: -5, // Potential slight negative impact
            riskLevel: 30
          },
          autoApplicable: false,
          implementation: [
            {
              step: 1,
              action: 'Review task purpose and effectiveness',
              files: [`packages/validation/src/tasks/${taskId}.ts`]
            }
          ],
          dependencies: []
        });
      }
    }

    return opportunities;
  }

  private async findCachingOpportunities(): Promise<OptimizationOpportunity[]> {
    const opportunities: OptimizationOpportunity[] = [];

    // Find repeated similar analyses
    const repetitionPatterns = await this.findRepetitionPatterns();
    for (const pattern of repetitionPatterns) {
      if (pattern.repetitionRate > 0.3) {
        opportunities.push({
          id: `cache-${pattern.component}`,
          type: 'caching',
          target: pattern.component,
          description: `${pattern.component} has ${(pattern.repetitionRate * 100).toFixed(0)}% repeated inputs`,
          impact: {
            timeSaving: pattern.avgTime * pattern.repetitionRate,
            qualityImpact: 0,
            riskLevel: 15
          },
          autoApplicable: true,
          implementation: [
            {
              step: 1,
              action: 'Add cache layer with TTL',
              files: [`${pattern.component}/cache.ts`]
            },
            {
              step: 2,
              action: 'Implement cache key generation',
              files: [`${pattern.component}/analyzer.ts`]
            }
          ],
          dependencies: []
        });
      }
    }

    return opportunities;
  }

  private async findReorderingOpportunities(): Promise<OptimizationOpportunity[]> {
    const opportunities: OptimizationOpportunity[] = [];

    // Find early-exit opportunities (move failing checks earlier)
    const failurePatterns = await this.analyzeFailurePatterns();
    for (const pattern of failurePatterns) {
      if (pattern.earlyExitBenefit > 1000) {
        opportunities.push({
          id: `reorder-${pattern.checkpoint}`,
          type: 'reordering',
          target: `checkpoints/${pattern.checkpoint}`,
          description: `Move ${pattern.checkpoint} earlier to fail fast on ${pattern.condition}`,
          impact: {
            timeSaving: pattern.earlyExitBenefit,
            qualityImpact: 0,
            riskLevel: 20
          },
          autoApplicable: false,
          implementation: [
            {
              step: 1,
              action: 'Analyze checkpoint dependencies',
              files: ['packages/checkpoints/src/dependencies.ts']
            },
            {
              step: 2,
              action: 'Reorder checkpoint in pipeline',
              files: ['packages/pipeline/src/phases.ts']
            }
          ],
          dependencies: []
        });
      }
    }

    return opportunities;
  }
}
```

### Implementation Plan Generator

```typescript
// packages/meta/src/optimization/implementation-plan.ts

export class ImplementationPlanGenerator {
  generate(opportunities: OptimizationOpportunity[]): ImplementationPlan {
    // Build dependency graph
    const graph = this.buildDependencyGraph(opportunities);

    // Topological sort for execution order
    const sorted = this.topologicalSort(graph);

    // Group into phases
    const phases = this.groupIntoPhases(sorted);

    return {
      phases,
      totalEstimatedSavings: this.calculateTotalSavings(sorted),
      riskAssessment: this.assessOverallRisk(sorted),
      rollbackPlan: this.generateRollbackPlan(sorted)
    };
  }

  private groupIntoPhases(
    opportunities: OptimizationOpportunity[]
  ): ImplementationPhase[] {
    return [
      {
        name: 'Low Risk / High Impact',
        opportunities: opportunities.filter(
          o => o.impact.riskLevel < 20 && o.impact.timeSaving > 500
        ),
        autoApply: true
      },
      {
        name: 'Medium Risk / High Impact',
        opportunities: opportunities.filter(
          o => o.impact.riskLevel >= 20 && o.impact.riskLevel < 50 && o.impact.timeSaving > 500
        ),
        autoApply: false
      },
      {
        name: 'Low Risk / Medium Impact',
        opportunities: opportunities.filter(
          o => o.impact.riskLevel < 20 && o.impact.timeSaving <= 500
        ),
        autoApply: true
      },
      {
        name: 'High Risk (Manual Review)',
        opportunities: opportunities.filter(o => o.impact.riskLevel >= 50),
        autoApply: false
      }
    ];
  }
}
```

---

## Business Value

O Process Optimizer permite que o Clone Lab **melhore continuamente sua eficiência** sem intervenção manual constante.

**Benefícios:**
- Reduz tempo de operações de clone
- Identifica código morto ou ineficiente
- Sugere melhorias com análise de risco
- Base para auto-otimização futura

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Optimization breaks functionality | Medium | High | Thorough testing + rollback plan |
| False positive removal | Medium | Medium | Require human approval for removals |
| Cached data becomes stale | Low | Medium | TTL + invalidation strategy |

---

## Scope

### In Scope
- ProcessOptimizer class
- 5 optimization types (parallelization, removal, caching, reordering, batching)
- Implementation plan generator
- Risk assessment
- Dependency analysis

### Out of Scope
- Auto-application of optimizations
- ML-based optimization suggestions
- Real-time optimization

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-029 (Metrics Collector) | Package | Pending |
| CL2-031 (Bottleneck Detector) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Optimization Priority Formula

```typescript
function calculatePriority(o: OptimizationOpportunity): number {
  return (
    o.impact.timeSaving * 0.4 +
    (100 - o.impact.riskLevel) * 0.3 +
    o.impact.qualityImpact * 0.2 +
    (o.autoApplicable ? 10 : 0) // Bonus for auto-applicable
  );
}
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/optimization/process-optimizer.ts` | Create | Pending |
| `packages/meta/src/optimization/implementation-plan.ts` | Create | Pending |
| `packages/meta/src/optimization/types.ts` | Create | Pending |
| `packages/meta/src/optimization/index.ts` | Create | Pending |
| `packages/meta/src/optimization/__tests__/process-optimizer.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] All 5 optimization types detected
- [ ] Impact and risk calculated correctly
- [ ] Implementation steps generated
- [ ] Dependency graph handled correctly
- [ ] Prioritization works
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] All 5 optimization types detected
- [ ] Impact and risk calculated correctly
- [ ] Implementation steps generated
- [ ] Dependency graph handled correctly
- [ ] Prioritization works
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
