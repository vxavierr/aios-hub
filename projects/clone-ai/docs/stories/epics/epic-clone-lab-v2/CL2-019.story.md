# Story CL2-019: Quality Tasks QA-001 to QA-006

**Story ID:** CL2-019
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 2 - Validation
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar as 6 Validation Tasks de Qualidade (QA-001 a QA-006), responsaveis por validar a qualidade geral do clone, incluindo fidelidade, consistencia e performance.

### Problem Statement
A qualidade final do clone precisa ser validada de forma abrangente. Estas 6 tasks fornecem uma avaliacao holistica da qualidade e prontidao do clone.

---

## Acceptance Criteria

```gherkin
Given a complete clone implementation
When quality tasks are executed
Then all 6 tasks return valid TaskResults

Given clone responses from test scenarios
When QA-001 (Fidelity Assessment) runs
Then it calculates an accurate fidelity score

Given multiple clone responses
When QA-003 (Consistency Check) runs
Then it validates response consistency

Given clone performance metrics
When QA-005 (Performance Validation) runs
Then it validates performance meets requirements
```

---

## Technical Requirements

### Task Definitions

| Task ID | Name | Description |
|---------|------|-------------|
| QA-001 | Fidelity Assessment | Avalia fidelidade geral do clone |
| QA-002 | Voice Match | Valida correspondencia de voz |
| QA-003 | Consistency Check | Verifica consistencia de respostas |
| QA-004 | Edge Case Handling | Valida tratamento de casos extremos |
| QA-005 | Performance Validation | Valida performance do clone |
| QA-006 | Quality Gate | Portao final de qualidade |

### Implementation Example

```typescript
// packages/validation/src/tasks/quality/qa-001-fidelity-assessment.ts

import { IValidationTask, TaskContext, TaskResult, TaskDefinition } from '../task.interface';

export class QA001FidelityAssessment implements IValidationTask {
  readonly definition: TaskDefinition = {
    id: 'QA-001',
    category: 'quality',
    name: 'Fidelity Assessment',
    description: 'Assesses overall clone fidelity against source personality',
    requiredInputs: ['extractedData', 'dna', 'testResponses'],
    outputs: ['fidelityScore', 'dimensionScores', 'recommendations'],
    timeout: 90000,
    retryable: true,
    priority: 'critical'
  };

  async execute(context: TaskContext): Promise<TaskResult> {
    const startTime = Date.now();
    const findings: TaskFinding[] = [];

    const testResponses = context.options.testResponses as TestResponse[];
    const dna = context.options.dna as PersonalityDNA;

    if (!testResponses || testResponses.length === 0) {
      return {
        taskId: this.definition.id,
        status: 'failed',
        score: 0,
        confidence: 0,
        findings: [{ type: 'issue', description: 'No test responses provided', severity: 'critical' }],
        recommendations: ['Generate test responses before fidelity assessment'],
        executionTime: Date.now() - startTime,
        metadata: {}
      };
    }

    const fidelityAnalysis = await this.analyzeFidelity(testResponses, dna, context);

    // Check for low fidelity dimensions
    for (const [dimension, score] of Object.entries(fidelityAnalysis.dimensionScores)) {
      if (score < 60) {
        findings.push({
          type: 'warning',
          description: `Low fidelity in ${dimension}: ${score}%`,
          severity: score < 40 ? 'high' : 'medium'
        });
      }
    }

    // Check for significant drift
    if (fidelityAnalysis.driftScore > 0.3) {
      findings.push({
        type: 'issue',
        description: 'Significant personality drift detected',
        severity: 'high',
        evidence: `Drift score: ${fidelityAnalysis.driftScore.toFixed(2)}`
      });
    }

    const score = this.calculateOverallScore(fidelityAnalysis);

    return {
      taskId: this.definition.id,
      status: score >= 70 ? 'passed' : 'failed',
      score,
      confidence: fidelityAnalysis.confidence,
      findings,
      recommendations: this.generateRecommendations(fidelityAnalysis),
      executionTime: Date.now() - startTime,
      metadata: {
        dimensionScores: fidelityAnalysis.dimensionScores,
        overallFidelity: fidelityAnalysis.overallFidelity,
        driftScore: fidelityAnalysis.driftScore,
        responsesAnalyzed: testResponses.length
      }
    };
  }

  private async analyzeFidelity(
    responses: TestResponse[],
    dna: PersonalityDNA,
    context: TaskContext
  ): Promise<FidelityAnalysis> {
    const dimensionScores: Record<string, number> = {
      behavioral: 0,
      values: 0,
      cognitive: 0,
      voice: 0,
      knowledge: 0
    };

    // Analyze each response against DNA
    for (const response of responses) {
      const responseAnalysis = this.analyzeResponse(response, dna);

      dimensionScores.behavioral += responseAnalysis.behavioralMatch;
      dimensionScores.values += responseAnalysis.valuesMatch;
      dimensionScores.cognitive += responseAnalysis.cognitiveMatch;
      dimensionScores.voice += responseAnalysis.voiceMatch;
      dimensionScores.knowledge += responseAnalysis.knowledgeMatch;
    }

    // Average scores
    const numResponses = responses.length;
    for (const key of Object.keys(dimensionScores)) {
      dimensionScores[key] = Math.round(dimensionScores[key] / numResponses);
    }

    // Calculate overall fidelity
    const overallFidelity = Math.round(
      Object.values(dimensionScores).reduce((a, b) => a + b, 0) / Object.keys(dimensionScores).length
    );

    // Calculate drift (deviation from expected)
    const driftScore = this.calculateDriftScore(responses, dna);

    // Calculate confidence based on sample size
    const confidence = Math.min(1, numResponses / 20);

    return {
      dimensionScores,
      overallFidelity,
      driftScore,
      confidence
    };
  }

  private analyzeResponse(response: TestResponse, dna: PersonalityDNA): ResponseAnalysis {
    // Compare response characteristics with DNA expectations
    const analysis: ResponseAnalysis = {
      behavioralMatch: 100,
      valuesMatch: 100,
      cognitiveMatch: 100,
      voiceMatch: 100,
      knowledgeMatch: 100
    };

    // Check behavioral alignment
    const expectedBehaviors = dna.behavioral?.patterns || [];
    const matchedBehaviors = expectedBehaviors.filter(b =>
      this.behaviorPresentInResponse(b, response.content)
    ).length;
    analysis.behavioralMatch = expectedBehaviors.length > 0
      ? Math.round((matchedBehaviors / expectedBehaviors.length) * 100)
      : 100;

    // Check values alignment
    const expectedValues = dna.values?.core || [];
    analysis.valuesMatch = this.assessValuesAlignment(response.content, expectedValues);

    // Check cognitive style
    analysis.cognitiveMatch = this.assessCognitiveMatch(response.content, dna.cognitive?.style);

    // Check voice match
    analysis.voiceMatch = this.assessVoiceMatch(response.content, dna.voice);

    // Check knowledge accuracy
    analysis.knowledgeMatch = this.assessKnowledgeAccuracy(response, dna.knowledge);

    return analysis;
  }

  private calculateOverallScore(analysis: FidelityAnalysis): number {
    // Weight dimensions
    const weights = {
      behavioral: 0.25,
      values: 0.20,
      cognitive: 0.20,
      voice: 0.20,
      knowledge: 0.15
    };

    let weightedScore = 0;
    for (const [dimension, score] of Object.entries(analysis.dimensionScores)) {
      weightedScore += score * (weights[dimension as keyof typeof weights] || 0.1);
    }

    // Penalize for drift
    weightedScore *= (1 - analysis.driftScore * 0.5);

    return Math.round(Math.max(0, Math.min(100, weightedScore)));
  }

  private calculateDriftScore(responses: TestResponse[], dna: PersonalityDNA): number {
    // Calculate how much responses deviate from expected patterns
    // Returns 0-1 where 0 is no drift, 1 is complete drift
    let totalDeviation = 0;

    for (const response of responses) {
      // Check for unexpected patterns
      const deviation = this.measureDeviation(response, dna);
      totalDeviation += deviation;
    }

    return Math.min(1, totalDeviation / responses.length);
  }

  async validateInputs(context: TaskContext): Promise<boolean> {
    return context.options.testResponses !== undefined && context.options.dna !== undefined;
  }

  canExecute(context: TaskContext): boolean {
    return context.previousResults.has('IM-007'); // Integration Test
  }

  getDependencies(): TaskId[] {
    return ['IM-007', 'SY-009']; // Integration Test and Fidelity Projection
  }
}
```

### File Structure

```
packages/validation/src/tasks/quality/
├── qa-001-fidelity-assessment.ts
├── qa-002-voice-match.ts
├── qa-003-consistency-check.ts
├── qa-004-edge-case-handling.ts
├── qa-005-performance-validation.ts
├── qa-006-quality-gate.ts
├── index.ts
└── __tests__/
    └── quality-tasks.test.ts
```

---

## Business Value

As Quality Tasks sao o **portao final** antes do clone ser considerado pronto. Elas garantem que o clone atende aos padroes de qualidade exigidos.

**Beneficios:**
- Avaliacao abrangente de fidelidade
- Deteccao de inconsistencias
- Validacao de performance
- Garantia de qualidade antes do deploy

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Metricas de fidelidade imprecisas | Medium | High | Multi-dimensional scoring |
| Testes insuficientes | Medium | High | Requisitos minimos de amostra |
| Falsos positivos | Low | Medium | Thresholds calibrados |

---

## Scope

### In Scope
- All 6 quality task implementations
- Unit tests for each task
- Fidelity scoring logic
- Finding and recommendation generation

### Out of Scope
- Other task categories
- Task Registry & Executor
- CLI integration

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-012 (Task Interface) | Package | Pending |
| CL2-018 (Implementation Tasks) | Package | Pending |
| @clone-lab/core (DNA) | Package | Available |

---

## Dev Notes

- Use multi-dimensional fidelity scoring
- Consider LLM-based similarity assessment
- Add benchmark comparisons
- Implement statistical significance tests

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/validation/src/tasks/quality/qa-001-fidelity-assessment.ts` | Create | Pending |
| `packages/validation/src/tasks/quality/qa-002-voice-match.ts` | Create | Pending |
| `packages/validation/src/tasks/quality/qa-003-consistency-check.ts` | Create | Pending |
| `packages/validation/src/tasks/quality/qa-004-edge-case-handling.ts` | Create | Pending |
| `packages/validation/src/tasks/quality/qa-005-performance-validation.ts` | Create | Pending |
| `packages/validation/src/tasks/quality/qa-006-quality-gate.ts` | Create | Pending |
| `packages/validation/src/tasks/quality/index.ts` | Create | Pending |
| `packages/validation/src/tasks/quality/__tests__/quality-tasks.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] All 6 tasks implement IValidationTask correctly
- [ ] Each task returns valid TaskResult
- [ ] Fidelity is accurately assessed
- [ ] Findings are descriptive and actionable
- [ ] Unit tests pass (coverage > 80%)
- [ ] Handles edge cases gracefully
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] All 6 tasks execute without errors
- [ ] Task results are consistent
- [ ] Fidelity scores are reasonable
- [ ] Quality gate properly evaluates
- [ ] Edge cases handled

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
