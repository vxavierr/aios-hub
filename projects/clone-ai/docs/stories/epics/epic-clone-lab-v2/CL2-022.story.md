# Story CL2-022: CP-1 Source Validation Checkpoint

**Story ID:** CL2-022
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 2 - Validation
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar o **Checkpoint 1 (CP-1)** - Source Validation, que valida a qualidade e adequacao das fontes extraidas antes de prosseguir com a analise.

### Problem Statement
Antes de investir tempo na analise profunda, eh importante validar se as fontes extraidas sao adequadas e de qualidade suficiente para criar um clone fiel.

---

## Acceptance Criteria

```gherkin
Given extracted sources from multiple content types
When CP-1 evaluates the sources
Then it returns a quality assessment

Given sources with insufficient quality
When CP-1 evaluates
Then it recommends additional sources or rejects

Given sources meeting auto-approve conditions
When CP-1 evaluates
Then it can auto-approve if configured

Given CP-1 evaluation complete
When human reviews the checkpoint
Then clear summary and recommendations are available
```

---

## Technical Requirements

### Checkpoint Implementation

```typescript
// packages/validation/src/checkpoints/cp-1-source-validation.ts

import { ICheckpoint, CheckpointDefinition, CheckpointContext, CheckpointResult, CheckpointDetail } from './checkpoint.interface';

export class CP1SourceValidation implements ICheckpoint {
  readonly definition: CheckpointDefinition = {
    id: 'CP-1',
    name: 'Source Validation',
    description: 'Validates the quality and adequacy of extracted sources',
    triggerPhase: 'extraction',
    requiredApprovals: 1,
    autoApproveConditions: [
      'sourceQualityScore >= 80',
      'sourceDiversity >= 3 types',
      'totalContentLength >= 50000 chars',
      'noCriticalExtractionErrors'
    ],
    timeout: 60 * 60 * 1000  // 1 hour
  };

  async evaluate(context: CheckpointContext): Promise<CheckpointResult> {
    const details: CheckpointDetail[] = [];
    const recommendations: string[] = [];

    // Get extraction task results
    const extractionResults = this.getExtractionResults(context.taskResults);

    // 1. Source Quality Assessment
    const qualityAssessment = this.assessSourceQuality(extractionResults);
    details.push({
      category: 'Source Quality',
      status: qualityAssessment.status,
      message: qualityAssessment.message,
      evidence: `Average quality score: ${qualityAssessment.averageScore}%`
    });

    // 2. Content Coverage
    const coverageAssessment = this.assessContentCoverage(extractionResults);
    details.push({
      category: 'Content Coverage',
      status: coverageAssessment.status,
      message: coverageAssessment.message,
      evidence: `Coverage score: ${coverageAssessment.coverage}%`
    });

    // 3. Source Diversity
    const diversityAssessment = this.assessSourceDiversity(extractionResults);
    details.push({
      category: 'Source Diversity',
      status: diversityAssessment.status,
      message: diversityAssessment.message,
      evidence: `Source types: ${diversityAssessment.types.join(', ')}`
    });

    // 4. Content Volume
    const volumeAssessment = this.assessContentVolume(extractionResults);
    details.push({
      category: 'Content Volume',
      status: volumeAssessment.status,
      message: volumeAssessment.message,
      evidence: `Total content: ${volumeAssessment.totalChars} characters across ${volumeAssessment.sourceCount} sources`
    });

    // 5. Temporal Distribution
    const temporalAssessment = this.assessTemporalDistribution(extractionResults);
    details.push({
      category: 'Temporal Distribution',
      status: temporalAssessment.status,
      message: temporalAssessment.message,
      evidence: temporalAssessment.dateRange
    });

    // Calculate overall score
    const score = this.calculateScore([
      qualityAssessment,
      coverageAssessment,
      diversityAssessment,
      volumeAssessment,
      temporalAssessment
    ]);

    // Generate recommendations
    if (qualityAssessment.status !== 'pass') {
      recommendations.push('Consider adding higher quality sources (published content, verified accounts)');
    }
    if (diversityAssessment.status !== 'pass') {
      recommendations.push(`Add more source types. Current: ${diversityAssessment.types.join(', ')}. Consider: videos, podcasts, articles`);
    }
    if (volumeAssessment.status !== 'pass') {
      recommendations.push('Increase content volume for better personality capture');
    }

    // Determine status
    const hasFail = details.some(d => d.status === 'fail');
    const hasWarn = details.some(d => d.status === 'warn');

    return {
      checkpointId: this.definition.id,
      status: hasFail ? 'waiting_approval' : (hasWarn ? 'waiting_approval' : 'pending'),
      score,
      summary: this.generateSummary(score, details),
      details,
      recommendations,
      timestamp: new Date()
    };
  }

  canAutoApprove(result: CheckpointResult): boolean {
    // Auto-approve if score >= 80 and no failures
    const hasFail = result.details.some(d => d.status === 'fail');
    return result.score >= 80 && !hasFail;
  }

  async getReviewData(context: CheckpointContext): Promise<Record<string, unknown>> {
    const extractionResults = this.getExtractionResults(context.taskResults);

    return {
      sources: extractionResults.map(r => ({
        taskId: r.taskId,
        score: r.score,
        metadata: r.metadata
      })),
      summary: {
        totalSources: extractionResults.length,
        averageScore: this.calculateAverageScore(extractionResults),
        types: this.getSourceTypes(extractionResults)
      }
    };
  }

  validateApproval(approval: ApprovalInfo): boolean {
    return !!approval.approvedBy && !!approval.approvedAt;
  }

  private getExtractionResults(results: Map<TaskId, TaskResult>): TaskResult[] {
    const extractionTasks: TaskResult[] = [];
    for (const [taskId, result] of results) {
      if (taskId.startsWith('EX-')) {
        extractionTasks.push(result);
      }
    }
    return extractionTasks;
  }

  private assessSourceQuality(results: TaskResult[]): AssessmentResult {
    const scores = results.filter(r => r.taskId === 'EX-002').map(r => r.score);
    const averageScore = scores.length > 0 ? scores.reduce((a, b) => a + b) / scores.length : 0;

    return {
      status: averageScore >= 70 ? 'pass' : (averageScore >= 50 ? 'warn' : 'fail'),
      message: averageScore >= 70
        ? 'Source quality is good'
        : 'Source quality needs improvement',
      averageScore,
      score: averageScore
    };
  }

  private assessContentCoverage(results: TaskResult[]): AssessmentResult {
    const coverageResult = results.find(r => r.taskId === 'EX-003');
    const coverage = coverageResult?.metadata?.coverageScore || 0;

    return {
      status: coverage >= 60 ? 'pass' : (coverage >= 40 ? 'warn' : 'fail'),
      message: coverage >= 60
        ? 'Content covers key personality aspects'
        : 'Content coverage is limited',
      coverage,
      score: coverage
    };
  }

  private assessSourceDiversity(results: TaskResult[]): AssessmentResult {
    const diversityResult = results.find(r => r.taskId === 'EX-010');
    const types: string[] = diversityResult?.metadata?.sourceTypes || [];

    const diversityScore = types.length * 20; // 5 types = 100

    return {
      status: types.length >= 3 ? 'pass' : (types.length >= 2 ? 'warn' : 'fail'),
      message: types.length >= 3
        ? 'Good source diversity'
        : 'Limited source diversity',
      types,
      score: Math.min(100, diversityScore)
    };
  }

  private assessContentVolume(results: TaskResult[]): AssessmentResult {
    const totalChars = results.reduce((sum, r) => {
      return sum + (r.metadata?.totalChars || 0);
    }, 0);
    const sourceCount = results.reduce((sum, r) => {
      return sum + (r.metadata?.sourceCount || 0);
    }, 0);

    const volumeScore = Math.min(100, totalChars / 500);

    return {
      status: totalChars >= 50000 ? 'pass' : (totalChars >= 20000 ? 'warn' : 'fail'),
      message: totalChars >= 50000
        ? 'Sufficient content volume'
        : 'Content volume may be insufficient',
      totalChars,
      sourceCount,
      score: volumeScore
    };
  }

  private assessTemporalDistribution(results: TaskResult[]): AssessmentResult {
    const temporalResult = results.find(r => r.taskId === 'EX-004');
    const dateRange = temporalResult?.metadata?.dateRange || 'Unknown';

    const spread = temporalResult?.metadata?.spread || 0;
    const spreadScore = Math.min(100, spread * 10); // 10 months = 100

    return {
      status: spread >= 6 ? 'pass' : (spread >= 3 ? 'warn' : 'fail'),
      message: spread >= 6
        ? 'Good temporal distribution'
        : 'Limited temporal distribution',
      dateRange,
      score: spreadScore
    };
  }

  private calculateScore(assessments: AssessmentResult[]): number {
    return Math.round(
      assessments.reduce((sum, a) => sum + a.score, 0) / assessments.length
    );
  }

  private generateSummary(score: number, details: CheckpointDetail[]): string {
    const status = score >= 70 ? 'GOOD' : (score >= 50 ? 'ADEQUATE' : 'NEEDS IMPROVEMENT');
    const issues = details.filter(d => d.status === 'fail').length;
    const warnings = details.filter(d => d.status === 'warn').length;

    return `Source Validation: ${status} (Score: ${score}%). ${issues} issues, ${warnings} warnings.`;
  }

  private calculateAverageScore(results: TaskResult[]): number {
    if (results.length === 0) return 0;
    return Math.round(results.reduce((sum, r) => sum + r.score, 0) / results.length);
  }

  private getSourceTypes(results: TaskResult[]): string[] {
    const types = new Set<string>();
    for (const result of results) {
      const resultTypes = result.metadata?.sourceTypes as string[] || [];
      resultTypes.forEach(t => types.add(t));
    }
    return Array.from(types);
  }
}

interface AssessmentResult {
  status: 'pass' | 'warn' | 'fail';
  message: string;
  score: number;
  [key: string]: unknown;
}
```

### File Structure

```
packages/validation/src/checkpoints/
├── cp-1-source-validation.ts
└── __tests__/
    └── cp-1-source-validation.test.ts
```

---

## Business Value

CP-1 eh o **primeiro checkpoint humano** do pipeline, garantindo que apenas fontes adequadas sigam para analise, economizando tempo e recursos.

**Beneficios:**
- Valida qualidade das fontes cedo
- Evita analise de dados inadequados
- Fornece feedback claro para coleta
- Auto-aprovacao para casos claros

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Rejeicao de boas fontes | Low | Medium | Thresholds calibrados |
| Auto-aprovacao indevida | Low | High | Condicoes rigorosas |
| Atraso por aprovacao | Medium | Low | Auto-approve habilitado |

---

## Scope

### In Scope
- CP-1 checkpoint implementation
- Source quality assessment
- Auto-approve conditions
- Unit tests

### Out of Scope
- Other checkpoints
- Checkpoint manager modifications
- CLI integration

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-013 (Extraction Tasks) | Package | Pending |
| CL2-021 (Checkpoint Interface) | Package | Pending |

---

## Dev Notes

- Calibrate auto-approve thresholds based on testing
- Add support for custom quality criteria
- Consider personality type in assessment

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/validation/src/checkpoints/cp-1-source-validation.ts` | Create | Pending |
| `packages/validation/src/checkpoints/__tests__/cp-1-source-validation.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Implements ICheckpoint correctly
- [ ] Evaluates all extraction tasks
- [ ] Returns valid CheckpointResult
- [ ] Auto-approve logic works
- [ ] Unit tests pass (coverage > 80%)
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Evaluation returns correct status
- [ ] Score calculation is accurate
- [ ] Auto-approve conditions work
- [ ] Recommendations are helpful
- [ ] Edge cases handled

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
