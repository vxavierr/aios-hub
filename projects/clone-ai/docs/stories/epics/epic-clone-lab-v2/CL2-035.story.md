# Story CL2-035: Constitution Validator & Enforcer

**Story ID:** CL2-035
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Constitution Validator & Enforcer** - componente que valida mudanças propostas contra as regras da constitution e aplica as decisões apropriadamente.

### Problem Statement
O Clone Lab tem regras de constitution definidas, mas precisa de um componente que as aplique ativamente. O Validator & Enforcer avalia cada mudança proposta e determina se pode ser aplicada automaticamente, requer aprovação, ou deve ser rejeitada.

---

## Acceptance Criteria

```gherkin
Given a change is proposed
When constitution validation runs
Then all applicable rules are evaluated

Given a rule rejects the change
When the enforcer processes the result
Then the change is blocked and logged

Given all rules allow the change
When the enforcer processes the result
Then the change is marked as auto-applicable

Given some rules warn but none reject
When the enforcer processes the result
Then warnings are logged and change may proceed
```

---

## Technical Requirements

### Constitution Validator

```typescript
// packages/meta/src/constitution/validator.ts

export interface ValidationResult {
  candidate: ImprovementCandidate;
  verdict: 'allow' | 'warn' | 'reject';
  ruleResults: RuleEvaluationResult[];
  blockingRules: string[];
  warningRules: string[];
  requiresApproval: boolean;
  autoApplicable: boolean;
  approvalReason?: string;
}

export class ConstitutionValidator {
  private readonly registry: ConstitutionRegistry;
  private readonly auditLog: AuditLog;

  constructor(registry: ConstitutionRegistry, auditLog: AuditLog) {
    this.registry = registry;
    this.auditLog = auditLog;
  }

  validate(candidate: ImprovementCandidate): ValidationResult {
    const rules = this.registry.getAllRules();
    const ruleResults: RuleEvaluationResult[] = [];

    // Evaluate each rule
    for (const rule of rules) {
      const result = this.evaluateRule(rule, candidate);
      ruleResults.push(result);
    }

    // Determine final verdict
    const verdict = this.calculateVerdict(ruleResults);

    // Build result
    const result: ValidationResult = {
      candidate,
      verdict: verdict.verdict,
      ruleResults,
      blockingRules: verdict.blocking,
      warningRules: verdict.warnings,
      requiresApproval: verdict.requiresApproval,
      autoApplicable: verdict.autoApplicable,
      approvalReason: verdict.reason
    };

    // Audit log the validation
    this.auditLog.log({
      type: 'constitution_validation',
      candidateId: candidate.id,
      verdict: result.verdict,
      rulesEvaluated: ruleResults.length,
      timestamp: new Date()
    });

    return result;
  }

  private evaluateRule(
    rule: ConstitutionRule,
    candidate: ImprovementCandidate
  ): RuleEvaluationResult {
    try {
      const verdict = rule.check(candidate);

      // Check for exceptions
      const exception = this.checkExceptions(rule, candidate);

      return {
        ruleId: rule.id,
        verdict: exception ? 'allow' : verdict,
        message: exception ? exception.description : rule.message,
        exception
      };
    } catch (error) {
      // On error, be conservative
      return {
        ruleId: rule.id,
        verdict: 'reject',
        message: `Rule evaluation error: ${error}`
      };
    }
  }

  private checkExceptions(
    rule: ConstitutionRule,
    candidate: ImprovementCandidate
  ): RuleException | undefined {
    if (!rule.exceptions) return undefined;

    for (const exception of rule.exceptions) {
      if (this.matchesException(exception, candidate)) {
        return exception;
      }
    }

    return undefined;
  }

  private calculateVerdict(
    results: RuleEvaluationResult[]
  ): {
    verdict: 'allow' | 'warn' | 'reject';
    blocking: string[];
    warnings: string[];
    requiresApproval: boolean;
    autoApplicable: boolean;
    reason?: string;
  } {
    const blocking = results
      .filter(r => r.verdict === 'reject')
      .map(r => r.ruleId);

    const warnings = results
      .filter(r => r.verdict === 'warn')
      .map(r => r.ruleId);

    if (blocking.length > 0) {
      return {
        verdict: 'reject',
        blocking,
        warnings,
        requiresApproval: true,
        autoApplicable: false,
        reason: `Blocked by rules: ${blocking.join(', ')}`
      };
    }

    if (warnings.length > 0) {
      return {
        verdict: 'warn',
        blocking,
        warnings,
        requiresApproval: true,
        autoApplicable: false,
        reason: `Warnings from rules: ${warnings.join(', ')}`
      };
    }

    return {
      verdict: 'allow',
      blocking,
      warnings,
      requiresApproval: false,
      autoApplicable: true
    };
  }
}
```

### Constitution Enforcer

```typescript
// packages/meta/src/constitution/enforcer.ts

export class ConstitutionEnforcer {
  private readonly validator: ConstitutionValidator;
  private readonly approvalQueue: ApprovalQueue;
  private readonly config: EnforcementConfig;

  constructor(
    validator: ConstitutionValidator,
    approvalQueue: ApprovalQueue,
    config: EnforcementConfig
  ) {
    this.validator = validator;
    this.approvalQueue = approvalQueue;
    this.config = config;
  }

  async evaluate(
    candidates: ImprovementCandidate[]
  ): Promise<FilteredCandidates> {
    const autoApply: ImprovementCandidate[] = [];
    const needsApproval: ImprovementCandidate[] = [];
    const rejected: ImprovementCandidate[] = [];

    // Check rate limits first
    const todayCount = await this.getTodayAutoApplyCount();
    const remainingSlots = Math.max(0, this.config.maxAutoPerDay - todayCount);

    for (const candidate of candidates) {
      const result = this.validator.validate(candidate);

      if (result.verdict === 'reject') {
        rejected.push(candidate);
        await this.logRejection(result);
      } else if (result.autoApplicable && autoApply.length < remainingSlots) {
        autoApply.push(candidate);
      } else {
        needsApproval.push(candidate);
        await this.queueForApproval(candidate, result);
      }
    }

    return { autoApply, needsApproval, rejected };
  }

  private async queueForApproval(
    candidate: ImprovementCandidate,
    result: ValidationResult
  ): Promise<void> {
    await this.approvalQueue.add({
      candidate,
      validation: result,
      queuedAt: new Date(),
      reason: result.approvalReason || 'Requires human approval',
      priority: this.calculatePriority(candidate, result)
    });
  }

  private async logRejection(result: ValidationResult): Promise<void> {
    await this.auditLog.log({
      type: 'constitution_rejection',
      candidateId: result.candidate.id,
      blockingRules: result.blockingRules,
      timestamp: new Date()
    });
  }

  // Verify a change can be applied
  async verifyBeforeApply(candidate: ImprovementCandidate): Promise<boolean> {
    const result = this.validator.validate(candidate);

    if (result.verdict === 'reject') {
      throw new ConstitutionViolationError(
        `Change blocked by constitution: ${result.approvalReason}`
      );
    }

    return result.autoApplicable || result.requiresApproval;
  }

  // Emergency override (requires special permissions)
  async emergencyOverride(
    candidate: ImprovementCandidate,
    justification: string,
    approver: string
  ): Promise<OverrideResult> {
    // Log override attempt
    await this.auditLog.log({
      type: 'emergency_override',
      candidateId: candidate.id,
      justification,
      approver,
      timestamp: new Date()
    });

    // Override still requires logging and monitoring
    return {
      allowed: true,
      overrideId: generateId(),
      conditions: [
        'Change will be monitored extra carefully',
        'Rollback plan must be ready',
        'Impact measurement required within 24h'
      ]
    };
  }
}
```

### Approval Queue

```typescript
// packages/meta/src/constitution/approval-queue.ts

export interface ApprovalRequest {
  id: string;
  candidate: ImprovementCandidate;
  validation: ValidationResult;
  queuedAt: Date;
  reason: string;
  priority: number;
  status: 'pending' | 'approved' | 'rejected' | 'expired';
  reviewedAt?: Date;
  reviewedBy?: string;
  reviewNotes?: string;
}

export class ApprovalQueue {
  private readonly storage: ApprovalStorage;
  private readonly expirationDays = 7;

  constructor(storage: ApprovalStorage) {
    this.storage = storage;
  }

  async add(request: Omit<ApprovalRequest, 'id' | 'status'>): Promise<string> {
    const id = generateId();

    await this.storage.save({
      id,
      ...request,
      status: 'pending'
    });

    return id;
  }

  async getPending(): Promise<ApprovalRequest[]> {
    return this.storage.query({ status: 'pending' });
  }

  async approve(
    requestId: string,
    approver: string,
    notes?: string
  ): Promise<void> {
    await this.storage.update(requestId, {
      status: 'approved',
      reviewedAt: new Date(),
      reviewedBy: approver,
      reviewNotes: notes
    });
  }

  async reject(
    requestId: string,
    approver: string,
    reason: string
  ): Promise<void> {
    await this.storage.update(requestId, {
      status: 'rejected',
      reviewedAt: new Date(),
      reviewedBy: approver,
      reviewNotes: reason
    });
  }

  async cleanup(): Promise<number> {
    const expired = await this.storage.query({
      status: 'pending',
      olderThan: daysAgo(this.expirationDays)
    });

    for (const request of expired) {
      await this.storage.update(request.id, { status: 'expired' });
    }

    return expired.length;
  }
}
```

---

## Business Value

O Constitution Validator & Enforcer é o **guardião ativo** - aplica as regras da constitution a cada mudança proposta, garantindo conformidade e segurança.

**Benefícios:**
- Aplicação automática de regras
- Fila de aprovação para mudanças arriscadas
- Auditoria completa de decisões
- Override de emergência com rastreabilidade

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Rules bypassed accidentally | Low | Critical | Multiple checkpoints |
| Approval queue backlog | Medium | Low | Auto-expiration + cleanup |
| False rejections | Medium | Low | Appeal process + override |

---

## Scope

### In Scope
- ConstitutionValidator class
- ConstitutionEnforcer class
- ApprovalQueue management
- Rate limiting enforcement
- Emergency override

### Out of Scope
- Approval UI
- Notification system
- External approval workflows

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-034 (Constitution Rules) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Rate Limiting Configuration

```yaml
enforcement:
  maxAutoPerDay: 5
  cooldownBetweenAuto: 4h
  maxPendingApprovals: 50
  approvalExpirationDays: 7
```

### Override Permissions

```typescript
// Only specific roles can perform emergency override
const OVERRIDE_PERMISSIONS = ['admin', 'aios-master'];
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/constitution/validator.ts` | Create | Pending |
| `packages/meta/src/constitution/enforcer.ts` | Create | Pending |
| `packages/meta/src/constitution/approval-queue.ts` | Create | Pending |
| `packages/meta/src/constitution/errors.ts` | Create | Pending |
| `packages/meta/src/constitution/__tests__/validator.test.ts` | Create | Pending |
| `packages/meta/src/constitution/__tests__/enforcer.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Validator evaluates all rules correctly
- [ ] Enforcer filters candidates correctly
- [ ] Approval queue works
- [ ] Rate limiting enforced
- [ ] Audit logging works
- [ ] Emergency override available
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Validator evaluates all rules correctly
- [ ] Enforcer filters candidates correctly
- [ ] Approval queue works
- [ ] Rate limiting enforced
- [ ] Audit logging works
- [ ] Emergency override available
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
