# Story CL2-050: Pipeline Phase Hooks

**Story ID:** CL2-050
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 4 - Integration
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar sistema de hooks que permite executar codigo customizado em pontos especificos do pipeline. Hooks podem ser usados para integracoes externas, logging customizado, ou transformacoes de dados.

### Problem Statement
O pipeline Clone Lab precisa de extensoes para permitir integracoes e customizacoes sem modificar o codigo core. Hooks permitem que usuarios estendam o pipeline de forma limpa.

---

## Acceptance Criteria

```gherkin
Given a hook is registered for a pipeline phase
When the phase starts or completes
Then the hook is executed with appropriate context

Given multiple hooks are registered for the same phase
When the phase executes
Then hooks run in priority order

Given a hook throws an error
When error handling mode is configured
Then the pipeline either continues or halts based on configuration

Given a hook needs to modify pipeline data
When the hook executes
Then modifications are passed to subsequent phases
```

---

## Technical Requirements

### Hook System Architecture

```typescript
// packages/pipeline/src/hooks/types.ts

export type HookPhase =
  | 'extraction:before' | 'extraction:after'
  | 'analysis:before' | 'analysis:after'
  | 'synthesis:before' | 'synthesis:after'
  | 'validation:before' | 'validation:after'
  | 'checkpoint:before' | 'checkpoint:after'
  | 'generation:before' | 'generation:after'
  | 'finalization:before' | 'finalization:after';

export interface HookContext {
  phase: HookPhase;
  cloneId: string;
  sessionId: string;
  data: Record<string, any>;
  metadata: Record<string, any>;
}

export interface HookResult {
  success: boolean;
  data?: Record<string, any>;      // Modified data to pass forward
  error?: Error;
  shouldContinue?: boolean;        // Override default error behavior
}

export interface HookConfig {
  id: string;
  phase: HookPhase;
  priority: number;                // Lower = runs first
  timeout: number;                 // ms before timeout
  onError: 'continue' | 'halt' | 'rollback';
  enabled: boolean;
}

export type HookHandler = (context: HookContext) => Promise<HookResult>;
```

### Hook Registry

```typescript
// packages/pipeline/src/hooks/registry.ts

export class HookRegistry {
  private hooks: Map<HookPhase, RegisteredHook[]> = new Map();

  register(config: HookConfig, handler: HookHandler): void {
    const registered: RegisteredHook = { config, handler };

    if (!this.hooks.has(config.phase)) {
      this.hooks.set(config.phase, []);
    }

    this.hooks.get(config.phase)!.push(registered);
    this.sortHooks(config.phase);
  }

  unregister(hookId: string): boolean {
    for (const [phase, hooks] of this.hooks.entries()) {
      const index = hooks.findIndex(h => h.config.id === hookId);
      if (index !== -1) {
        hooks.splice(index, 1);
        return true;
      }
    }
    return false;
  }

  getHooks(phase: HookPhase): RegisteredHook[] {
    return this.hooks.get(phase) || [];
  }

  private sortHooks(phase: HookPhase): void {
    const hooks = this.hooks.get(phase);
    if (hooks) {
      hooks.sort((a, b) => a.config.priority - b.config.priority);
    }
  }
}
```

### Hook Executor

```typescript
// packages/pipeline/src/hooks/executor.ts

export class HookExecutor {
  constructor(
    private readonly registry: HookRegistry,
    private readonly logger: Logger
  ) {}

  async execute(phase: HookPhase, context: HookContext): Promise<HookExecutionContext> {
    const hooks = this.registry.getHooks(phase);
    const execContext: HookExecutionContext = {
      phase,
      originalData: { ...context.data },
      results: [],
      modifiedData: { ...context.data }
    };

    for (const hook of hooks) {
      if (!hook.config.enabled) {
        continue;
      }

      const result = await this.executeHook(hook, context);
      execContext.results.push({
        hookId: hook.config.id,
        result
      });

      // Handle errors
      if (!result.success) {
        const shouldContinue = this.shouldContinue(hook.config, result);
        if (!shouldContinue) {
          execContext.halted = true;
          execContext.haltedBy = hook.config.id;
          break;
        }
      }

      // Apply data modifications
      if (result.data) {
        execContext.modifiedData = {
          ...execContext.modifiedData,
          ...result.data
        };
        context.data = execContext.modifiedData;
      }
    }

    return execContext;
  }

  private async executeHook(
    hook: RegisteredHook,
    context: HookContext
  ): Promise<HookResult> {
    const timeout = hook.config.timeout || 30000;

    try {
      const result = await Promise.race([
        hook.handler(context),
        this.createTimeout(timeout, hook.config.id)
      ]);

      return result;
    } catch (error) {
      this.logger.error(`Hook ${hook.config.id} failed:`, error);
      return {
        success: false,
        error: error instanceof Error ? error : new Error(String(error))
      };
    }
  }

  private shouldContinue(config: HookConfig, result: HookResult): boolean {
    // Explicit override from hook
    if (result.shouldContinue !== undefined) {
      return result.shouldContinue;
    }

    // Config-based behavior
    switch (config.onError) {
      case 'continue':
        return true;
      case 'halt':
        return false;
      case 'rollback':
        return false; // Will trigger rollback in pipeline
      default:
        return false;
    }
  }

  private createTimeout(ms: number, hookId: string): Promise<HookResult> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Hook ${hookId} timed out after ${ms}ms`));
      }, ms);
    });
  }
}
```

### Pipeline Integration

```typescript
// packages/pipeline/src/pipeline/hooked-pipeline.ts

export class HookedPipeline {
  constructor(
    private readonly pipeline: ClonePipeline,
    private readonly hookExecutor: HookExecutor
  ) {}

  async run(input: PipelineInput): Promise<PipelineResult> {
    const sessionId = generateId();
    let context: HookContext = {
      phase: 'extraction:before',
      cloneId: input.cloneId,
      sessionId,
      data: { input },
      metadata: {}
    };

    // Extraction phase
    context = await this.runPhaseWithHooks('extraction', context, async () => {
      return this.pipeline.extract(input);
    });

    if (context.halted) {
      return this.createHaltedResult(context);
    }

    // Analysis phase
    context = await this.runPhaseWithHooks('analysis', context, async () => {
      return this.pipeline.analyze(context.data.extractionResult);
    });

    if (context.halted) {
      return this.createHaltedResult(context);
    }

    // Continue for other phases...

    return this.createSuccessResult(context);
  }

  private async runPhaseWithHooks(
    phaseName: string,
    context: HookContext,
    phaseFn: () => Promise<any>
  ): Promise<HookContext> {
    // Before hooks
    const beforePhase = `${phaseName}:before` as HookPhase;
    context.phase = beforePhase;
    const beforeResult = await this.hookExecutor.execute(beforePhase, context);
    context.data = beforeResult.modifiedData;

    if (beforeResult.halted) {
      context.halted = true;
      return context;
    }

    // Run phase
    const phaseResult = await phaseFn();
    context.data[`${phaseName}Result`] = phaseResult;

    // After hooks
    const afterPhase = `${phaseName}:after` as HookPhase;
    context.phase = afterPhase;
    const afterResult = await this.hookExecutor.execute(afterPhase, context);
    context.data = afterResult.modifiedData;

    if (afterResult.halted) {
      context.halted = true;
    }

    return context;
  }
}
```

### Built-in Hooks

```typescript
// packages/pipeline/src/hooks/built-in/logging-hook.ts

export function createLoggingHook(config: Partial<HookConfig> = {}): RegisteredHook {
  return {
    config: {
      id: 'builtin-logging',
      phase: 'extraction:before',
      priority: 1000,
      timeout: 5000,
      onError: 'continue',
      enabled: true,
      ...config
    },
    handler: async (context: HookContext): Promise<HookResult> => {
      console.log(`[Hook] ${context.phase} - Clone: ${context.cloneId}`);
      return { success: true };
    }
  };
}

// packages/pipeline/src/hooks/built-in/metrics-hook.ts

export function createMetricsHook(meter: MetricsMeter): RegisteredHook {
  return {
    config: {
      id: 'builtin-metrics',
      phase: 'extraction:after',
      priority: 100,
      timeout: 5000,
      onError: 'continue',
      enabled: true
    },
    handler: async (context: HookContext): Promise<HookResult> => {
      meter.recordCounter('pipeline_phase_completed', {
        phase: context.phase,
        cloneId: context.cloneId
      });
      return { success: true };
    }
  };
}

// packages/pipeline/src/hooks/built-in/webhook-hook.ts

export function createWebhookHook(url: string, config: Partial<HookConfig> = {}): RegisteredHook {
  return {
    config: {
      id: `webhook-${url}`,
      phase: 'finalization:after',
      priority: 500,
      timeout: 10000,
      onError: 'continue',
      enabled: true,
      ...config
    },
    handler: async (context: HookContext): Promise<HookResult> => {
      try {
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            phase: context.phase,
            cloneId: context.cloneId,
            data: context.data
          })
        });

        return { success: response.ok };
      } catch (error) {
        return { success: false, error };
      }
    }
  };
}
```

---

## Business Value

Hooks permitem extender o pipeline de forma limpa e modular, habilitando integracoes externas e customizacoes sem modificar codigo core.

**Beneficios:**
- Extensibilidade sem modificar core
- Integracoes externas via webhooks
- Logging e metricas customizadas
- Transformacoes de dados no pipeline
- Controle fino de error handling

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Hook malicioso | Low | High | Sandbox + whitelist de hooks |
| Hook lento afeta pipeline | Medium | Medium | Timeouts obrigatorios |
| Hooks conflitam entre si | Low | Medium | Prioridades + documentacao |
| Error handling inconsistente | Low | Medium | Configuracao clara de onError |

---

## Scope

### In Scope
- HookRegistry for registration
- HookExecutor for execution
- Pipeline integration
- Built-in hooks (logging, metrics, webhook)
- Error handling strategies
- Timeout support

### Out of Scope
- Hook sandboxing/isolation
- Distributed hooks
- Hook marketplace

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| Clone Pipeline v1.0 | Package | Available |
| Logger Package | Package | Available |
| Metrics System | Runtime | Available |

---

## Dev Notes

### Hook Configuration File

```yaml
# config/hooks.yaml
hooks:
  - id: notify-slack
    phase: finalization:after
    priority: 100
    timeout: 5000
    onError: continue
    enabled: true
    handler: ./handlers/slack-notification.js

  - id: validate-input
    phase: extraction:before
    priority: 1
    timeout: 30000
    onError: halt
    enabled: true
    handler: ./handlers/input-validator.js
```

### Available Phases

| Phase | When |
|-------|------|
| extraction:before | Before data extraction |
| extraction:after | After data extraction |
| analysis:before | Before Mind analysis |
| analysis:after | After Mind analysis |
| synthesis:before | Before DNA synthesis |
| synthesis:after | After DNA synthesis |
| validation:before | Before validation tasks |
| validation:after | After validation tasks |
| checkpoint:before | Before each checkpoint |
| checkpoint:after | After each checkpoint |
| generation:before | Before manifest generation |
| generation:after | After manifest generation |
| finalization:before | Before finalization |
| finalization:after | After finalization |

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/pipeline/src/hooks/types.ts` | Create | Pending |
| `packages/pipeline/src/hooks/registry.ts` | Create | Pending |
| `packages/pipeline/src/hooks/executor.ts` | Create | Pending |
| `packages/pipeline/src/hooks/built-in/logging-hook.ts` | Create | Pending |
| `packages/pipeline/src/hooks/built-in/metrics-hook.ts` | Create | Pending |
| `packages/pipeline/src/hooks/built-in/webhook-hook.ts` | Create | Pending |
| `packages/pipeline/src/hooks/index.ts` | Create | Pending |
| `packages/pipeline/src/pipeline/hooked-pipeline.ts` | Create | Pending |
| `packages/pipeline/src/__tests__/hooks.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] HookRegistry registers and manages hooks
- [ ] HookExecutor runs hooks with timeout
- [ ] Pipeline integration works correctly
- [ ] Built-in hooks functional
- [ ] Error handling strategies work
- [ ] Data modifications propagate
- [ ] Priority ordering correct
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Hooks execute at correct phases
- [ ] Priority ordering works
- [ ] Timeouts enforced
- [ ] Error handling correct
- [ ] Data modifications apply
- [ ] Built-in hooks functional

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
