# Story CL2-017: Synthesis Tasks SY-001 to SY-009

**Story ID:** CL2-017
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 2 - Validation
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar as 9 Validation Tasks de Sintese (SY-001 a SY-009), responsaveis por validar a integracao de todas as dimensoes analisadas em uma visao coesa e consistente da personalidade.

### Problem Statement
A sintese eh o processo de combinar todas as analises em um DNA coeso. Estas 9 tasks garantem que a integracao das dimensoes resulta em uma representacao consistente e nao contraditoria.

---

## Acceptance Criteria

```gherkin
Given analysis results from all categories
When synthesis tasks are executed
Then all 9 tasks return valid TaskResults

Given behavioral and values analysis results
When SY-002 (Cross-Dimensional Consistency) runs
Then it validates consistency across dimensions

Given synthesized personality profile
When SY-004 (Paradox Resolution) runs
Then it validates handling of apparent contradictions

Given integrated analysis
When SY-007 (DNA Completeness) runs
Then it validates completeness of DNA profile
```

---

## Technical Requirements

### Task Definitions

| Task ID | Name | Description |
|---------|------|-------------|
| SY-001 | Dimension Integration | Valida integracao de todas as dimensoes |
| SY-002 | Cross-Dimensional Consistency | Verifica consistencia entre dimensoes |
| SY-003 | Contradiction Detection | Detecta contradicoes aparentes |
| SY-004 | Paradox Resolution | Valida resolucao de paradoxos |
| SY-005 | Voice Consistency | Valida consistencia de voz/tom |
| SY-006 | Perspective Synthesis | Valida sintese de perspectivas |
| SY-007 | DNA Completeness | Valida completude do DNA |
| SY-008 | Synthesis Coherence | Valida coerencia da sintese |
| SY-009 | Fidelity Projection | Projeta fidelidade esperada |

### Implementation Example

```typescript
// packages/validation/src/tasks/synthesis/sy-002-cross-dimensional-consistency.ts

import { IValidationTask, TaskContext, TaskResult, TaskDefinition } from '../task.interface';

export class SY002CrossDimensionalConsistency implements IValidationTask {
  readonly definition: TaskDefinition = {
    id: 'SY-002',
    category: 'synthesis',
    name: 'Cross-Dimensional Consistency',
    description: 'Validates consistency between behavioral, values, and cognitive dimensions',
    requiredInputs: ['extractedData', 'previousTaskResults'],
    outputs: ['consistencyMatrix', 'conflicts', 'recommendations'],
    timeout: 60000,
    retryable: true,
    priority: 'critical'
  };

  async execute(context: TaskContext): Promise<TaskResult> {
    const startTime = Date.now();
    const findings: TaskFinding[] = [];

    const consistencyAnalysis = await this.analyzeConsistency(context);

    // Check for critical conflicts
    for (const conflict of consistencyAnalysis.conflicts) {
      if (conflict.severity === 'critical') {
        findings.push({
          type: 'issue',
          description: `Critical conflict: ${conflict.description}`,
          severity: 'critical',
          evidence: conflict.evidence
        });
      } else if (conflict.severity === 'high') {
        findings.push({
          type: 'warning',
          description: `Potential inconsistency: ${conflict.description}`,
          severity: 'high',
          evidence: conflict.evidence
        });
      }
    }

    const score = this.calculateScore(consistencyAnalysis);

    return {
      taskId: this.definition.id,
      status: score >= 60 ? 'passed' : 'failed',
      score,
      confidence: consistencyAnalysis.overallConfidence,
      findings,
      recommendations: this.generateRecommendations(consistencyAnalysis),
      executionTime: Date.now() - startTime,
      metadata: {
        consistencyMatrix: consistencyAnalysis.matrix,
        conflictsFound: consistencyAnalysis.conflicts.length,
        dimensionScores: consistencyAnalysis.dimensionScores
      }
    };
  }

  private async analyzeConsistency(context: TaskContext): Promise<ConsistencyAnalysis> {
    const matrix: ConsistencyMatrix = {
      behavioralValues: 0,
      behavioralCognitive: 0,
      valuesCognitive: 0
    };

    const conflicts: Conflict[] = [];

    // Get results from each dimension
    const behavioralResults = this.getDimensionResults(context, 'behavioral');
    const valuesResults = this.getDimensionResults(context, 'values');
    const cognitiveResults = this.getDimensionResults(context, 'cognitive');

    // Analyze behavioral-values consistency
    matrix.behavioralValues = this.compareDimensions(behavioralResults, valuesResults);
    conflicts.push(...this.findConflicts(behavioralResults, valuesResults, 'behavioral', 'values'));

    // Analyze behavioral-cognitive consistency
    matrix.behavioralCognitive = this.compareDimensions(behavioralResults, cognitiveResults);
    conflicts.push(...this.findConflicts(behavioralResults, cognitiveResults, 'behavioral', 'cognitive'));

    // Analyze values-cognitive consistency
    matrix.valuesCognitive = this.compareDimensions(valuesResults, cognitiveResults);
    conflicts.push(...this.findConflicts(valuesResults, cognitiveResults, 'values', 'cognitive'));

    const dimensionScores = {
      behavioral: this.calculateDimensionScore(behavioralResults),
      values: this.calculateDimensionScore(valuesResults),
      cognitive: this.calculateDimensionScore(cognitiveResults)
    };

    const overallConfidence = (matrix.behavioralValues + matrix.behavioralCognitive + matrix.valuesCognitive) / 3;

    return { matrix, conflicts, dimensionScores, overallConfidence };
  }

  private compareDimensions(dim1: DimensionResults, dim2: DimensionResults): number {
    // Compare key attributes between dimensions
    // Return consistency score 0-1
    let matches = 0;
    let comparisons = 0;

    for (const trait1 of dim1.traits) {
      for (const trait2 of dim2.traits) {
        if (this.areRelated(trait1, trait2)) {
          comparisons++;
          if (this.areConsistent(trait1, trait2)) {
            matches++;
          }
        }
      }
    }

    return comparisons > 0 ? matches / comparisons : 1;
  }

  private findConflicts(
    dim1: DimensionResults,
    dim2: DimensionResults,
    name1: string,
    name2: string
  ): Conflict[] {
    const conflicts: Conflict[] = [];

    for (const trait1 of dim1.traits) {
      for (const trait2 of dim2.traits) {
        if (this.areRelated(trait1, trait2) && !this.areConsistent(trait1, trait2)) {
          conflicts.push({
            dimension1: name1,
            dimension2: name2,
            trait1: trait1.name,
            trait2: trait2.name,
            description: `${trait1.name} (${name1}) conflicts with ${trait2.name} (${name2})`,
            severity: this.assessConflictSeverity(trait1, trait2),
            evidence: `${trait1.value} vs ${trait2.value}`
          });
        }
      }
    }

    return conflicts;
  }

  private calculateScore(analysis: ConsistencyAnalysis): number {
    const avgConsistency = (
      analysis.matrix.behavioralValues +
      analysis.matrix.behavioralCognitive +
      analysis.matrix.valuesCognitive
    ) / 3;

    // Base score from consistency
    let score = avgConsistency * 70;

    // Penalty for conflicts
    const criticalConflicts = analysis.conflicts.filter(c => c.severity === 'critical').length;
    const highConflicts = analysis.conflicts.filter(c => c.severity === 'high').length;

    score -= criticalConflicts * 15;
    score -= highConflicts * 5;

    // Bonus for high dimension scores
    const avgDimensionScore = (
      analysis.dimensionScores.behavioral +
      analysis.dimensionScores.values +
      analysis.dimensionScores.cognitive
    ) / 3;
    score += avgDimensionScore * 0.1;

    return Math.max(0, Math.min(100, Math.round(score)));
  }

  async validateInputs(context: TaskContext): Promise<boolean> {
    // Need results from all three dimensions
    const categories = ['behavioral', 'values', 'cognitive'];
    return categories.every(cat =>
      Array.from(context.previousResults.keys()).some(k => k.startsWith(cat.substring(0, 2).toUpperCase()))
    );
  }

  canExecute(context: TaskContext): boolean {
    return context.previousResults.size >= 10; // Need enough previous results
  }

  getDependencies(): TaskId[] {
    return ['BH-001', 'VL-001', 'CG-001']; // Core tasks from each dimension
  }
}
```

### File Structure

```
packages/validation/src/tasks/synthesis/
├── sy-001-dimension-integration.ts
├── sy-002-cross-dimensional-consistency.ts
├── sy-003-contradiction-detection.ts
├── sy-004-paradox-resolution.ts
├── sy-005-voice-consistency.ts
├── sy-006-perspective-synthesis.ts
├── sy-007-dna-completeness.ts
├── sy-008-synthesis-coherence.ts
├── sy-009-fidelity-projection.ts
├── index.ts
└── __tests__/
    └── synthesis-tasks.test.ts
```

---

## Business Value

As Synthesis Tasks sao o **ponto de integracao** onde todas as analises se encontram. Elas garantem que o DNA resultante eh coeso e nao contraditorio.

**Beneficios:**
- Detecta inconsistencias entre dimensoes
- Valida coerencia do perfil integrado
- Projeta fidelidade esperada do clone
- Fornece feedback para refinamento

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Falsos conflitos | Medium | Medium | Thresholds configuraveis |
| Complexidade de integracao | High | High | Testes extensivos |
| Dependencia de outras tasks | High | Medium | Ordem de execucao clara |

---

## Scope

### In Scope
- All 9 synthesis task implementations
- Unit tests for each task
- Cross-dimensional consistency logic
- Finding and recommendation generation

### Out of Scope
- Other task categories
- Task Registry & Executor
- CLI integration

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-012 (Task Interface) | Package | Pending |
| CL2-013 to CL2-016 (All Categories) | Package | Pending |
| @clone-lab/minds (Charlie) | Package | Pending |

---

## Dev Notes

- Synthesis tasks should run after all category tasks
- Use weighted scoring for consistency
- Consider using LLM for paradox resolution
- Add fidelity prediction model

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/validation/src/tasks/synthesis/sy-001-dimension-integration.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-002-cross-dimensional-consistency.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-003-contradiction-detection.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-004-paradox-resolution.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-005-voice-consistency.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-006-perspective-synthesis.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-007-dna-completeness.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-008-synthesis-coherence.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/sy-009-fidelity-projection.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/index.ts` | Create | Pending |
| `packages/validation/src/tasks/synthesis/__tests__/synthesis-tasks.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] All 9 tasks implement IValidationTask correctly
- [ ] Each task returns valid TaskResult
- [ ] Cross-dimensional consistency is validated
- [ ] Findings are descriptive and actionable
- [ ] Unit tests pass (coverage > 80%)
- [ ] Handles edge cases gracefully
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] All 9 tasks execute without errors
- [ ] Task results are consistent
- [ ] Conflicts are accurately detected
- [ ] Fidelity projection is reasonable
- [ ] Edge cases handled

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
