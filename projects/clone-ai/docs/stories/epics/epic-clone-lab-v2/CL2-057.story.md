# Story CL2-057: Impact Measurement System

**Story ID:** CL2-057
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 5 - Self-Evolution
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Impact Measurement System** - sistema que mede o impacto de melhorias aplicadas, comparando métricas antes e depois para determinar se a mudança foi positiva ou negativa.

### Problem Statement
Para que o sistema evolua corretamente, é essencial medir o impacto real de cada melhoria aplicada. Sem isso, não é possível saber se as mudanças estão realmente melhorando o sistema.

---

## Acceptance Criteria

```gherkin
Given an improvement was applied
When the measurement period begins
Then baseline metrics are captured

Given the measurement period has elapsed
When impact is calculated
Then before/after comparison is available

Given an improvement had positive impact
When measurement completes
Then the improvement is marked as successful

Given an improvement had negative impact
When measurement completes
Then a rollback is recommended

Given multiple improvements were applied
When impact is measured
Then each improvement's contribution is estimated
```

---

## Technical Requirements

### Impact Measurement Engine

```typescript
// packages/meta/src/impact/measurement-engine.ts

export interface ImpactMeasurement {
  improvementId: string;
  appliedAt: Date;
  baseline: MetricSnapshot;
  measurementPeriod: Duration;
  measurements: MetricSnapshot[];
  finalAssessment?: ImpactAssessment;
}

export interface MetricSnapshot {
  timestamp: Date;
  metrics: Record<string, number>;
}

export interface ImpactAssessment {
  overall: 'positive' | 'negative' | 'neutral';
  confidence: number;
  metricChanges: MetricChange[];
  recommendation: 'keep' | 'rollback' | 'monitor';
}

export interface MetricChange {
  metric: string;
  before: number;
  after: number;
  change: number;           // Percentage
  changeType: 'improvement' | 'regression' | 'neutral';
  significance: number;     // Statistical significance
}

export class ImpactMeasurementEngine {
  private readonly config: MeasurementConfig;
  private readonly metricsCollector: MetricsCollector;
  private readonly pendingMeasurements: Map<string, ImpactMeasurement>;

  constructor(
    config: MeasurementConfig,
    metricsCollector: MetricsCollector
  ) {
    this.config = config;
    this.metricsCollector = metricsCollector;
    this.pendingMeasurements = new Map();
  }

  async startMeasurement(improvementId: string): Promise<void> {
    const baseline = await this.captureBaseline();

    const measurement: ImpactMeasurement = {
      improvementId,
      appliedAt: new Date(),
      baseline,
      measurementPeriod: this.config.defaultPeriod,
      measurements: []
    };

    this.pendingMeasurements.set(improvementId, measurement);

    // Schedule periodic measurements
    this.schedulePeriodicMeasurements(measurement);
  }

  async completeMeasurement(improvementId: string): Promise<ImpactAssessment> {
    const measurement = this.pendingMeasurements.get(improvementId);
    if (!measurement) {
      throw new Error(`No pending measurement for: ${improvementId}`);
    }

    // Capture final snapshot
    const finalSnapshot = await this.captureBaseline();
    measurement.measurements.push(finalSnapshot);

    // Calculate assessment
    const assessment = this.calculateAssessment(measurement);
    measurement.finalAssessment = assessment;

    // Store result
    await this.storeMeasurement(measurement);

    // Clean up
    this.pendingMeasurements.delete(improvementId);

    return assessment;
  }

  private async captureBaseline(): Promise<MetricSnapshot> {
    const metrics: Record<string, number> = {};

    for (const metricName of this.config.trackedMetrics) {
      const value = await this.metricsCollector.getAggregated(
        metricName,
        { start: subHours(new Date(), 24), end: new Date() },
        'avg'
      );
      metrics[metricName] = value[0]?.value ?? 0;
    }

    return {
      timestamp: new Date(),
      metrics
    };
  }

  private calculateAssessment(measurement: ImpactMeasurement): ImpactAssessment {
    const changes: MetricChange[] = [];

    for (const [metric, beforeValue] of Object.entries(measurement.baseline.metrics)) {
      const afterSnapshot = measurement.measurements[measurement.measurements.length - 1];
      const afterValue = afterSnapshot?.metrics[metric] ?? 0;

      const change = beforeValue !== 0
        ? ((afterValue - beforeValue) / beforeValue) * 100
        : 0;

      const metricConfig = this.config.metricConfigs[metric];
      const isImprovement = metricConfig?.higherIsBetter
        ? change > 0
        : change < 0;

      changes.push({
        metric,
        before: beforeValue,
        after: afterValue,
        change,
        changeType: isImprovement ? 'improvement' : change === 0 ? 'neutral' : 'regression',
        significance: this.calculateSignificance(beforeValue, afterValue)
      });
    }

    // Calculate overall assessment
    const improvements = changes.filter(c => c.changeType === 'improvement').length;
    const regressions = changes.filter(c => c.changeType === 'regression').length;

    let overall: 'positive' | 'negative' | 'neutral';
    let recommendation: 'keep' | 'rollback' | 'monitor';

    if (improvements > regressions * 2) {
      overall = 'positive';
      recommendation = 'keep';
    } else if (regressions > improvements * 2) {
      overall = 'negative';
      recommendation = 'rollback';
    } else {
      overall = 'neutral';
      recommendation = 'monitor';
    }

    return {
      overall,
      confidence: this.calculateConfidence(changes),
      metricChanges: changes,
      recommendation
    };
  }

  private calculateSignificance(before: number, after: number): number {
    // Simplified significance calculation
    const change = Math.abs(after - before);
    const baseline = Math.max(Math.abs(before), 0.001);
    return Math.min(1, change / baseline);
  }

  private calculateConfidence(changes: MetricChange[]): number {
    // Higher significance values = higher confidence
    const avgSignificance = changes.reduce((sum, c) => sum + c.significance, 0) / changes.length;
    return Math.min(1, avgSignificance * 2);
  }
}
```

### Tracked Metrics Configuration

```typescript
// packages/meta/src/impact/metrics-config.ts

export const DEFAULT_TRACKED_METRICS: MetricConfig = {
  trackedMetrics: [
    'clone_fidelity_score',
    'clone_operation_duration_seconds',
    'mind_confidence_score',
    'validation_task_success_rate',
    'system_error_rate'
  ],
  metricConfigs: {
    'clone_fidelity_score': {
      higherIsBetter: true,
      weight: 3
    },
    'clone_operation_duration_seconds': {
      higherIsBetter: false,
      weight: 2
    },
    'mind_confidence_score': {
      higherIsBetter: true,
      weight: 2
    },
    'validation_task_success_rate': {
      higherIsBetter: true,
      weight: 1
    },
    'system_error_rate': {
      higherIsBetter: false,
      weight: 3
    }
  },
  defaultPeriod: { hours: 24 }
};
```

---

## Business Value

O Impact Measurement System permite **avaliar objetivamente** se as melhorias aplicadas estão funcionando, fornecendo dados para decisões de rollback ou manutenção da mudança.

**Benefícios:**
- Feedback objetivo sobre melhorias
- Decisões baseadas em dados
- Detecção precoce de regressões
- Aprendizado para futuras melhorias
- Confiança no sistema de auto-evolução

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Período de medição muito curto | Medium | Medium | Configurável + recomendações |
| Ruído nos dados | Medium | Medium | Médias + filtros estatísticos |
| Correlação != causalidade | High | Low | Múltiplas métricas + confiança |

---

## Scope

### In Scope
- ImpactMeasurementEngine class
- Baseline capture
- Periodic measurements
- Assessment calculation
- Recommendation generation

### Out of Scope
- A/B testing
- Statistical significance testing
- ML-based impact prediction

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-029 (Metrics Collector) | Package | Pending |
| CL2-036 (Auto-Improvement Engine) | Package | Ready |

---

## Dev Notes

### Default Measurement Period

```yaml
impact_measurement:
  default_period_hours: 24
  min_period_hours: 4
  max_period_hours: 168  # 1 week
  measurement_intervals: 6  # Every 4 hours for 24h period
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/impact/measurement-engine.ts` | Create | Pending |
| `packages/meta/src/impact/metrics-config.ts` | Create | Pending |
| `packages/meta/src/impact/types.ts` | Create | Pending |
| `packages/meta/src/impact/index.ts` | Create | Pending |
| `packages/meta/src/impact/__tests__/measurement.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Baseline metrics captured correctly
- [ ] Periodic measurements work
- [ ] Assessment calculation accurate
- [ ] Recommendations generated
- [ ] Integration with improvement engine
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Baseline capture works
- [ ] Measurements recorded
- [ ] Assessment calculated correctly
- [ ] Recommendations reasonable
- [ ] Integration works

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
