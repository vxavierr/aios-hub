# Story CL2-063: End-to-End Self-Evolution Test

**Story ID:** CL2-063
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 5 - Self-Evolution
**Status:** Ready
**Points:** 8
**Author:** Morgan (PM)

---

## Description

Implementar **testes end-to-end** completos do sistema de auto-evolução, validando todo o fluxo desde detecção de melhorias até aplicação, medição de impacto e rollback.

---

## Acceptance Criteria

```gherkin
Given the full self-evolution pipeline
When end-to-end test runs
Then complete cycle executes successfully

Given an improvement is identified
When auto-approved and applied
Then impact is measured correctly

Given a negative impact improvement
When rollback is triggered
Then system returns to previous state

Given all E2E tests pass
When validation completes
Then system is ready for production
```

---

## Technical Requirements

### E2E Test Scenarios

```typescript
// packages/meta/src/__tests__/e2e/self-evolution.e2e.test.ts

describe('Self-Evolution E2E', () => {

  test('complete improvement cycle - auto-approved', async () => {
    // 1. Setup: Create test data with known issues
    const testData = await setupTestData({
      fidelityScore: 70, // Below threshold
      unusedTasks: ['EX-003'] // Task not used
    });

    // 2. Trigger assessment
    const assessment = await selfAssessment.assess();

    // 3. Verify improvement identified
    expect(assessment.improvements).toContainEqual(
      expect.objectContaining({
        category: 'remove',
        target: expect.stringContaining('EX-003')
      })
    );

    // 4. Run improvement cycle
    const result = await autoImprovementEngine.runImprovementCycle();

    // 5. Verify auto-applied
    expect(result.autoApplied).toHaveLength(1);

    // 6. Verify impact measured
    await waitForMeasurement();
    const impact = await impactMeasurement.getMeasurement(result.autoApplied[0].id);
    expect(impact.overall).toBe('positive');
  });

  test('improvement requires human approval', async () => {
    // Setup improvement that needs approval
    const proposal = await queueImprovement({
      category: 'modify',
      target: 'checkpoints/CP-1/threshold',
      riskLevel: 60
    });

    // Verify queued for approval
    const pending = await approvalQueue.getPending();
    expect(pending).toContainEqual(
      expect.objectContaining({ id: proposal.id })
    );

    // Approve
    await approvalQueue.approve(proposal.id, 'test-reviewer');

    // Verify applied
    const applied = await getAppliedImprovements();
    expect(applied).toContainEqual(
      expect.objectContaining({ improvementId: proposal.id })
    );
  });

  test('rollback on negative impact', async () => {
    // Apply an improvement that will have negative impact
    const improvement = await applyImprovement({
      category: 'modify',
      target: 'minds/tim/prompts',
      change: 'BREAK_THE_PROMPT' // Intentionally bad
    });

    // Wait for measurement
    await waitForMeasurement();
    const impact = await impactMeasurement.getMeasurement(improvement.id);

    // Verify negative assessment
    expect(impact.overall).toBe('negative');
    expect(impact.recommendation).toBe('rollback');

    // Trigger rollback
    await rollbackManager.rollback(improvement.id);

    // Verify rollback completed
    const state = await getSystemState();
    expect(state.improvements.active).not.toContain(improvement.id);
  });

  test('constitution prevents forbidden changes', async () => {
    // Try to apply forbidden improvement
    const forbiddenImprovement = {
      category: 'remove',
      target: 'checkpoints/all', // Forbidden
      riskLevel: 10
    };

    // Should be rejected
    await expect(
      autoImprovementEngine.apply(forbiddenImprovement)
    ).rejects.toThrow('forbidden by constitution');

    // Verify not in applied list
    const applied = await getAppliedImprovements();
    expect(applied).not.toContainEqual(
      expect.objectContaining({ target: 'checkpoints/all' })
    );
  });

  test('rate limiting prevents too many changes', async () => {
    // Apply 5 improvements (daily limit)
    for (let i = 0; i < 5; i++) {
      await applyImprovement({
        category: 'modify',
        target: `minds/tim/prompts/v${i}`,
        riskLevel: 10
      });
    }

    // Try 6th - should be blocked
    await expect(
      applyImprovement({
        category: 'modify',
        target: 'minds/tim/prompts/v6',
        riskLevel: 10
      })
    ).rejects.toThrow('rate limit exceeded');
  });

  test('evolution log captures all changes', async () => {
    // Apply several improvements
    const improvements = [];
    for (let i = 0; i < 3; i++) {
      improvements.push(await applyImprovement({
        category: 'modify',
        target: `test/target/${i}`,
        riskLevel: 10
      }));
    }

    // Query evolution log
    const log = await evolutionLog.getEntries({
      from: subHours(new Date(), 1),
      to: new Date()
    });

    // Verify all captured
    expect(log).toHaveLength(3);
    expect(log.map(e => e.improvementId)).toEqual(improvements.map(i => i.id));
  });
});
```

### Test Infrastructure

```typescript
// packages/meta/src/__tests__/e2e/test-helpers.ts

export async function setupTestData(config: TestConfig): Promise<TestData> {
  // Create test clone data
  // Configure mock metrics
  // Setup test minds
}

export async function waitForMeasurement(): Promise<void> {
  // Wait for impact measurement period
  await new Promise(resolve => setTimeout(resolve, 100));
}

export async function resetTestState(): Promise<void> {
  // Clear all test data
  // Reset metrics
  // Clear evolution log
}
```

---

## Business Value

E2E tests garantem que todo o sistema de auto-evolução funciona corretamente antes de ir para produção.

**Benefícios:** Confiança no sistema, detecção de bugs, documentação viva, regressão protegida

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Testes lentos | Medium | Low | Paralelização + mocks |
| Falsos positivos | Medium | Medium | Testes determinísticos |
| Estado não limpo | Low | High | Reset obrigatório |

---

## Scope

### In Scope
- All E2E test scenarios
- Test infrastructure
- CI integration

### Out of Scope
- Performance tests
- Load tests
- Chaos engineering

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| All Phase 3-5 stories | Package | Pending |
| Vitest | Package | Available |

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/__tests__/e2e/self-evolution.e2e.test.ts` | Create | Pending |
| `packages/meta/src/__tests__/e2e/test-helpers.ts` | Create | Pending |
| `packages/meta/src/__tests__/e2e/setup.ts` | Create | Pending |

---

## Definition of Done

- [ ] All E2E test scenarios implemented
- [ ] Tests pass consistently
- [ ] CI integration works
- [ ] Test coverage > 90% of evolution flow
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Complete cycle test passes
- [ ] Approval flow test passes
- [ ] Rollback test passes
- [ ] Constitution test passes
- [ ] Rate limit test passes
- [ ] Evolution log test passes

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
