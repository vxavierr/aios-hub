# Story CL2-040: Result Tracker

**Story ID:** CL2-040
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar o **Result Tracker** - componente que rastreia os resultados de mudanças aplicadas, medindo impacto real vs. esperado.

### Problem Statement
O Clone Lab precisa medir se as mudanças aplicadas tiveram o impacto esperado. O Result Tracker monitora métricas antes e depois das mudanças para avaliar eficácia.

---

## Acceptance Criteria

```gherkin
Given a change was applied
When result tracking period begins
Then baseline metrics are captured

Given tracking period has elapsed
When impact is calculated
Then before/after comparison is available

Given a change had positive impact
When results are recorded
Then success is logged for future reference

Given a change had negative impact
When results are recorded
Then it may trigger rollback consideration
```

---

## Technical Requirements

### Result Tracker

```typescript
// packages/meta/src/tracking/result-tracker.ts

export interface TrackedResult {
  id: string;
  changeId: string;              // Change being tracked
  baseline: MetricBaseline;
  measurements: Measurement[];
  impact: ImpactAssessment;
  trackingPeriod: Duration;
  startedAt: Date;
  completedAt: Date | null;
  status: 'tracking' | 'completed' | 'failed';
}

export interface MetricBaseline {
  capturedAt: Date;
  metrics: Record<string, number>;
  sampleSize: number;
}

export interface Measurement {
  capturedAt: Date;
  metrics: Record<string, number>;
  deltaFromBaseline: Record<string, number>;
}

export interface ImpactAssessment {
  overallScore: number;          // -100 to +100
  metrics: MetricImpact[];
  verdict: 'positive' | 'neutral' | 'negative';
  confidence: number;
  recommendation: 'keep' | 'rollback' | 'monitor';
}

export interface MetricImpact {
  name: string;
  baseline: number;
  current: number;
  change: number;                // Percentage change
  direction: 'improved' | 'unchanged' | 'degraded';
  weight: number;
}

export class ResultTracker {
  private readonly metricsCollector: MetricsCollector;
  private readonly evolutionLog: EvolutionLog;
  private readonly config: TrackingConfig;

  constructor(
    metricsCollector: MetricsCollector,
    evolutionLog: EvolutionLog,
    config: TrackingConfig
  ) {
    this.metricsCollector = metricsCollector;
    this.evolutionLog = evolutionLog;
    this.config = config;
  }

  async startTracking(changeId: string): Promise<TrackedResult> {
    // Capture baseline metrics
    const baseline = await this.captureBaseline();

    const result: TrackedResult = {
      id: generateId(),
      changeId,
      baseline,
      measurements: [],
      impact: null as any,
      trackingPeriod: this.config.defaultTrackingPeriod,
      startedAt: new Date(),
      completedAt: null,
      status: 'tracking'
    };

    await this.saveResult(result);

    // Schedule periodic measurements
    await this.scheduleMeasurements(result);

    // Schedule final assessment
    await this.scheduleFinalAssessment(result);

    return result;
  }

  async recordMeasurement(resultId: string): Promise<Measurement> {
    const result = await this.getResult(resultId);
    if (!result) {
      throw new Error(`Result not found: ${resultId}`);
    }

    // Capture current metrics
    const currentMetrics = await this.captureMetrics();
    const deltaFromBaseline = this.calculateDelta(
      result.baseline.metrics,
      currentMetrics
    );

    const measurement: Measurement = {
      capturedAt: new Date(),
      metrics: currentMetrics,
      deltaFromBaseline
    };

    result.measurements.push(measurement);
    await this.saveResult(result);

    return measurement;
  }

  async assessImpact(resultId: string): Promise<ImpactAssessment> {
    const result = await this.getResult(resultId);
    if (!result) {
      throw new Error(`Result not found: ${resultId}`);
    }

    // Get latest measurement or capture new one
    const latestMeasurement = result.measurements[result.measurements.length - 1] ||
      await this.recordMeasurement(resultId);

    // Calculate impact for each metric
    const metricImpacts = this.calculateMetricImpacts(
      result.baseline.metrics,
      latestMeasurement.metrics
    );

    // Calculate overall score (weighted average)
    const overallScore = this.calculateOverallScore(metricImpacts);

    // Determine verdict
    const verdict = this.determineVerdict(overallScore);

    // Generate recommendation
    const recommendation = this.generateRecommendation(overallScore, metricImpacts);

    const impact: ImpactAssessment = {
      overallScore,
      metrics: metricImpacts,
      verdict,
      confidence: this.calculateConfidence(result),
      recommendation
    };

    result.impact = impact;
    result.completedAt = new Date();
    result.status = 'completed';

    await this.saveResult(result);

    // Log the impact assessment
    await this.evolutionLog.logImpact({
      resultId,
      changeId: result.changeId,
      impact,
      timestamp: new Date()
    });

    return impact;
  }

  private async captureBaseline(): Promise<MetricBaseline> {
    const metrics = await this.captureMetrics();
    return {
      capturedAt: new Date(),
      metrics,
      sampleSize: this.config.baselineSampleSize
    };
  }

  private async captureMetrics(): Promise<Record<string, number>> {
    const metricNames = this.config.trackedMetrics;
    const metrics: Record<string, number> = {};

    for (const name of metricNames) {
      const aggregated = await this.metricsCollector.getAggregated(
        name,
        { start: hoursAgo(1), end: now() },
        'avg'
      );
      metrics[name] = aggregated[0]?.value || 0;
    }

    return metrics;
  }

  private calculateDelta(
    baseline: Record<string, number>,
    current: Record<string, number>
  ): Record<string, number> {
    const delta: Record<string, number> = {};

    for (const [key, baselineValue] of Object.entries(baseline)) {
      const currentValue = current[key] || 0;
      if (baselineValue !== 0) {
        delta[key] = ((currentValue - baselineValue) / baselineValue) * 100;
      } else {
        delta[key] = currentValue > 0 ? 100 : 0;
      }
    }

    return delta;
  }

  private calculateMetricImpacts(
    baseline: Record<string, number>,
    current: Record<string, number>
  ): MetricImpact[] {
    const impacts: MetricImpact[] = [];
    const weights = this.config.metricWeights;

    for (const [name, baselineValue] of Object.entries(baseline)) {
      const currentValue = current[name] || 0;
      const change = baselineValue !== 0
        ? ((currentValue - baselineValue) / baselineValue) * 100
        : (currentValue > 0 ? 100 : 0);

      const isImprovement = this.isImprovement(name, change);

      impacts.push({
        name,
        baseline: baselineValue,
        current: currentValue,
        change,
        direction: isImprovement ? 'improved' : change === 0 ? 'unchanged' : 'degraded',
        weight: weights[name] || 1
      });
    }

    return impacts;
  }

  private isImprovement(metricName: string, changePercent: number): boolean {
    // Some metrics are "higher is better", others "lower is better"
    const higherIsBetter = [
      'clone_fidelity_score',
      'mind_confidence_score',
      'success_rate'
    ];

    const lowerIsBetter = [
      'execution_time',
      'error_count',
      'bottleneck_events'
    ];

    if (higherIsBetter.some(m => metricName.includes(m))) {
      return changePercent > 0;
    }

    if (lowerIsBetter.some(m => metricName.includes(m))) {
      return changePercent < 0;
    }

    return changePercent > 0;
  }

  private calculateOverallScore(impacts: MetricImpact[]): number {
    let weightedSum = 0;
    let totalWeight = 0;

    for (const impact of impacts) {
      const score = impact.direction === 'improved' ? impact.change :
        impact.direction === 'degraded' ? -impact.change : 0;
      weightedSum += score * impact.weight;
      totalWeight += impact.weight;
    }

    return totalWeight > 0 ? Math.round(weightedSum / totalWeight) : 0;
  }

  private determineVerdict(score: number): 'positive' | 'neutral' | 'negative' {
    if (score >= 5) return 'positive';
    if (score <= -5) return 'negative';
    return 'neutral';
  }

  private generateRecommendation(
    score: number,
    impacts: MetricImpact[]
  ): 'keep' | 'rollback' | 'monitor' {
    // Check for critical degradation
    const criticalDegrades = impacts.filter(
      i => i.direction === 'degraded' && Math.abs(i.change) > 20
    );

    if (criticalDegrades.length > 0) {
      return 'rollback';
    }

    if (score >= 5) {
      return 'keep';
    }

    return 'monitor';
  }

  private calculateConfidence(result: TrackedResult): number {
    // More measurements = higher confidence
    const measurementScore = Math.min(result.measurements.length * 10, 50);

    // Longer tracking period = higher confidence
    const elapsedHours = (Date.now() - result.startedAt.getTime()) / (1000 * 60 * 60);
    const durationScore = Math.min(elapsedHours * 2, 30);

    // Sample size contribution
    const sampleScore = Math.min(result.baseline.sampleSize * 2, 20);

    return Math.min(measurementScore + durationScore + sampleScore, 100);
  }
}
```

### Tracking Configuration

```yaml
# packages/meta/src/tracking/config.yaml

tracking:
  defaultTrackingPeriod: 24h
  baselineSampleSize: 10
  measurementInterval: 1h

  trackedMetrics:
    - clone_fidelity_score
    - clone_operation_duration_seconds
    - validation_task_executions_total
    - mind_confidence_score
    - system_bottleneck_events_total

  metricWeights:
    clone_fidelity_score: 3.0
    clone_operation_duration_seconds: 1.0
    validation_task_executions_total: 1.0
    mind_confidence_score: 2.0
    system_bottleneck_events_total: 1.5

  thresholds:
    positiveThreshold: 5
    negativeThreshold: -5
    criticalThreshold: -20
```

---

## Business Value

O Result Tracker permite **medir a eficácia das mudanças**, garantindo que melhorias tenham impacto real e positivo.

**Benefícios:**
- Medição objetiva de impacto
- Base para decisões de rollback
- Dados para aprendizado do sistema
- Feedback loop para auto-improvement

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| External factors affect metrics | High | Medium | Control group comparison |
| Insufficient tracking period | Medium | Low | Configurable duration |
| Baseline variance | Medium | Medium | Multiple baseline samples |

---

## Scope

### In Scope
- ResultTracker class
- Baseline capture
- Periodic measurements
- Impact assessment
- Recommendation generation

### Out of Scope
- A/B testing
- Control groups
- Real-time monitoring

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-029 (Metrics Collector) | Package | Pending |
| CL2-041 (Evolution Log) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Measurement Schedule

```typescript
// Schedule measurements at regular intervals
const SCHEDULE = {
  immediate: 0,          // Right after change
  short: '1h',           // 1 hour
  medium: '6h',          // 6 hours
  long: '24h',           // 24 hours (final)
  extended: '7d'         // 7 days (extended monitoring)
};
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/tracking/result-tracker.ts` | Create | Pending |
| `packages/meta/src/tracking/config.yaml` | Create | Pending |
| `packages/meta/src/tracking/types.ts` | Create | Pending |
| `packages/meta/src/tracking/index.ts` | Create | Pending |
| `packages/meta/src/tracking/__tests__/result-tracker.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Baseline capture works
- [ ] Periodic measurements captured
- [ ] Impact assessment calculates correctly
- [ ] Recommendations generated
- [ ] Evolution log integration works
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Baseline capture works
- [ ] Periodic measurements captured
- [ ] Impact assessment calculates correctly
- [ ] Recommendations generated
- [ ] Evolution log integration works
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
