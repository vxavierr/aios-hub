# Story CL2-055: Auto-Improvement Scheduler

**Story ID:** CL2-055
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 5 - Self-Evolution
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Auto-Improvement Scheduler** - componente responsável por agendar e executar ciclos de auto-melhoria do sistema em intervalos configuráveis, respeitando rate limits e janelas de manutenção.

### Problem Statement
O sistema de auto-melhoria precisa ser executado automaticamente em intervalos regulares, mas de forma controlada para não impactar operações normais e respeitar rate limits de mudanças.

---

## Acceptance Criteria

```gherkin
Given the auto-improvement system is enabled
When the scheduled time arrives
Then an improvement cycle is triggered automatically

Given a maintenance window is configured
When scheduling improvement cycles
Then cycles only run during the maintenance window

Given the daily rate limit is reached
When another cycle would be scheduled
Then it is deferred to the next day

Given the scheduler is running
When the system is shut down gracefully
Then pending cycles are persisted and resumed on restart
```

---

## Technical Requirements

### Auto-Improvement Scheduler

```typescript
// packages/meta/src/scheduler/improvement-scheduler.ts

export interface SchedulerConfig {
  enabled: boolean;
  interval: Duration;              // Time between cycles
  maintenanceWindow: {
    start: string;                 // "22:00"
    end: string;                   // "06:00"
    timezone: string;              // "America/Sao_Paulo"
  };
  rateLimits: {
    maxChangesPerDay: number;
    maxChangesPerWeek: number;
    cooldownBetweenChanges: Duration;
  };
  retry: {
    maxAttempts: number;
    backoffMultiplier: number;
  };
}

export class AutoImprovementScheduler {
  private readonly config: SchedulerConfig;
  private readonly engine: AutoImprovementEngine;
  private readonly stateStore: SchedulerStateStore;
  private timer?: NodeJS.Timeout;
  private isRunning = false;

  constructor(
    config: SchedulerConfig,
    engine: AutoImprovementEngine,
    stateStore: SchedulerStateStore
  ) {
    this.config = config;
    this.engine = engine;
    this.stateStore = stateStore;
  }

  start(): void {
    if (!this.config.enabled || this.isRunning) return;

    this.isRunning = true;
    this.scheduleNextCycle();
  }

  stop(): void {
    this.isRunning = false;
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = undefined;
    }
  }

  private scheduleNextCycle(): void {
    if (!this.isRunning) return;

    const nextRun = this.calculateNextRunTime();

    this.timer = setTimeout(async () => {
      await this.runCycle();
      this.scheduleNextCycle();
    }, nextRun.msUntil);
  }

  private calculateNextRunTime(): NextRunTime {
    const now = new Date();

    // Check if within maintenance window
    if (!this.isWithinMaintenanceWindow(now)) {
      return this.getNextMaintenanceWindowStart(now);
    }

    // Check rate limits
    if (this.isRateLimitExceeded()) {
      return this.getNextRateLimitReset();
    }

    // Normal scheduling
    return {
      time: new Date(now.getTime() + this.config.interval.ms),
      msUntil: this.config.interval.ms
    };
  }

  private async runCycle(): Promise<void> {
    try {
      // Persist state before running
      await this.stateStore.save({
        lastRunStart: new Date(),
        status: 'running'
      });

      // Run improvement cycle
      const result = await this.engine.runImprovementCycle();

      // Persist result
      await this.stateStore.save({
        lastRunEnd: new Date(),
        status: 'completed',
        lastResult: result
      });

    } catch (error) {
      await this.stateStore.save({
        lastRunEnd: new Date(),
        status: 'failed',
        lastError: error.message
      });

      // Schedule retry with backoff
      this.scheduleRetry();
    }
  }

  private isWithinMaintenanceWindow(time: Date): boolean {
    const window = this.config.maintenanceWindow;
    const hour = time.getHours();
    const [startHour] = window.start.split(':').map(Number);
    const [endHour] = window.end.split(':').map(Number);

    if (startHour > endHour) {
      // Window spans midnight
      return hour >= startHour || hour < endHour;
    }
    return hour >= startHour && hour < endHour;
  }

  private isRateLimitExceeded(): boolean {
    const limits = this.config.rateLimits;
    const today = this.stateStore.getTodayChanges();
    const thisWeek = this.stateStore.getWeekChanges();

    return today >= limits.maxChangesPerDay ||
           thisWeek >= limits.maxChangesPerWeek;
  }
}
```

### Scheduler State Store

```typescript
// packages/meta/src/scheduler/state-store.ts

export interface SchedulerState {
  lastRunStart?: Date;
  lastRunEnd?: Date;
  status: 'idle' | 'running' | 'completed' | 'failed';
  lastResult?: ImprovementCycleResult;
  lastError?: string;
  pendingRetry?: Date;
}

export class SchedulerStateStore {
  private readonly stateFile: string;

  constructor(dataDir: string) {
    this.stateFile = path.join(dataDir, 'scheduler-state.json');
  }

  async save(state: Partial<SchedulerState>): Promise<void> {
    const current = await this.load();
    const updated = { ...current, ...state };
    await fs.writeFile(this.stateFile, JSON.stringify(updated, null, 2));
  }

  async load(): Promise<SchedulerState> {
    try {
      const content = await fs.readFile(this.stateFile, 'utf-8');
      return JSON.parse(content);
    } catch {
      return { status: 'idle' };
    }
  }

  getTodayChanges(): number {
    // Count changes from today's evolution log
    return this.countChangesSince(startOfDay(new Date()));
  }

  getWeekChanges(): number {
    // Count changes from this week
    return this.countChangesSince(startOfWeek(new Date()));
  }

  private countChangesSince(date: Date): number {
    // Implementation reads evolution log
  }
}
```

---

## Business Value

O Scheduler permite que o sistema de auto-melhoria funcione de forma **autônoma e segura**, garantindo que melhorias sejam aplicadas de forma controlada sem impacto nas operações.

**Benefícios:**
- Automação completa do ciclo de melhorias
- Respeito a janelas de manutenção
- Rate limiting automático
- Persistência de estado para recuperação
- Logs de execução para auditoria

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Scheduler falha e não recupera | Low | High | Persistência de estado + restart automático |
| Execução durante pico de uso | Medium | Medium | Maintenance windows |
| Rate limit bypassado | Low | Critical | Verificação dupla + logs |

---

## Scope

### In Scope
- AutoImprovementScheduler class
- Maintenance window support
- Rate limit enforcement
- State persistence
- Graceful shutdown

### Out of Scope
- Distributed scheduling
- Real-time monitoring UI
- Manual override interface

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-036 (Auto-Improvement Engine) | Package | Ready |
| CL2-041 (Evolution Log) | Package | Pending |

---

## Dev Notes

### Default Configuration

```yaml
auto_improvement_scheduler:
  enabled: true
  interval: 6h
  maintenance_window:
    start: "22:00"
    end: "06:00"
    timezone: "America/Sao_Paulo"
  rate_limits:
    max_changes_per_day: 5
    max_changes_per_week: 20
    cooldown_between_changes: 4h
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/scheduler/improvement-scheduler.ts` | Create | Pending |
| `packages/meta/src/scheduler/state-store.ts` | Create | Pending |
| `packages/meta/src/scheduler/types.ts` | Create | Pending |
| `packages/meta/src/scheduler/index.ts` | Create | Pending |
| `packages/meta/src/scheduler/__tests__/scheduler.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Scheduler starts and stops correctly
- [ ] Cycles run on schedule
- [ ] Maintenance windows respected
- [ ] Rate limits enforced
- [ ] State persisted and recovered
- [ ] Graceful shutdown works
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Scheduler executes on schedule
- [ ] Maintenance window respected
- [ ] Rate limits enforced
- [ ] State recovery works
- [ ] Graceful shutdown tested

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
