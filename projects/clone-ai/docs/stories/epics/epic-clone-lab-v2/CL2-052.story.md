# Story CL2-052: Handoff Protocol

**Story ID:** CL2-052
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 4 - Integration
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar protocolo de handoff para transferir contexto e estado entre fases do pipeline e entre sessoes. O protocolo garante continuidade quando o pipeline e pausado, retomado ou executado em partes.

### Problem Statement
Pipelines longos podem precisar ser pausados e retomados, ou transferidos entre processos. Um protocolo de handoff garante que estado e contexto sejam preservados.

---

## Acceptance Criteria

```gherkin
Given a pipeline is paused mid-execution
When handoff is triggered
Then current state is serialized and saved

Given a handoff package exists
When pipeline resumes
Then state is restored and execution continues

Given a handoff is created
When validated
Then all required context is present and intact

Given handoff transfer occurs
When integrity is verified
Then checksums match and data is valid
```

---

## Technical Requirements

### Handoff Types

```typescript
// packages/handoff/src/types.ts

export interface HandoffPackage {
  id: string;
  sessionId: string;
  cloneId: string;
  createdAt: Date;
  sourcePhase: PipelinePhase;
  targetPhase: PipelinePhase;
  context: SerializedContext;
  checkpoint: PhaseCheckpoint;
  metadata: HandoffMetadata;
  integrity: IntegrityCheck;
}

export interface SerializedContext {
  entries: ContextEntrySerialized[];
  size: number;
  checksum: string;
}

export interface ContextEntrySerialized {
  key: string;
  value: string;              // JSON serialized
  metadata: ContextMetadata;
}

export interface PhaseCheckpoint {
  phase: PipelinePhase;
  step: number;
  totalSteps: number;
  status: 'paused' | 'completed' | 'error';
  resumePoint: string;
}

export interface HandoffMetadata {
  version: string;
  pipelineVersion: string;
  createdBy: string;
  reason: string;
  expiresAt?: Date;
}

export interface IntegrityCheck {
  algorithm: 'sha256';
  checksum: string;
  verifiedAt?: Date;
  valid?: boolean;
}

export type PipelinePhase =
  | 'extraction'
  | 'analysis'
  | 'synthesis'
  | 'validation'
  | 'checkpoint'
  | 'generation'
  | 'finalization';
```

### Handoff Manager

```typescript
// packages/handoff/src/handoff-manager.ts

export class HandoffManager {
  constructor(
    private readonly contextManager: ContextManager,
    private readonly storage: HandoffStorage
  ) {}

  async createHandoff(
    sessionId: string,
    options: CreateHandoffOptions
  ): Promise<HandoffPackage> {
    const context = this.contextManager.getContext(sessionId);
    if (!context) {
      throw new Error(`Context not found for session ${sessionId}`);
    }

    // Serialize context
    const serializedContext = await this.serializeContext(context);

    // Create checkpoint
    const checkpoint = await this.createCheckpoint(options);

    // Calculate integrity
    const integrity = this.calculateIntegrity(serializedContext);

    const handoff: HandoffPackage = {
      id: generateId(),
      sessionId,
      cloneId: options.cloneId,
      createdAt: new Date(),
      sourcePhase: options.sourcePhase,
      targetPhase: options.targetPhase,
      context: serializedContext,
      checkpoint,
      metadata: {
        version: '1.0',
        pipelineVersion: getPipelineVersion(),
        createdBy: options.createdBy || 'system',
        reason: options.reason || 'manual',
        expiresAt: options.expiresAt
      },
      integrity
    };

    // Save to storage
    await this.storage.save(handoff);

    return handoff;
  }

  async receiveHandoff(handoffId: string): Promise<HandoffReceiveResult> {
    // Load handoff package
    const handoff = await this.storage.load(handoffId);
    if (!handoff) {
      return { success: false, error: 'Handoff package not found' };
    }

    // Verify integrity
    const verified = await this.verifyIntegrity(handoff);
    if (!verified) {
      return { success: false, error: 'Integrity check failed' };
    }

    // Check expiration
    if (handoff.metadata.expiresAt && new Date() > handoff.metadata.expiresAt) {
      return { success: false, error: 'Handoff package expired' };
    }

    // Restore context
    const context = this.contextManager.createContext(handoff.sessionId);
    await this.restoreContext(context, handoff.context);

    return {
      success: true,
      handoff,
      resumePoint: handoff.checkpoint.resumePoint
    };
  }

  private async serializeContext(context: SharedContext): Promise<SerializedContext> {
    const entries = await context.findByPattern('*');
    const serialized: ContextEntrySerialized[] = [];

    for (const entry of entries) {
      serialized.push({
        key: entry.key,
        value: JSON.stringify(entry.value),
        metadata: entry.metadata
      });
    }

    const size = JSON.stringify(serialized).length;
    const checksum = this.calculateChecksum(JSON.stringify(serialized));

    return { entries: serialized, size, checksum };
  }

  private async restoreContext(
    context: SharedContext,
    serialized: SerializedContext
  ): Promise<void> {
    for (const entry of serialized.entries) {
      await context.set(entry.key, JSON.parse(entry.value), {
        source: entry.metadata.source,
        tags: entry.metadata.tags
      });
    }
  }

  private calculateIntegrity(context: SerializedContext): IntegrityCheck {
    const checksum = this.calculateChecksum(JSON.stringify(context));
    return {
      algorithm: 'sha256',
      checksum
    };
  }

  private async verifyIntegrity(handoff: HandoffPackage): Promise<boolean> {
    const checksum = this.calculateChecksum(JSON.stringify(handoff.context));
    return checksum === handoff.integrity.checksum;
  }

  private calculateChecksum(data: string): string {
    return crypto.createHash('sha256').update(data).digest('hex');
  }
}
```

### Handoff Storage

```typescript
// packages/handoff/src/storage.ts

export interface HandoffStorage {
  save(handoff: HandoffPackage): Promise<void>;
  load(id: string): Promise<HandoffPackage | null>;
  list(filter?: HandoffFilter): Promise<HandoffPackage[]>;
  delete(id: string): Promise<boolean>;
}

export interface HandoffFilter {
  sessionId?: string;
  cloneId?: string;
  status?: 'active' | 'expired';
  createdAfter?: Date;
}

export class FileHandoffStorage implements HandoffStorage {
  constructor(private readonly basePath: string) {}

  async save(handoff: HandoffPackage): Promise<void> {
    const path = this.getHandoffPath(handoff.id);
    await fs.ensureDir(this.basePath);
    await fs.writeJson(path, handoff, { spaces: 2 });
  }

  async load(id: string): Promise<HandoffPackage | null> {
    const path = this.getHandoffPath(id);
    if (!(await fs.pathExists(path))) {
      return null;
    }
    return fs.readJson(path);
  }

  async list(filter?: HandoffFilter): Promise<HandoffPackage[]> {
    const files = await fs.readdir(this.basePath);
    const handoffs: HandoffPackage[] = [];

    for (const file of files) {
      if (!file.endsWith('.json')) continue;

      const handoff = await fs.readJson(path.join(this.basePath, file));

      if (this.matchesFilter(handoff, filter)) {
        handoffs.push(handoff);
      }
    }

    return handoffs;
  }

  async delete(id: string): Promise<boolean> {
    const path = this.getHandoffPath(id);
    if (await fs.pathExists(path)) {
      await fs.remove(path);
      return true;
    }
    return false;
  }

  private getHandoffPath(id: string): string {
    return path.join(this.basePath, `${id}.json`);
  }

  private matchesFilter(handoff: HandoffPackage, filter?: HandoffFilter): boolean {
    if (!filter) return true;

    if (filter.sessionId && handoff.sessionId !== filter.sessionId) return false;
    if (filter.cloneId && handoff.cloneId !== filter.cloneId) return false;
    if (filter.createdAfter && handoff.createdAt < filter.createdAfter) return false;

    if (filter.status === 'active' && handoff.metadata.expiresAt) {
      if (new Date() > handoff.metadata.expiresAt) return false;
    }
    if (filter.status === 'expired' && handoff.metadata.expiresAt) {
      if (new Date() <= handoff.metadata.expiresAt) return false;
    }

    return true;
  }
}
```

### Pipeline Integration

```typescript
// packages/handoff/src/pipeline-integration.ts

export class HandoffPipelineWrapper {
  constructor(
    private readonly pipeline: ClonePipeline,
    private readonly handoffManager: HandoffManager
  ) {}

  async pause(sessionId: string, reason?: string): Promise<HandoffPackage> {
    const status = await this.pipeline.getStatus(sessionId);
    if (status.state !== 'running') {
      throw new Error('Pipeline is not running');
    }

    // Pause the pipeline
    await this.pipeline.pause(sessionId);

    // Create handoff
    return this.handoffManager.createHandoff(sessionId, {
      cloneId: status.cloneId,
      sourcePhase: status.currentPhase,
      targetPhase: status.currentPhase,
      reason: reason || 'user-requested'
    });
  }

  async resume(handoffId: string): Promise<PipelineResult> {
    const result = await this.handoffManager.receiveHandoff(handoffId);

    if (!result.success) {
      throw new Error(`Failed to receive handoff: ${result.error}`);
    }

    // Resume pipeline from checkpoint
    return this.pipeline.resume(
      result.handoff.sessionId,
      result.resumePoint
    );
  }

  async transfer(
    sessionId: string,
    targetProcess: string
  ): Promise<TransferResult> {
    // Create handoff
    const handoff = await this.pause(sessionId, 'transfer');

    // Transfer to target process (e.g., via message queue)
    await this.sendToTarget(targetProcess, handoff);

    return {
      handoffId: handoff.id,
      targetProcess,
      transferredAt: new Date()
    };
  }
}
```

---

## Business Value

O protocolo de handoff garante continuidade de execucao, permitindo pausar, retomar e transferir pipelines sem perder estado.

**Beneficios:**
- Pausar e retomar pipelines longos
- Transferir entre processos/servidores
- Recuperacao de falhas
- Integridade verificada
- Suporte a execucao distribuida

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Handoff muito grande | Medium | Low | Compressao + filtros |
| Integridade falha | Low | High | Checksum + validacao |
| Expiracao precoce | Low | Medium | TTL configuravel |
| Conflito ao restaurar | Low | Medium | Merge strategy |

---

## Scope

### In Scope
- HandoffPackage structure
- HandoffManager for create/receive
- FileHandoffStorage
- Pipeline integration
- Integrity verification
- Expiration handling

### Out of Scope
- Remote storage (S3, etc.)
- Encryption
- Compression

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-051 (Shared Context) | Package | Pending |
| Clone Pipeline v1.0 | Package | Available |
| fs-extra | Runtime | Available |

---

## Dev Notes

### Handoff File Location

```
.handoffs/
├── hof-abc123.json
├── hof-def456.json
└── ...
```

### Handoff Flow

```
1. Pipeline running
2. Pause requested
3. Create checkpoint
4. Serialize context
5. Calculate integrity
6. Save handoff package
7. Pipeline paused

... time passes ...

1. Resume requested
2. Load handoff package
3. Verify integrity
4. Check expiration
5. Restore context
6. Resume from checkpoint
7. Pipeline running
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/handoff/src/types.ts` | Create | Pending |
| `packages/handoff/src/handoff-manager.ts` | Create | Pending |
| `packages/handoff/src/storage.ts` | Create | Pending |
| `packages/handoff/src/pipeline-integration.ts` | Create | Pending |
| `packages/handoff/src/index.ts` | Create | Pending |
| `packages/handoff/src/__tests__/handoff.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] HandoffManager creates packages
- [ ] HandoffManager receives packages
- [ ] Context serialization works
- [ ] Context restoration works
- [ ] Integrity verification passes
- [ ] Expiration handled correctly
- [ ] Pipeline integration functional
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Create handoff works
- [ ] Receive handoff works
- [ ] Integrity verified
- [ ] Expiration enforced
- [ ] Context fully restored
- [ ] Pipeline resumes correctly

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
