# Story CL2-036: Auto-Improvement Engine

**Story ID:** CL2-036
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 8
**Author:** Morgan (PM)

---

## Description

Implementar o **Auto-Improvement Engine** - o coração da capacidade de auto-evolução do Clone Lab. Este componente avalia o sistema, identifica melhorias, e as aplica (automaticamente ou com aprovação humana, dependendo da constitution).

### Problem Statement
O Clone Lab precisa ser capaz de melhorar a si mesmo sem intervenção manual constante. O Auto-Improvement Engine analisa métricas, identifica oportunidades de melhoria, e as aplica de forma segura.

---

## Acceptance Criteria

```gherkin
Given the system has been running for some time
When auto-improvement analysis is triggered
Then improvement opportunities are identified with impact assessment

Given an improvement is auto-applicable
When the engine decides to apply it
Then the change is applied and logged

Given an improvement requires human approval
When the engine identifies it
Then it is queued for human review without being applied

Given a change was applied
When impact measurement period completes
Then the system evaluates if change was positive or negative

Given a change had negative impact
When rollback is triggered
Then the system reverts to previous state
```

---

## Technical Requirements

### Auto-Improvement Engine

```typescript
// packages/meta/src/auto-improve/improvement-engine.ts

export interface ImprovementCandidate {
  id: string;
  category: 'add' | 'remove' | 'modify' | 'optimize';
  target: string;                    // What to change
  reason: string;                    // Why change is needed
  impact: 'low' | 'medium' | 'high';
  autoApplicable: boolean;           // Can be auto-applied?
  requiresApproval: boolean;         // Needs human approval?
  riskLevel: number;                 // 0-100
  predictedBenefit: number;          // 0-100
  rollbackPossible: boolean;
}

export interface AppliedImprovement {
  id: string;
  improvement: ImprovementCandidate;
  appliedAt: Date;
  appliedBy: 'auto' | 'human';
  beforeState: any;
  afterState: any;
  impactMeasurement: ImpactMeasurement | null;
  rolledBack: boolean;
}

export class AutoImprovementEngine {
  constructor(
    private readonly assessor: SelfAssessor,
    private readonly constitution: ConstitutionEnforcer,
    private readonly changeApplier: ChangeApplier,
    private readonly rollbackManager: RollbackManager
  ) {}

  async runImprovementCycle(): Promise<ImprovementCycleResult> {
    // 1. Self-assessment
    const assessment = await this.assessor.assess();

    // 2. Identify improvement opportunities
    const candidates = await this.identifyImprovements(assessment);

    // 3. Filter by constitution rules
    const { autoApply, needsApproval, rejected } = this.constitution.filter(candidates);

    // 4. Auto-apply safe improvements
    const autoApplied = await this.autoApplyImprovements(autoApply);

    // 5. Queue others for human review
    await this.queueForReview(needsApproval);

    return {
      assessment,
      candidates: candidates.length,
      autoApplied: autoApplied.length,
      queuedForReview: needsApproval.length,
      rejected: rejected.length
    };
  }

  private async identifyImprovements(
    assessment: SelfAssessmentResult
  ): Promise<ImprovementCandidate[]> {
    const candidates: ImprovementCandidate[] = [];

    // Check for unused validation tasks
    const unusedTasks = this.findUnusedTasks(assessment.metrics);
    for (const task of unusedTasks) {
      candidates.push({
        id: `remove-unused-task-${task}`,
        category: 'remove',
        target: `validation/tasks/${task}`,
        reason: `Task ${task} has not triggered in 30+ days`,
        impact: 'low',
        autoApplicable: true,
        requiresApproval: false,
        riskLevel: 10,
        predictedBenefit: 15,
        rollbackPossible: true
      });
    }

    // Check for bottleneck patterns
    const bottlenecks = assessment.metrics.processBottlenecks;
    for (const bottleneck of bottlenecks) {
      candidates.push({
        id: `optimize-bottleneck-${bottleneck}`,
        category: 'optimize',
        target: bottleneck,
        reason: `Identified as performance bottleneck`,
        impact: 'medium',
        autoApplicable: false,
        requiresApproval: true,
        riskLevel: 40,
        predictedBenefit: 60,
        rollbackPossible: true
      });
    }

    // Check for fidelity correlations
    const correlations = this.analyzeFidelityCorrelations(assessment);
    for (const correlation of correlations) {
      if (correlation.impact > 0.3) {
        candidates.push({
          id: `optimize-mind-prompt-${correlation.mind}`,
          category: 'modify',
          target: `minds/${correlation.mind}/prompts`,
          reason: `Prompt optimization correlates with higher fidelity`,
          impact: 'high',
          autoApplicable: true,
          requiresApproval: false,
          riskLevel: 25,
          predictedBenefit: Math.round(correlation.impact * 100),
          rollbackPossible: true
        });
      }
    }

    return candidates;
  }

  private async autoApplyImprovements(
    candidates: ImprovementCandidate[]
  ): Promise<AppliedImprovement[]> {
    const applied: AppliedImprovement[] = [];

    // Rate limiting: max 5 auto-changes per day
    const todayApplied = await this.countTodayAutoApplied();
    const remaining = 5 - todayApplied;

    for (const candidate of candidates.slice(0, remaining)) {
      try {
        const result = await this.changeApplier.apply(candidate);
        applied.push(result);

        // Schedule impact measurement
        await this.scheduleImpactMeasurement(result);
      } catch (error) {
        console.error(`Failed to apply ${candidate.id}:`, error);
      }
    }

    return applied;
  }
}
```

### Change Applier

```typescript
// packages/meta/src/auto-improve/change-applier.ts

export class ChangeApplier {
  constructor(
    private readonly fileSystem: FileSystem,
    private readonly evolutionLog: EvolutionLog
  ) {}

  async apply(improvement: ImprovementCandidate): Promise<AppliedImprovement> {
    // 1. Capture before state
    const beforeState = await this.captureState(improvement.target);

    // 2. Create restore point
    await this.createRestorePoint(improvement);

    // 3. Apply change
    await this.applyChange(improvement);

    // 4. Capture after state
    const afterState = await this.captureState(improvement.target);

    // 5. Log the change
    const applied: AppliedImprovement = {
      id: generateId(),
      improvement,
      appliedAt: new Date(),
      appliedBy: improvement.autoApplicable ? 'auto' : 'human',
      beforeState,
      afterState,
      impactMeasurement: null,
      rolledBack: false
    };

    await this.evolutionLog.log(applied);

    return applied;
  }

  private async applyChange(improvement: ImprovementCandidate): Promise<void> {
    switch (improvement.category) {
      case 'remove':
        await this.fileSystem.remove(improvement.target);
        break;
      case 'add':
        await this.fileSystem.create(improvement.target, improvement.content);
        break;
      case 'modify':
        await this.fileSystem.modify(improvement.target, improvement.patch);
        break;
      case 'optimize':
        await this.applyOptimization(improvement);
        break;
    }
  }
}
```

### Constitution Enforcer

```typescript
// packages/meta/src/constitution/enforcer.ts

export class ConstitutionEnforcer {
  private readonly rules: ConstitutionRule[];

  constructor(rules: ConstitutionRule[]) {
    this.rules = rules;
  }

  filter(candidates: ImprovementCandidate[]): FilteredCandidates {
    const autoApply: ImprovementCandidate[] = [];
    const needsApproval: ImprovementCandidate[] = [];
    const rejected: ImprovementCandidate[] = [];

    for (const candidate of candidates) {
      // Check against each rule
      const verdict = this.evaluateRules(candidate);

      if (verdict === 'reject') {
        rejected.push(candidate);
      } else if (verdict === 'approve-auto') {
        autoApply.push(candidate);
      } else {
        needsApproval.push(candidate);
      }
    }

    return { autoApply, needsApproval, rejected };
  }

  private evaluateRules(candidate: ImprovementCandidate): RuleVerdict {
    // Rule 1: Forbidden modifications
    if (this.isForbidden(candidate)) {
      return 'reject';
    }

    // Rule 2: Auto-applicable (from constitution)
    if (this.isAutoApplicable(candidate)) {
      return 'approve-auto';
    }

    // Rule 3: Requires approval
    if (this.requiresApproval(candidate)) {
      return 'needs-approval';
    }

    // Default: needs approval for safety
    return 'needs-approval';
  }

  private isForbidden(candidate: ImprovementCandidate): boolean {
    const forbidden = [
      /checkpoints\/all/,
      /constitution\/rules/,
      /audit-trail/,
      /clone-data/
    ];

    return forbidden.some(pattern => pattern.test(candidate.target));
  }

  private isAutoApplicable(candidate: ImprovementCandidate): boolean {
    const autoPatterns = [
      /validation\/tasks\/EX-\d+/,     // Task removal
      /minds\/.*\/prompts/,            // Prompt optimization
      /checkpoints\/.*\/threshold/     // Threshold adjustment
    ];

    return autoPatterns.some(pattern =>
      pattern.test(candidate.target) &&
      candidate.riskLevel < 30
    );
  }
}
```

---

## Business Value

O Auto-Improvement Engine é o **coração da auto-evolução** do Clone Lab. Permite que o sistema melhore a si mesmo sem intervenção manual constante, alinhando com a filosofia AIOS.

**Benefícios:**
- Sistema aprende com própria execução
- Reduz necessidade de intervenção manual
- Identifica e corrige gargalos automaticamente
- Aumenta qualidade dos clones ao longo do tempo
- Diferencial competitivo: sistema que melhora sozinho

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Mudança automática causa regressão | Medium | Critical | Rollback obrigatório + rate limiting |
| Constitution bypassado por bug | Low | Critical | Logs de auditoria + alertas |
| Loop infinito de melhorias | Low | High | Max 5 mudanças/dia + cooldown |
| Falso positivo em identificação | Medium | Medium | Confidence thresholds + human approval |

---

## Scope

### In Scope
- AutoImprovementEngine class
- Improvement identification algorithms
- ChangeApplier for safe modifications
- ConstitutionEnforcer integration
- Rate limiting (5 changes/day)
- Impact measurement scheduling
- Evolution log integration

### Out of Scope
- Dashboard UI
- Distributed improvement
- ML-based improvement suggestions

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-030 (Self-Assessment) | Package | Pending |
| CL2-034 (Constitution Rules) | Package | Pending |
| CL2-037 (Change Applier) | Package | Pending |
| CL2-038 (Rollback Manager) | Package | Pending |
| CL2-041 (Evolution Log) | Package | Pending |

---

## Dev Notes

### Improvement Categories

| Category | Examples | Auto-Applicable |
|----------|----------|-----------------|
| **Remove** | Unused tasks, deprecated code | Yes (low risk) |
| **Add** | New validation patterns | No |
| **Modify** | Prompt tweaks, thresholds | Yes (low risk) |
| **Optimize** | Performance improvements | Sometimes |

### Rate Limiting Strategy

```yaml
auto_improvement:
  max_per_day: 5
  cooldown_hours: 4
  require_review_after: 3  # After 3 consecutive auto-changes
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/auto-improve/improvement-engine.ts` | Create | Pending |
| `packages/meta/src/auto-improve/change-applier.ts` | Create | Pending |
| `packages/meta/src/auto-improve/types.ts` | Create | Pending |
| `packages/meta/src/auto-improve/index.ts` | Create | Pending |
| `packages/meta/src/auto-improve/__tests__/improvement-engine.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Identifies improvement opportunities correctly
- [ ] Filters by constitution rules
- [ ] Auto-applies safe improvements
- [ ] Queues risky improvements for review
- [ ] Rate limiting works (max 5/day)
- [ ] Changes are logged to evolution log
- [ ] Rollback is possible for all changes
- [ ] Impact measurement is scheduled
- [ ] Constitution rules não podem ser bypassadas
- [ ] Teste de rollback executado com sucesso
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Identifies improvement opportunities correctly
- [ ] Filters by constitution rules
- [ ] Auto-applies safe improvements
- [ ] Queues risky improvements for review
- [ ] Rate limiting works (max 5/day)
- [ ] Changes are logged to evolution log
- [ ] Rollback is possible for all changes
- [ ] Impact measurement is scheduled

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
