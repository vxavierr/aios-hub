# Story CL2-051: Shared Context System

**Story ID:** CL2-051
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 4 - Integration
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar sistema de contexto compartilhado que permite que componentes do pipeline compartilhem estado e dados de forma eficiente. O sistema deve suportar caching, invalidacao e acesso concorrente.

### Problem Statement
Os diversos componentes do Clone Lab (Minds, Validations, Checkpoints) precisam compartilhar contexto durante a execucao do pipeline. Um sistema centralizado melhora eficiencia e consistencia.

---

## Acceptance Criteria

```gherkin
Given a pipeline session is active
When a component stores data in shared context
Then other components can retrieve it within the same session

Given data is stored with a TTL
When TTL expires
Then the data is automatically invalidated

Given multiple components access shared context concurrently
When race conditions occur
Then data integrity is maintained

Given a component updates shared data
When other components are listening
Then they are notified of the change
```

---

## Technical Requirements

### Shared Context Types

```typescript
// packages/context/src/types.ts

export interface ContextEntry<T = any> {
  key: string;
  value: T;
  createdAt: Date;
  updatedAt: Date;
  ttl?: number;                    // ms until expiration
  expiresAt?: Date;
  metadata: ContextMetadata;
}

export interface ContextMetadata {
  source: string;                  // Component that created the entry
  version: number;
  tags: string[];
}

export interface ContextSubscription {
  id: string;
  pattern: string;                 // Glob pattern to match keys
  callback: (entry: ContextEntry, action: 'set' | 'delete') => void;
}

export interface SharedContextOptions {
  sessionId: string;
  defaultTTL?: number;
  maxEntries?: number;
  enableNotifications?: boolean;
}
```

### Shared Context Implementation

```typescript
// packages/context/src/shared-context.ts

export class SharedContext {
  private store: Map<string, ContextEntry> = new Map();
  private subscriptions: ContextSubscription[] = [];
  private cleanupInterval?: NodeJS.Timeout;

  constructor(private readonly options: SharedContextOptions) {
    if (options.maxEntries) {
      this.startCleanup();
    }
  }

  // Core operations
  async get<T>(key: string): Promise<T | undefined> {
    const entry = this.store.get(key);

    if (!entry) {
      return undefined;
    }

    // Check expiration
    if (this.isExpired(entry)) {
      await this.delete(key);
      return undefined;
    }

    return entry.value;
  }

  async set<T>(
    key: string,
    value: T,
    options: { ttl?: number; source?: string; tags?: string[] } = {}
  ): Promise<void> {
    const now = new Date();
    const ttl = options.ttl ?? this.options.defaultTTL;

    const entry: ContextEntry<T> = {
      key,
      value,
      createdAt: this.store.has(key)
        ? this.store.get(key)!.createdAt
        : now,
      updatedAt: now,
      ttl,
      expiresAt: ttl ? new Date(now.getTime() + ttl) : undefined,
      metadata: {
        source: options.source || 'unknown',
        version: this.store.has(key)
          ? this.store.get(key)!.metadata.version + 1
          : 1,
        tags: options.tags || []
      }
    };

    this.store.set(key, entry);
    this.notifySubscribers(key, entry, 'set');
  }

  async delete(key: string): Promise<boolean> {
    const entry = this.store.get(key);
    if (!entry) {
      return false;
    }

    const deleted = this.store.delete(key);
    if (deleted) {
      this.notifySubscribers(key, entry, 'delete');
    }

    return deleted;
  }

  async has(key: string): Promise<boolean> {
    const entry = this.store.get(key);
    if (!entry) {
      return false;
    }

    if (this.isExpired(entry)) {
      await this.delete(key);
      return false;
    }

    return true;
  }

  // Bulk operations
  async getMultiple(keys: string[]): Promise<Record<string, any>> {
    const result: Record<string, any> = {};
    for (const key of keys) {
      const value = await this.get(key);
      if (value !== undefined) {
        result[key] = value;
      }
    }
    return result;
  }

  async setMultiple(
    entries: Record<string, any>,
    options?: { ttl?: number; source?: string }
  ): Promise<void> {
    for (const [key, value] of Object.entries(entries)) {
      await this.set(key, value, options);
    }
  }

  // Query operations
  async findByPattern(pattern: string): Promise<ContextEntry[]> {
    const regex = this.patternToRegex(pattern);
    const results: ContextEntry[] = [];

    for (const entry of this.store.values()) {
      if (regex.test(entry.key) && !this.isExpired(entry)) {
        results.push(entry);
      }
    }

    return results;
  }

  async findByTag(tag: string): Promise<ContextEntry[]> {
    const results: ContextEntry[] = [];

    for (const entry of this.store.values()) {
      if (entry.metadata.tags.includes(tag) && !this.isExpired(entry)) {
        results.push(entry);
      }
    }

    return results;
  }

  // Subscriptions
  subscribe(
    pattern: string,
    callback: ContextSubscription['callback']
  ): string {
    const subscription: ContextSubscription = {
      id: generateId(),
      pattern,
      callback
    };

    this.subscriptions.push(subscription);
    return subscription.id;
  }

  unsubscribe(subscriptionId: string): boolean {
    const index = this.subscriptions.findIndex(s => s.id === subscriptionId);
    if (index !== -1) {
      this.subscriptions.splice(index, 1);
      return true;
    }
    return false;
  }

  // Lifecycle
  clear(): void {
    this.store.clear();
  }

  destroy(): void {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    this.store.clear();
    this.subscriptions = [];
  }

  // Private methods
  private isExpired(entry: ContextEntry): boolean {
    if (!entry.expiresAt) {
      return false;
    }
    return new Date() > entry.expiresAt;
  }

  private notifySubscribers(
    key: string,
    entry: ContextEntry,
    action: 'set' | 'delete'
  ): void {
    if (!this.options.enableNotifications) {
      return;
    }

    for (const sub of this.subscriptions) {
      const regex = this.patternToRegex(sub.pattern);
      if (regex.test(key)) {
        try {
          sub.callback(entry, action);
        } catch (error) {
          console.error(`Subscription callback error:`, error);
        }
      }
    }
  }

  private patternToRegex(pattern: string): RegExp {
    const regexStr = pattern
      .replace(/\*/g, '.*')
      .replace(/\?/g, '.');
    return new RegExp(`^${regexStr}$`);
  }

  private startCleanup(): void {
    this.cleanupInterval = setInterval(() => {
      this.cleanupExpired();
    }, 60000); // Clean every minute
  }

  private cleanupExpired(): void {
    for (const [key, entry] of this.store.entries()) {
      if (this.isExpired(entry)) {
        this.store.delete(key);
      }
    }

    // Enforce max entries
    if (this.options.maxEntries && this.store.size > this.options.maxEntries) {
      const entries = Array.from(this.store.entries());
      entries.sort((a, b) => a[1].updatedAt.getTime() - b[1].updatedAt.getTime());

      const toRemove = entries.slice(0, this.store.size - this.options.maxEntries);
      for (const [key] of toRemove) {
        this.store.delete(key);
      }
    }
  }
}
```

### Context Manager

```typescript
// packages/context/src/context-manager.ts

export class ContextManager {
  private contexts: Map<string, SharedContext> = new Map();

  createContext(sessionId: string, options?: Partial<SharedContextOptions>): SharedContext {
    const context = new SharedContext({
      sessionId,
      defaultTTL: 3600000, // 1 hour
      maxEntries: 10000,
      enableNotifications: true,
      ...options
    });

    this.contexts.set(sessionId, context);
    return context;
  }

  getContext(sessionId: string): SharedContext | undefined {
    return this.contexts.get(sessionId);
  }

  getOrCreate(sessionId: string): SharedContext {
    let context = this.contexts.get(sessionId);
    if (!context) {
      context = this.createContext(sessionId);
    }
    return context;
  }

  destroyContext(sessionId: string): boolean {
    const context = this.contexts.get(sessionId);
    if (context) {
      context.destroy();
      this.contexts.delete(sessionId);
      return true;
    }
    return false;
  }

  // Standard keys for Clone Lab
  getStandardKeys(): StandardContextKeys {
    return {
      // Extraction
      EXTRACTED_DATA: 'extraction:data',
      SOURCE_METADATA: 'extraction:metadata',

      // Analysis
      MIND_RESULTS: 'analysis:mind:*',
      ORCHESTRATOR_RESULT: 'analysis:orchestrator',

      // Synthesis
      DNA_PROFILE: 'synthesis:dna',
      SYNTHESIS_RESULT: 'synthesis:result',

      // Validation
      VALIDATION_RESULTS: 'validation:results',
      VALIDATION_SUMMARY: 'validation:summary',

      // Checkpoints
      CHECKPOINT_STATUS: 'checkpoint:*:status',
      CHECKPOINT_DECISION: 'checkpoint:*:decision',

      // Generation
      MANIFEST_CONTENT: 'generation:manifest',

      // Session
      SESSION_INFO: 'session:info',
      PIPELINE_STATUS: 'pipeline:status'
    };
  }
}

export const contextManager = new ContextManager();
```

### Pipeline Context Integration

```typescript
// packages/context/src/pipeline-context.ts

export class PipelineContext {
  private context: SharedContext;

  constructor(sessionId: string) {
    this.context = contextManager.getOrCreate(sessionId);
  }

  // Convenience methods for pipeline phases

  // Extraction phase
  async setExtractedData(data: ExtractedData[]): Promise<void> {
    await this.context.set('extraction:data', data, {
      source: 'extraction',
      tags: ['phase:extraction', 'data']
    });
  }

  async getExtractedData(): Promise<ExtractedData[] | undefined> {
    return this.context.get('extraction:data');
  }

  // Analysis phase
  async setMindResult(mindId: MindId, result: MindResult): Promise<void> {
    await this.context.set(`analysis:mind:${mindId}`, result, {
      source: `mind:${mindId}`,
      tags: ['phase:analysis', 'mind', mindId]
    });
  }

  async getMindResult(mindId: MindId): Promise<MindResult | undefined> {
    return this.context.get(`analysis:mind:${mindId}`);
  }

  async getAllMindResults(): Promise<Record<MindId, MindResult>> {
    const entries = await this.context.findByPattern('analysis:mind:*');
    const results: Record<string, MindResult> = {};

    for (const entry of entries) {
      const mindId = entry.key.split(':')[2] as MindId;
      results[mindId] = entry.value;
    }

    return results as Record<MindId, MindResult>;
  }

  // DNA phase
  async setDNAProfile(dna: DNAProfile): Promise<void> {
    await this.context.set('synthesis:dna', dna, {
      source: 'dna-synthesizer',
      tags: ['phase:synthesis', 'dna']
    });
  }

  async getDNAProfile(): Promise<DNAProfile | undefined> {
    return this.context.get('synthesis:dna');
  }

  // Validation phase
  async addValidationResult(taskId: string, result: TaskResult): Promise<void> {
    await this.context.set(`validation:task:${taskId}`, result, {
      source: 'validation',
      tags: ['phase:validation', taskId]
    });
  }

  async getValidationResults(): Promise<TaskResult[]> {
    const entries = await this.context.findByPattern('validation:task:*');
    return entries.map(e => e.value);
  }

  // Checkpoint phase
  async setCheckpointDecision(
    checkpointId: string,
    decision: CheckpointDecision
  ): Promise<void> {
    await this.context.set(`checkpoint:${checkpointId}:decision`, decision, {
      source: 'checkpoint',
      tags: ['phase:checkpoint', checkpointId]
    });
  }

  // Status tracking
  async setPipelineStatus(status: PipelineStatus): Promise<void> {
    await this.context.set('pipeline:status', status, {
      source: 'pipeline'
    });
  }

  async getPipelineStatus(): Promise<PipelineStatus | undefined> {
    return this.context.get('pipeline:status');
  }
}
```

---

## Business Value

O sistema de contexto compartilhado melhora eficiencia e consistencia do pipeline, eliminando redundancia e facilitando comunicacao entre componentes.

**Beneficios:**
- Dados compartilhados entre componentes
- Cache com TTL automatico
- Notificacoes de mudancas
- API conveniente para pipeline
- Rastreamento de versoes

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Memory leak com muitos dados | Medium | Medium | Max entries + cleanup |
| Race conditions | Low | Medium | Operacoes atomicas |
| Context corrompido | Low | High | Validacao de schema |
| Performance degrada | Low | Low | Indexacao + lazy loading |

---

## Scope

### In Scope
- SharedContext class with core operations
- ContextManager for lifecycle
- PipelineContext convenience wrapper
- TTL and expiration
- Subscriptions/notifications
- Pattern-based queries

### Out of Scope
- Distributed context (Redis, etc.)
- Context persistence
- Context encryption

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| TypeScript 5.x | Runtime | Available |
| Clone Pipeline v1.0 | Package | Available |

---

## Dev Notes

### Context Size Guidelines

```yaml
context_limits:
  max_entries_per_session: 10000
  max_entry_size_kb: 100
  default_ttl_minutes: 60
  cleanup_interval_minutes: 1
```

### Key Naming Convention

```
{phase}:{category}:{id}

Examples:
- extraction:data
- analysis:mind:tim
- validation:task:EX-001
- checkpoint:cp-1:decision
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/context/src/types.ts` | Create | Pending |
| `packages/context/src/shared-context.ts` | Create | Pending |
| `packages/context/src/context-manager.ts` | Create | Pending |
| `packages/context/src/pipeline-context.ts` | Create | Pending |
| `packages/context/src/index.ts` | Create | Pending |
| `packages/context/src/__tests__/shared-context.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] SharedContext implements all operations
- [ ] TTL and expiration work correctly
- [ ] Subscriptions notify listeners
- [ ] ContextManager handles lifecycle
- [ ] PipelineContext integrates with pipeline
- [ ] Pattern queries functional
- [ ] Cleanup prevents memory leaks
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Get/set operations work
- [ ] TTL expiration correct
- [ ] Notifications delivered
- [ ] Pattern matching accurate
- [ ] Cleanup removes expired
- [ ] Max entries enforced
- [ ] Pipeline integration functional

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
