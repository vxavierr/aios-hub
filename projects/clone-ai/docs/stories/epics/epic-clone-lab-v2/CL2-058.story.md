# Story CL2-058: Learning Repository

**Story ID:** CL2-058
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 5 - Self-Evolution
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Learning Repository** - repositório centralizado que armazena padrões aprendidos, correlações descobertas e conhecimento acumulado pelo sistema durante sua operação.

### Problem Statement
O sistema precisa lembrar o que aprendeu ao longo do tempo para tomar decisões melhores. Sem um repositório de aprendizado, cada ciclo de melhoria começa do zero.

---

## Acceptance Criteria

```gherkin
Given a pattern is discovered
When it is validated
Then it is stored in the learning repository

Given the learning repository has patterns
When a new improvement is being considered
Then relevant past learnings are consulted

Given a pattern was wrong
When negative impact is detected
Then the pattern is deprecated or removed

Given multiple patterns exist
When querying the repository
Then patterns are ranked by relevance and confidence
```

---

## Technical Requirements

### Learning Repository

```typescript
// packages/meta/src/learning/repository.ts

export interface LearningPattern {
  id: string;
  type: 'correlation' | 'optimization' | 'avoidance' | 'best_practice';
  category: string;
  pattern: string;
  description: string;
  confidence: number;
  evidence: Evidence[];
  applications: number;
  successes: number;
  failures: number;
  createdAt: Date;
  lastUpdated: Date;
  deprecated: boolean;
  deprecationReason?: string;
}

export interface Evidence {
  improvementId: string;
  outcome: 'positive' | 'negative' | 'neutral';
  impactMeasurement: ImpactAssessment;
  timestamp: Date;
}

export class LearningRepository {
  private readonly storage: LearningStorage;
  private readonly index: PatternIndex;

  constructor(storage: LearningStorage) {
    this.storage = storage;
    this.index = new PatternIndex();
  }

  async store(pattern: Omit<LearningPattern, 'id' | 'createdAt' | 'lastUpdated'>): Promise<string> {
    const newPattern: LearningPattern = {
      ...pattern,
      id: generateId(),
      createdAt: new Date(),
      lastUpdated: new Date(),
      applications: 0,
      successes: 0,
      failures: 0,
      deprecated: false
    };

    await this.storage.save(newPattern);
    await this.index.add(newPattern);

    return newPattern.id;
  }

  async findRelevant(
    query: string,
    options?: SearchOptions
  ): Promise<LearningPattern[]> {
    const results = await this.index.search(query, options);

    return results
      .filter(p => !p.deprecated)
      .sort((a, b) => {
        // Sort by confidence * success rate
        const scoreA = a.confidence * (a.successes / Math.max(1, a.applications));
        const scoreB = b.confidence * (b.successes / Math.max(1, b.applications));
        return scoreB - scoreA;
      });
  }

  async recordApplication(
    patternId: string,
    improvementId: string,
    outcome: 'positive' | 'negative' | 'neutral',
    assessment: ImpactAssessment
  ): Promise<void> {
    const pattern = await this.storage.get(patternId);
    if (!pattern) return;

    // Update statistics
    pattern.applications++;
    if (outcome === 'positive') pattern.successes++;
    if (outcome === 'negative') pattern.failures++;

    // Add evidence
    pattern.evidence.push({
      improvementId,
      outcome,
      impactMeasurement: assessment,
      timestamp: new Date()
    });

    // Update confidence based on outcomes
    pattern.confidence = this.recalculateConfidence(pattern);
    pattern.lastUpdated = new Date();

    // Auto-deprecate if consistently failing
    if (pattern.failures > 5 && pattern.successes / pattern.applications < 0.3) {
      pattern.deprecated = true;
      pattern.deprecationReason = 'Consistently negative outcomes';
    }

    await this.storage.save(pattern);
    await this.index.update(pattern);
  }

  async deprecate(patternId: string, reason: string): Promise<void> {
    const pattern = await this.storage.get(patternId);
    if (!pattern) return;

    pattern.deprecated = true;
    pattern.deprecationReason = reason;
    pattern.lastUpdated = new Date();

    await this.storage.save(pattern);
    await this.index.update(pattern);
  }

  async getPatternsByCategory(category: string): Promise<LearningPattern[]> {
    return this.storage.getByCategory(category);
  }

  async getTopPatterns(limit: number = 10): Promise<LearningPattern[]> {
    const all = await this.storage.getAll();
    return all
      .filter(p => !p.deprecated && p.applications >= 3)
      .sort((a, b) => {
        const scoreA = a.confidence * (a.successes / a.applications);
        const scoreB = b.confidence * (b.successes / b.applications);
        return scoreB - scoreA;
      })
      .slice(0, limit);
  }

  private recalculateConfidence(pattern: LearningPattern): number {
    // Bayesian-inspired confidence update
    const priorWeight = 2; // pseudo-counts for prior
    const priorConfidence = 0.5;
    const observations = pattern.applications;
    const successRate = pattern.successes / Math.max(1, observations);

    return (priorWeight * priorConfidence + observations * successRate) /
           (priorWeight + observations);
  }
}
```

### Pattern Index

```typescript
// packages/meta/src/learning/pattern-index.ts

export class PatternIndex {
  private patterns: Map<string, LearningPattern>;
  private categoryIndex: Map<string, Set<string>>;
  private keywordIndex: Map<string, Set<string>>;

  constructor() {
    this.patterns = new Map();
    this.categoryIndex = new Map();
    this.keywordIndex = new Map();
  }

  add(pattern: LearningPattern): void {
    this.patterns.set(pattern.id, pattern);
    this.indexByCategory(pattern);
    this.indexByKeywords(pattern);
  }

  update(pattern: LearningPattern): void {
    this.patterns.set(pattern.id, pattern);
    // Re-index in case of changes
    this.indexByCategory(pattern);
  }

  search(query: string, options?: SearchOptions): LearningPattern[] {
    const keywords = this.extractKeywords(query);
    const patternIds = new Set<string>();

    // Find patterns matching any keyword
    for (const keyword of keywords) {
      const matches = this.keywordIndex.get(keyword);
      if (matches) {
        matches.forEach(id => patternIds.add(id));
      }
    }

    // Convert to patterns
    let results = Array.from(patternIds)
      .map(id => this.patterns.get(id)!)
      .filter(p => p !== undefined);

    // Apply category filter
    if (options?.category) {
      results = results.filter(p => p.category === options.category);
    }

    // Apply type filter
    if (options?.type) {
      results = results.filter(p => p.type === options.type);
    }

    return results;
  }

  private indexByCategory(pattern: LearningPattern): void {
    if (!this.categoryIndex.has(pattern.category)) {
      this.categoryIndex.set(pattern.category, new Set());
    }
    this.categoryIndex.get(pattern.category)!.add(pattern.id);
  }

  private indexByKeywords(pattern: LearningPattern): void {
    const text = `${pattern.pattern} ${pattern.description}`.toLowerCase();
    const keywords = this.extractKeywords(text);

    for (const keyword of keywords) {
      if (!this.keywordIndex.has(keyword)) {
        this.keywordIndex.set(keyword, new Set());
      }
      this.keywordIndex.get(keyword)!.add(pattern.id);
    }
  }

  private extractKeywords(text: string): string[] {
    return text.toLowerCase()
      .split(/\W+/)
      .filter(w => w.length > 3)
      .filter(w => !STOP_WORDS.includes(w));
  }
}
```

---

## Business Value

O Learning Repository permite que o sistema **acumule conhecimento** ao longo do tempo, tomando decisões cada vez melhores baseadas em evidências passadas.

**Benefícios:**
- Memória institucional do sistema
- Decisões baseadas em evidências
- Evita repetição de erros
- Melhoria contínua acelerada
- Base para recomendações futuras

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Padrões incorretos aprendidos | Medium | High | Validação + deprecation |
| Repository muito grande | Low | Low | Limpeza de padrões antigos |
| Overfitting em padrões | Medium | Medium | Confidence decay + cross-validation |

---

## Scope

### In Scope
- LearningRepository class
- Pattern storage and retrieval
- Keyword-based search
- Confidence recalculation
- Auto-deprecation

### Out of Scope
- ML-based pattern discovery
- Distributed repository
- Pattern visualization

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-039 (Pattern Learner) | Package | Pending |
| CL2-057 (Impact Measurement) | Package | Pending |

---

## Dev Notes

### Pattern Types

```typescript
type PatternType =
  | 'correlation'     // "High Tim confidence correlates with higher fidelity"
  | 'optimization'    // "Reducing EX-005 threshold improves coverage"
  | 'avoidance'       // "Avoid auto-modifying constitution rules"
  | 'best_practice';  // "Always validate after prompt changes"
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/learning/repository.ts` | Create | Pending |
| `packages/meta/src/learning/pattern-index.ts` | Create | Pending |
| `packages/meta/src/learning/types.ts` | Create | Pending |
| `packages/meta/src/learning/index.ts` | Create | Pending |
| `packages/meta/src/learning/__tests__/repository.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Patterns stored correctly
- [ ] Search returns relevant results
- [ ] Confidence updates on applications
- [ ] Auto-deprecation works
- [ ] Integration with pattern learner
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Patterns stored and retrieved
- [ ] Search works correctly
- [ ] Confidence updates
- [ ] Auto-deprecation triggers
- [ ] Evidence recorded

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
