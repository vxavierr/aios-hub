# Story CL2-021: Checkpoint Interface & Manager

**Story ID:** CL2-021
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 2 - Validation
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Criar a interface **ICheckpoint** e o **CheckpointManager** que gerenciam os 6 Human Checkpoints no pipeline, permitindo aprovacao humana em pontos criticos do processo de clonagem.

### Problem Statement
O pipeline de clonagem requer intervencao humana em pontos criticos para garantir qualidade e controle. O sistema de checkpoints permite pausar o pipeline e solicitar aprovacao humana.

---

## Acceptance Criteria

```gherkin
Given a pipeline execution reaching a checkpoint
When the checkpoint is triggered
Then the pipeline pauses and requests human approval

Given a checkpoint with approval
When the CheckpointManager processes it
Then the pipeline resumes execution

Given a checkpoint with rejection
When the CheckpointManager processes it
Then appropriate handling occurs (retry or abort)

Given all 6 checkpoints are implemented
When the CheckpointManager is queried
Then all checkpoints are registered and accessible
```

---

## Technical Requirements

### Checkpoint Interface

```typescript
// packages/validation/src/checkpoints/checkpoint.interface.ts

export type CheckpointId = 'CP-1' | 'CP-2' | 'CP-3' | 'CP-4' | 'CP-5' | 'CP-6';

export type CheckpointStatus = 'pending' | 'waiting_approval' | 'approved' | 'rejected' | 'skipped';

export interface CheckpointDefinition {
  id: CheckpointId;
  name: string;
  description: string;
  triggerPhase: string;          // Pipeline phase that triggers this checkpoint
  requiredApprovals: number;     // How many approvals needed
  autoApproveConditions?: string[]; // Conditions for auto-approval
  timeout: number;               // Max time waiting for approval (ms)
}

export interface CheckpointContext {
  sessionId: string;
  pipelinePhase: string;
  taskResults: Map<TaskId, TaskResult>;
  dna?: PersonalityDNA;
  previousCheckpoints: Map<CheckpointId, CheckpointResult>;
}

export interface CheckpointResult {
  checkpointId: CheckpointId;
  status: CheckpointStatus;
  score: number;                 // 0-100
  summary: string;
  details: CheckpointDetail[];
  approval?: ApprovalInfo;
  recommendations: string[];
  timestamp: Date;
}

export interface CheckpointDetail {
  category: string;
  status: 'pass' | 'warn' | 'fail';
  message: string;
  evidence?: string;
}

export interface ApprovalInfo {
  approvedBy: string;
  approvedAt: Date;
  comments?: string;
  autoApproved: boolean;
}

export interface ICheckpoint {
  readonly definition: CheckpointDefinition;

  // Evaluate checkpoint conditions
  evaluate(context: CheckpointContext): Promise<CheckpointResult>;

  // Can auto-approve?
  canAutoApprove(result: CheckpointResult): boolean;

  // Get required data for human review
  getReviewData(context: CheckpointContext): Promise<Record<string, unknown>>;

  // Validate approval
  validateApproval(approval: ApprovalInfo): boolean;
}
```

### Checkpoint Manager

```typescript
// packages/validation/src/checkpoints/checkpoint-manager.ts

import { ICheckpoint, CheckpointId, CheckpointContext, CheckpointResult, ApprovalInfo } from './checkpoint.interface';

export interface ManagerConfig {
  autoApproveEnabled: boolean;
  timeoutMs: number;
  maxRetries: number;
  notificationHandler?: (checkpoint: CheckpointId, result: CheckpointResult) => void;
}

export class CheckpointManager {
  private checkpoints: Map<CheckpointId, ICheckpoint>;
  private results: Map<string, Map<CheckpointId, CheckpointResult>>;  // sessionId -> checkpoint -> result
  private pendingApprovals: Map<string, CheckpointId>;  // sessionId -> pending checkpoint

  constructor(private config: ManagerConfig = {
    autoApproveEnabled: false,
    timeoutMs: 24 * 60 * 60 * 1000,  // 24 hours
    maxRetries: 3
  }) {
    this.checkpoints = new Map();
    this.results = new Map();
    this.pendingApprovals = new Map();
  }

  // Register a checkpoint
  register(checkpoint: ICheckpoint): void {
    this.checkpoints.set(checkpoint.definition.id, checkpoint);
  }

  // Register all checkpoints
  registerAll(checkpoints: ICheckpoint[]): void {
    checkpoints.forEach(cp => this.register(cp));
  }

  // Get a checkpoint
  get(id: CheckpointId): ICheckpoint | undefined {
    return this.checkpoints.get(id);
  }

  // Get all checkpoints
  getAll(): ICheckpoint[] {
    return Array.from(this.checkpoints.values());
  }

  // Evaluate a checkpoint
  async evaluate(
    checkpointId: CheckpointId,
    context: CheckpointContext
  ): Promise<CheckpointResult> {
    const checkpoint = this.checkpoints.get(checkpointId);
    if (!checkpoint) {
      throw new Error(`Checkpoint not found: ${checkpointId}`);
    }

    const result = await checkpoint.evaluate(context);

    // Store result
    this.storeResult(context.sessionId, result);

    // Check for auto-approval
    if (this.config.autoApproveEnabled && checkpoint.canAutoApprove(result)) {
      const autoApproval: ApprovalInfo = {
        approvedBy: 'system',
        approvedAt: new Date(),
        autoApproved: true,
        comments: 'Auto-approved based on conditions met'
      };
      result.status = 'approved';
      result.approval = autoApproval;
    } else if (result.status === 'pending') {
      result.status = 'waiting_approval';
      this.pendingApprovals.set(context.sessionId, checkpointId);

      // Notify if handler configured
      if (this.config.notificationHandler) {
        this.config.notificationHandler(checkpointId, result);
      }
    }

    return result;
  }

  // Approve a checkpoint
  async approve(
    sessionId: string,
    checkpointId: CheckpointId,
    approval: ApprovalInfo
  ): Promise<CheckpointResult> {
    const checkpoint = this.checkpoints.get(checkpointId);
    if (!checkpoint) {
      throw new Error(`Checkpoint not found: ${checkpointId}`);
    }

    // Validate approval
    if (!checkpoint.validateApproval(approval)) {
      throw new Error('Invalid approval');
    }

    // Get existing result
    const sessionResults = this.results.get(sessionId);
    if (!sessionResults) {
      throw new Error('No checkpoint results found for session');
    }

    const result = sessionResults.get(checkpointId);
    if (!result) {
      throw new Error('Checkpoint not evaluated');
    }

    // Update with approval
    result.status = 'approved';
    result.approval = approval;

    // Remove from pending
    if (this.pendingApprovals.get(sessionId) === checkpointId) {
      this.pendingApprovals.delete(sessionId);
    }

    // Store updated result
    this.storeResult(sessionId, result);

    return result;
  }

  // Reject a checkpoint
  async reject(
    sessionId: string,
    checkpointId: CheckpointId,
    reason: string
  ): Promise<CheckpointResult> {
    const sessionResults = this.results.get(sessionId);
    if (!sessionResults) {
      throw new Error('No checkpoint results found for session');
    }

    const result = sessionResults.get(checkpointId);
    if (!result) {
      throw new Error('Checkpoint not evaluated');
    }

    result.status = 'rejected';
    result.recommendations.push(`Rejection reason: ${reason}`);

    // Remove from pending
    if (this.pendingApprovals.get(sessionId) === checkpointId) {
      this.pendingApprovals.delete(sessionId);
    }

    this.storeResult(sessionId, result);

    return result;
  }

  // Get checkpoint result
  getResult(sessionId: string, checkpointId: CheckpointId): CheckpointResult | undefined {
    return this.results.get(sessionId)?.get(checkpointId);
  }

  // Get all results for a session
  getSessionResults(sessionId: string): Map<CheckpointId, CheckpointResult> {
    return this.results.get(sessionId) || new Map();
  }

  // Check if checkpoint is complete
  isComplete(sessionId: string, checkpointId: CheckpointId): boolean {
    const result = this.getResult(sessionId, checkpointId);
    return result?.status === 'approved' || result?.status === 'skipped';
  }

  // Check if all checkpoints are complete
  areAllComplete(sessionId: string): boolean {
    const sessionResults = this.results.get(sessionId);
    if (!sessionResults) return false;

    for (const cpId of this.checkpoints.keys()) {
      const result = sessionResults.get(cpId);
      if (!result || (result.status !== 'approved' && result.status !== 'skipped')) {
        return false;
      }
    }

    return true;
  }

  // Get pending approval
  getPendingApproval(sessionId: string): CheckpointId | undefined {
    return this.pendingApprovals.get(sessionId);
  }

  // Skip checkpoint (with reason)
  async skip(
    sessionId: string,
    checkpointId: CheckpointId,
    reason: string
  ): Promise<CheckpointResult> {
    const sessionResults = this.results.get(sessionId);
    if (!sessionResults) {
      throw new Error('No checkpoint results found for session');
    }

    let result = sessionResults.get(checkpointId);
    if (!result) {
      // Create a skipped result
      result = {
        checkpointId,
        status: 'skipped',
        score: 0,
        summary: `Skipped: ${reason}`,
        details: [],
        recommendations: [],
        timestamp: new Date()
      };
    } else {
      result.status = 'skipped';
      result.summary = `Skipped: ${reason}`;
    }

    // Remove from pending
    if (this.pendingApprovals.get(sessionId) === checkpointId) {
      this.pendingApprovals.delete(sessionId);
    }

    this.storeResult(sessionId, result);

    return result;
  }

  private storeResult(sessionId: string, result: CheckpointResult): void {
    if (!this.results.has(sessionId)) {
      this.results.set(sessionId, new Map());
    }
    this.results.get(sessionId)!.set(result.checkpointId, result);
  }
}
```

### File Structure

```
packages/validation/src/checkpoints/
├── checkpoint.interface.ts
├── checkpoint-manager.ts
├── index.ts
└── __tests__/
    ├── checkpoint-manager.test.ts
    └── mocks/
        └── mock-checkpoint.ts
```

---

## Business Value

O Checkpoint Manager implementa o **Human-in-the-Loop** para pontos criticos, garantindo controle e qualidade atraves de aprovacao humana.

**Beneficios:**
- Controle humano em pontos criticos
- Auto-aprovacao condicional para casos simples
- Rastreabilidade de decisoes
- Notificacoes para aprovacoes pendentes

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Bottleneck de aprovacao | Medium | High | Auto-approve conditions |
| Timeout de aprovacao | Medium | Medium | Lembretes e escalacao |
| Rejeicao sem feedback | Low | Medium | Requisitar motivo |

---

## Scope

### In Scope
- ICheckpoint interface
- CheckpointManager class
- Approval workflow
- Auto-approve conditions
- Unit tests

### Out of Scope
- Individual checkpoint implementations (CL2-022 to CL2-027)
- CLI integration
- Notification implementation

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-012 (Task Interface) | Package | Pending |
| CL2-020 (Task Registry) | Package | Pending |
| @clone-lab/core types | Package | Available |

---

## Dev Notes

- Consider persistent storage for checkpoint state
- Add webhook support for notifications
- Implement escalation for timed-out approvals
- Add audit logging for all decisions

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/validation/src/checkpoints/checkpoint.interface.ts` | Create | Pending |
| `packages/validation/src/checkpoints/checkpoint-manager.ts` | Create | Pending |
| `packages/validation/src/checkpoints/index.ts` | Create | Pending |
| `packages/validation/src/checkpoints/__tests__/checkpoint-manager.test.ts` | Create | Pending |
| `packages/validation/src/checkpoints/__tests__/mocks/mock-checkpoint.ts` | Create | Pending |

---

## Definition of Done

- [ ] Interface defines all required methods
- [ ] Manager registers and manages checkpoints
- [ ] Approval workflow works correctly
- [ ] Auto-approve logic works
- [ ] Timeout handling implemented
- [ ] Unit tests pass (coverage > 80%)
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Checkpoints can be registered
- [ ] Evaluate returns correct results
- [ ] Approve/reject workflow works
- [ ] Auto-approve conditions work
- [ ] State management is correct

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
