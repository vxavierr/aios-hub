# Story CL2-020: Task Registry & Executor

**Story ID:** CL2-020
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 2 - Validation
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Criar o **Task Registry** e **Task Executor** que gerenciam o registro e execucao das 63 Validation Tasks, garantindo execucao em ordem correta de dependencias e agregacao de resultados.

### Problem Statement
As 63 tasks precisam ser registradas, descobertas e executadas de forma coordenada. O Registry mantem o catalogo de tasks e o Executor gerencia a execucao respeitando dependencias.

---

## Acceptance Criteria

```gherkin
Given all validation tasks are implemented
When the Task Registry is initialized
Then all 63 tasks are registered and discoverable

Given a validation session with extracted data
When the Task Executor runs
Then tasks execute in dependency order

Given parallel tasks with no dependencies between them
When the Task Executor runs
Then they execute concurrently for performance

Given a task execution failure
When the Executor handles the error
Then dependent tasks are skipped with appropriate status
```

---

## Technical Requirements

### Task Registry

```typescript
// packages/validation/src/registry/task-registry.ts

import { IValidationTask, TaskId, TaskCategory, TaskDefinition } from '../tasks/task.interface';

export interface RegistryStats {
  totalTasks: number;
  byCategory: Record<TaskCategory, number>;
  byPriority: Record<string, number>;
}

export class TaskRegistry {
  private tasks: Map<TaskId, IValidationTask>;
  private byCategory: Map<TaskCategory, Set<TaskId>>;

  constructor() {
    this.tasks = new Map();
    this.byCategory = new Map();
    this.initializeCategories();
  }

  private initializeCategories(): void {
    const categories: TaskCategory[] = [
      'extraction', 'behavioral', 'values', 'cognitive',
      'synthesis', 'implementation', 'quality'
    ];
    for (const cat of categories) {
      this.byCategory.set(cat, new Set());
    }
  }

  // Register a task
  register(task: IValidationTask): void {
    const id = task.definition.id;
    if (this.tasks.has(id)) {
      throw new Error(`Task already registered: ${id}`);
    }
    this.tasks.set(id, task);
    this.byCategory.get(task.definition.category)?.add(id);
  }

  // Register multiple tasks
  registerAll(tasks: IValidationTask[]): void {
    for (const task of tasks) {
      this.register(task);
    }
  }

  // Get a specific task
  get(id: TaskId): IValidationTask | undefined {
    return this.tasks.get(id);
  }

  // Get all tasks in a category
  getByCategory(category: TaskCategory): IValidationTask[] {
    const ids = this.byCategory.get(category);
    if (!ids) return [];
    return Array.from(ids).map(id => this.tasks.get(id)!).filter(Boolean);
  }

  // Get all tasks
  getAll(): IValidationTask[] {
    return Array.from(this.tasks.values());
  }

  // Get task definitions
  getDefinitions(): TaskDefinition[] {
    return this.getAll().map(t => t.definition);
  }

  // Get registry statistics
  getStats(): RegistryStats {
    const byCategory: Record<TaskCategory, number> = {
      extraction: 0, behavioral: 0, values: 0, cognitive: 0,
      synthesis: 0, implementation: 0, quality: 0
    };
    const byPriority: Record<string, number> = {
      critical: 0, high: 0, medium: 0, low: 0
    };

    for (const task of this.tasks.values()) {
      byCategory[task.definition.category]++;
      byPriority[task.definition.priority]++;
    }

    return {
      totalTasks: this.tasks.size,
      byCategory,
      byPriority
    };
  }

  // Validate all dependencies exist
  validateDependencies(): { valid: boolean; missing: TaskId[][] } {
    const missing: TaskId[][] = [];

    for (const task of this.tasks.values()) {
      const deps = task.getDependencies();
      for (const depId of deps) {
        if (!this.tasks.has(depId)) {
          missing.push([task.definition.id, depId]);
        }
      }
    }

    return {
      valid: missing.length === 0,
      missing
    };
  }

  // Build dependency graph
  buildDependencyGraph(): Map<TaskId, TaskId[]> {
    const graph = new Map<TaskId, TaskId[]>();

    for (const task of this.tasks.values()) {
      graph.set(task.definition.id, task.getDependencies());
    }

    return graph;
  }
}
```

### Task Executor

```typescript
// packages/validation/src/registry/task-executor.ts

import { IValidationTask, TaskContext, TaskResult, TaskId } from '../tasks/task.interface';
import { TaskRegistry } from './task-registry';

export interface ExecutionPlan {
  waves: TaskId[][];  // Tasks grouped by execution wave
  totalTasks: number;
  criticalPath: TaskId[];
}

export interface ExecutionResult {
  sessionId: string;
  results: Map<TaskId, TaskResult>;
  summary: {
    passed: number;
    failed: number;
    skipped: number;
    totalScore: number;
    averageScore: number;
  };
  executionTime: number;
}

export interface ExecutorConfig {
  parallel: boolean;
  maxConcurrency: number;
  stopOnCriticalFailure: boolean;
  timeout: number;
}

export class TaskExecutor {
  private results: Map<TaskId, TaskResult>;
  private executed: Set<TaskId>;
  private skipped: Set<TaskId>;

  constructor(
    private registry: TaskRegistry,
    private config: ExecutorConfig = {
      parallel: true,
      maxConcurrency: 5,
      stopOnCriticalFailure: true,
      timeout: 60000
    }
  ) {
    this.results = new Map();
    this.executed = new Set();
    this.skipped = new Set();
  }

  // Build execution plan based on dependencies
  buildExecutionPlan(): ExecutionPlan {
    const graph = this.registry.buildDependencyGraph();
    const waves: TaskId[][] = [];
    const completed = new Set<TaskId>();
    const criticalPath: TaskId[] = [];

    while (completed.size < graph.size) {
      const wave: TaskId[] = [];

      for (const [taskId, deps] of graph) {
        if (completed.has(taskId)) continue;

        // Check if all dependencies are completed
        const depsMet = deps.every(dep => completed.has(dep));
        if (depsMet) {
          wave.push(taskId);
        }
      }

      if (wave.length === 0) {
        // Circular dependency or missing dependency
        throw new Error('Unable to build execution plan - possible circular dependency');
      }

      waves.push(wave);
      wave.forEach(id => completed.add(id));

      // Track critical path (highest priority tasks)
      const criticalTask = wave.find(id => {
        const task = this.registry.get(id);
        return task?.definition.priority === 'critical';
      });
      if (criticalTask) criticalPath.push(criticalTask);
    }

    return {
      waves,
      totalTasks: graph.size,
      criticalPath
    };
  }

  // Execute all tasks
  async execute(context: TaskContext): Promise<ExecutionResult> {
    const startTime = Date.now();
    this.results = new Map();
    this.executed = new Set();
    this.skipped = new Set();

    const plan = this.buildExecutionPlan();

    // Execute wave by wave
    for (const wave of plan.waves) {
      if (this.config.parallel) {
        await this.executeWaveParallel(wave, context);
      } else {
        await this.executeWaveSequential(wave, context);
      }
    }

    return this.buildResult(startTime);
  }

  // Execute specific tasks
  async executeTasks(
    taskIds: TaskId[],
    context: TaskContext
  ): Promise<Map<TaskId, TaskResult>> {
    const results = new Map<TaskId, TaskResult>();

    for (const taskId of taskIds) {
      const task = this.registry.get(taskId);
      if (!task) {
        results.set(taskId, this.createErrorResult(taskId, 'Task not found'));
        continue;
      }

      const result = await this.executeTask(task, context);
      results.set(taskId, result);
      this.results.set(taskId, result);
    }

    return results;
  }

  private async executeWaveParallel(wave: TaskId[], context: TaskContext): Promise<void> {
    // Limit concurrency
    const batches: TaskId[][] = [];
    for (let i = 0; i < wave.length; i += this.config.maxConcurrency) {
      batches.push(wave.slice(i, i + this.config.maxConcurrency));
    }

    for (const batch of batches) {
      await Promise.all(batch.map(id => this.executeTaskSafe(id, context)));
    }
  }

  private async executeWaveSequential(wave: TaskId[], context: TaskContext): Promise<void> {
    for (const taskId of wave) {
      await this.executeTaskSafe(taskId, context);
    }
  }

  private async executeTaskSafe(taskId: TaskId, context: TaskContext): Promise<void> {
    // Check if dependencies passed
    const task = this.registry.get(taskId);
    if (!task) {
      this.results.set(taskId, this.createErrorResult(taskId, 'Task not found'));
      return;
    }

    // Check dependencies
    const deps = task.getDependencies();
    const depsFailed = deps.some(dep => {
      const result = this.results.get(dep);
      return result && result.status === 'failed';
    });

    if (depsFailed) {
      this.skipped.add(taskId);
      this.results.set(taskId, {
        taskId,
        status: 'skipped',
        score: 0,
        confidence: 0,
        findings: [{
          type: 'info',
          description: 'Skipped due to failed dependency',
          severity: 'low'
        }],
        recommendations: [],
        executionTime: 0,
        metadata: { skippedReason: 'dependency_failed' }
      });
      return;
    }

    // Execute the task
    const result = await this.executeTask(task, context);
    this.results.set(taskId, result);
    this.executed.add(taskId);

    // Check for critical failure
    if (this.config.stopOnCriticalFailure &&
        result.status === 'failed' &&
        task.definition.priority === 'critical') {
      // Mark remaining tasks as skipped
      throw new Error(`Critical task ${taskId} failed`);
    }
  }

  private async executeTask(task: IValidationTask, context: TaskContext): Promise<TaskResult> {
    const startTime = Date.now();

    try {
      // Validate inputs
      const inputsValid = await task.validateInputs(context);
      if (!inputsValid) {
        return {
          taskId: task.definition.id,
          status: 'skipped',
          score: 0,
          confidence: 0,
          findings: [{ type: 'info', description: 'Invalid inputs', severity: 'low' }],
          recommendations: [],
          executionTime: Date.now() - startTime,
          metadata: {}
        };
      }

      // Execute with timeout
      const result = await Promise.race([
        task.execute(context),
        this.createTimeoutPromise(task.definition.timeout)
      ]);

      return result;
    } catch (error) {
      return {
        taskId: task.definition.id,
        status: 'failed',
        score: 0,
        confidence: 0,
        findings: [{
          type: 'issue',
          description: `Execution error: ${error}`,
          severity: 'high'
        }],
        recommendations: ['Review task implementation'],
        executionTime: Date.now() - startTime,
        error: String(error),
        metadata: {}
      };
    }
  }

  private createTimeoutPromise(timeout: number): Promise<TaskResult> {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Task timeout')), timeout);
    });
  }

  private createErrorResult(taskId: TaskId, error: string): TaskResult {
    return {
      taskId,
      status: 'failed',
      score: 0,
      confidence: 0,
      findings: [{ type: 'issue', description: error, severity: 'critical' }],
      recommendations: [],
      executionTime: 0,
      error,
      metadata: {}
    };
  }

  private buildResult(startTime: number): ExecutionResult {
    const results = Array.from(this.results.values());

    const passed = results.filter(r => r.status === 'passed').length;
    const failed = results.filter(r => r.status === 'failed').length;
    const skipped = results.filter(r => r.status === 'skipped').length;
    const totalScore = results.reduce((sum, r) => sum + r.score, 0);
    const averageScore = results.length > 0 ? totalScore / results.length : 0;

    return {
      sessionId: '', // Will be set by caller
      results: this.results,
      summary: { passed, failed, skipped, totalScore, averageScore },
      executionTime: Date.now() - startTime
    };
  }
}
```

### File Structure

```
packages/validation/src/registry/
├── task-registry.ts
├── task-executor.ts
├── index.ts
└── __tests__/
    ├── task-registry.test.ts
    └── task-executor.test.ts
```

---

## Business Value

O Task Registry e Executor sao o **coracao do sistema de validacao**, gerenciando todas as 63 tasks e garantindo execucao coordenada.

**Beneficios:**
- Registro centralizado de todas as tasks
- Execucao automatica respeitando dependencias
- Paralelizacao para performance
- Error handling robusto

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Dependencia circular | Low | Critical | Validacao no buildExecutionPlan |
| Performance bottleneck | Medium | Medium | Concurrency limits |
| Falha em cascata | Medium | High | Skip logica |

---

## Scope

### In Scope
- TaskRegistry class
- TaskExecutor class
- Execution plan builder
- Parallel execution
- Error handling and recovery
- Unit and integration tests

### Out of Scope
- CLI integration
- Persistence
- Checkpoint integration

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-012 to CL2-019 (All Tasks) | Package | Pending |
| @clone-lab/core types | Package | Available |

---

## Dev Notes

- Use topological sort for dependency resolution
- Implement circuit breaker for task failures
- Add telemetry hooks for observability
- Consider persistent result caching

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/validation/src/registry/task-registry.ts` | Create | Pending |
| `packages/validation/src/registry/task-executor.ts` | Create | Pending |
| `packages/validation/src/registry/index.ts` | Create | Pending |
| `packages/validation/src/registry/__tests__/task-registry.test.ts` | Create | Pending |
| `packages/validation/src/registry/__tests__/task-executor.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Registry registers all task types
- [ ] Executor builds correct execution plan
- [ ] Parallel execution works
- [ ] Dependencies are respected
- [ ] Error handling works as expected
- [ ] Integration tests with all 63 tasks
- [ ] Performance: 63 tasks em < 60s
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Registry validates dependencies
- [ ] Executor respects dependency order
- [ ] Parallel execution is correct
- [ ] Failed tasks handled properly
- [ ] Skipped tasks tracked

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
