# Story CL2-038: Rollback Manager

**Story ID:** CL2-038
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o **Rollback Manager** - componente que gerencia a reversão de mudanças aplicadas, restaurando o sistema a estados anteriores quando necessário.

### Problem Statement
O Clone Lab precisa de capacidade de rollback robusta para reverter mudanças que tiveram impacto negativo. O Rollback Manager gerencia restore points e executa rollbacks de forma segura.

---

## Acceptance Criteria

```gherkin
Given a change was applied successfully
When rollback is requested
Then the system is restored to its previous state

Given multiple changes were applied
When rollback to a specific point is requested
Then all changes after that point are reversed

Given a rollback is in progress
When an error occurs
Then partial rollback state is tracked for recovery

Given a change had negative impact detected
When automatic rollback is triggered
Then the system reverts without human intervention
```

---

## Technical Requirements

### Rollback Manager

```typescript
// packages/meta/src/rollback/manager.ts

export interface RollbackRequest {
  changeId: string;              // Change to roll back
  reason: string;
  triggeredBy: 'auto' | 'human';
  urgency: 'immediate' | 'scheduled';
}

export interface RollbackResult {
  id: string;
  request: RollbackRequest;
  status: 'success' | 'partial' | 'failed';
  restoredFiles: string[];
  failedFiles: string[];
  startedAt: Date;
  completedAt: Date;
  verificationPassed: boolean;
}

export interface RollbackPolicy {
  autoRollbackThreshold: number; // Impact score threshold
  cooldownAfterRollback: Duration;
  maxRollbackChainLength: number;
}

export class RollbackManager {
  private readonly snapshotManager: SnapshotManager;
  private readonly evolutionLog: EvolutionLog;
  private readonly fileSystem: FileSystemAccess;
  private readonly policy: RollbackPolicy;

  constructor(
    snapshotManager: SnapshotManager,
    evolutionLog: EvolutionLog,
    fileSystem: FileSystemAccess,
    policy: RollbackPolicy
  ) {
    this.snapshotManager = snapshotManager;
    this.evolutionLog = evolutionLog;
    this.fileSystem = fileSystem;
    this.policy = policy;
  }

  async rollback(request: RollbackRequest): Promise<RollbackResult> {
    const rollbackId = generateId();
    const startTime = new Date();

    // 1. Get the change to rollback
    const change = await this.evolutionLog.getChange(request.changeId);
    if (!change) {
      throw new RollbackError(`Change not found: ${request.changeId}`);
    }

    // 2. Check if rollback is possible
    if (!change.restorePoint) {
      throw new RollbackError(`No restore point for change: ${request.changeId}`);
    }

    // 3. Find dependent changes that also need rollback
    const dependentChanges = await this.findDependentChanges(request.changeId);
    if (dependentChanges.length > this.policy.maxRollbackChainLength) {
      throw new RollbackError(
        `Too many dependent changes (${dependentChanges.length}). ` +
        `Manual intervention required.`
      );
    }

    // 4. Create rollback plan
    const plan = await this.createRollbackPlan(change, dependentChanges);

    // 5. Execute rollback
    const execution = await this.executeRollback(plan);

    // 6. Verify rollback
    const verification = await this.verifyRollback(change, execution);

    const result: RollbackResult = {
      id: rollbackId,
      request,
      status: execution.success ? 'success' : execution.partial ? 'partial' : 'failed',
      restoredFiles: execution.restoredFiles,
      failedFiles: execution.failedFiles,
      startedAt: startTime,
      completedAt: new Date(),
      verificationPassed: verification.passed
    };

    // 7. Log the rollback
    await this.evolutionLog.logRollback({
      rollbackId,
      originalChangeId: request.changeId,
      result,
      timestamp: new Date()
    });

    // 8. Mark original change as rolled back
    await this.evolutionLog.updateChangeStatus(request.changeId, 'rolled_back');

    return result;
  }

  async rollbackChain(changeIds: string[]): Promise<RollbackChainResult> {
    // Roll back in reverse order (newest first)
    const sortedIds = await this.sortChangesByTimeDesc(changeIds);
    const results: RollbackResult[] = [];

    for (const changeId of sortedIds) {
      const result = await this.rollback({
        changeId,
        reason: 'Part of chain rollback',
        triggeredBy: 'human',
        urgency: 'immediate'
      });
      results.push(result);

      // Stop chain on failure
      if (result.status === 'failed') {
        break;
      }
    }

    return {
      results,
      totalRolledBack: results.filter(r => r.status === 'success').length,
      totalFailed: results.filter(r => r.status !== 'success').length
    };
  }

  async autoRollback(changeId: string, impactData: ImpactMeasurement): Promise<RollbackResult> {
    // Check if auto-rollback threshold is met
    if (impactData.impactScore < this.policy.autoRollbackThreshold) {
      throw new RollbackError(
        `Impact score (${impactData.impactScore}) below auto-rollback threshold ` +
        `(${this.policy.autoRollbackThreshold})`
      );
    }

    return this.rollback({
      changeId,
      reason: `Auto-rollback: negative impact detected (score: ${impactData.impactScore})`,
      triggeredBy: 'auto',
      urgency: 'immediate'
    });
  }

  private async findDependentChanges(changeId: string): Promise<AppliedChange[]> {
    // Find changes that depend on this change
    const allChanges = await this.evolutionLog.getChangesAfter(changeId);
    const dependent: AppliedChange[] = [];

    for (const change of allChanges) {
      if (change.improvement.dependencies?.includes(changeId)) {
        dependent.push(change);
      }
    }

    return dependent;
  }

  private async createRollbackPlan(
    change: AppliedChange,
    dependentChanges: AppliedChange[]
  ): Promise<RollbackPlan> {
    return {
      primaryChange: change,
      dependentChanges,
      steps: [
        // Roll back dependents first
        ...dependentChanges.reverse().map(c => ({
          type: 'restore' as const,
          change: c,
          restorePoint: c.restorePoint
        })),
        // Then roll back primary change
        {
          type: 'restore' as const,
          change,
          restorePoint: change.restorePoint
        }
      ]
    };
  }

  private async executeRollback(plan: RollbackPlan): Promise<RollbackExecution> {
    const restoredFiles: string[] = [];
    const failedFiles: string[] = [];

    for (const step of plan.steps) {
      try {
        await this.snapshotManager.restore(step.restorePoint);

        // Track restored files
        for (const snapshot of step.change.beforeState.files) {
          if (!failedFiles.includes(snapshot.path)) {
            restoredFiles.push(snapshot.path);
          }
        }
      } catch (error) {
        console.error(`Rollback step failed: ${error}`);
        // Mark files as failed
        for (const snapshot of step.change.beforeState.files) {
          failedFiles.push(snapshot.path);
        }
      }
    }

    return {
      success: failedFiles.length === 0,
      partial: failedFiles.length > 0 && restoredFiles.length > 0,
      restoredFiles: [...new Set(restoredFiles)],
      failedFiles: [...new Set(failedFiles)]
    };
  }

  private async verifyRollback(
    change: AppliedChange,
    execution: RollbackExecution
  ): Promise<VerificationResult> {
    // Verify files match original state
    const mismatches: string[] = [];

    for (const snapshot of change.beforeState.files) {
      const currentHash = await this.fileSystem.hash(snapshot.path);
      if (currentHash !== snapshot.hash) {
        mismatches.push(snapshot.path);
      }
    }

    return {
      passed: mismatches.length === 0,
      mismatches
    };
  }
}
```

### Rollback Policies

```typescript
// packages/meta/src/rollback/policies.ts

export const DEFAULT_ROLLBACK_POLICY: RollbackPolicy = {
  // Auto-rollback when impact score is negative and below this threshold
  autoRollbackThreshold: -30,

  // Don't allow changes for this duration after a rollback
  cooldownAfterRollback: '24h',

  // Maximum number of changes to roll back in a chain
  maxRollbackChainLength: 5
};

export class RollbackPolicyManager {
  private policies: Map<string, RollbackPolicy>;

  constructor() {
    this.policies = new Map();
    this.policies.set('default', DEFAULT_ROLLBACK_POLICY);
  }

  getPolicy(name: string = 'default'): RollbackPolicy {
    return this.policies.get(name) || DEFAULT_ROLLBACK_POLICY;
  }

  shouldAutoRollback(
    policy: RollbackPolicy,
    impactData: ImpactMeasurement
  ): boolean {
    return (
      impactData.impactScore < 0 &&
      Math.abs(impactData.impactScore) >= Math.abs(policy.autoRollbackThreshold)
    );
  }

  isInCooldown(
    lastRollbackTime: Date,
    policy: RollbackPolicy
  ): boolean {
    const cooldownEnd = new Date(lastRollbackTime);
    cooldownEnd.setHours(
      cooldownEnd.getHours() + this.parseDuration(policy.cooldownAfterRollback)
    );
    return new Date() < cooldownEnd;
  }

  private parseDuration(duration: string): number {
    const match = duration.match(/^(\d+)(h|d)$/);
    if (!match) return 24;

    const value = parseInt(match[1]);
    const unit = match[2];

    return unit === 'd' ? value * 24 : value;
  }
}
```

### Rollback History

```typescript
// packages/meta/src/rollback/history.ts

export class RollbackHistory {
  private readonly storage: HistoryStorage;

  constructor(storage: HistoryStorage) {
    this.storage = storage;
  }

  async record(rollback: RollbackResult): Promise<void> {
    await this.storage.save({
      ...rollback,
      recordedAt: new Date()
    });
  }

  async getHistory(options?: HistoryOptions): Promise<RollbackResult[]> {
    return this.storage.query(options);
  }

  async getStatistics(): Promise<RollbackStatistics> {
    const history = await this.getHistory();

    return {
      total: history.length,
      successful: history.filter(r => r.status === 'success').length,
      partial: history.filter(r => r.status === 'partial').length,
      failed: history.filter(r => r.status === 'failed').length,
      autoTriggered: history.filter(r => r.request.triggeredBy === 'auto').length,
      humanTriggered: history.filter(r => r.request.triggeredBy === 'human').length,
      averageDuration: this.calculateAverageDuration(history)
    };
  }
}
```

---

## Business Value

O Rollback Manager é a **segurança do sistema** - permite reverter mudanças problemáticas rapidamente, minimizando tempo de inatividade e impacto.

**Benefícios:**
- Recuperação rápida de mudanças problemáticas
- Rollback automático baseado em impacto
- Histórico completo de rollbacks
- Políticas configuráveis

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Rollback fails partially | Medium | High | Partial state tracking |
| Dependent changes not rolled back | Medium | Medium | Dependency analysis |
| Data loss during rollback | Low | Critical | Verification step |

---

## Scope

### In Scope
- RollbackManager class
- Chain rollback support
- Auto-rollback based on impact
- Rollback policies
- History and statistics

### Out of Scope
- Distributed rollback
- Database-specific rollback
- Real-time monitoring

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| CL2-037 (Change Applier) | Package | Pending |
| CL2-041 (Evolution Log) | Package | Pending |
| CL2-042 (Snapshot System) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Rollback Trigger Conditions

```typescript
const AUTO_ROLLBACK_TRIGGERS = [
  { metric: 'error_rate_increase', threshold: 50 },      // 50% increase
  { metric: 'response_time_increase', threshold: 100 }, // 2x slower
  { metric: 'fidelity_score_drop', threshold: -10 },    // 10 points drop
  { metric: 'user_reported_issues', threshold: 3 }       // 3+ reports
];
```

### Rollback Verification

```typescript
async function verifyRollbackComplete(
  original: ChangeState,
  current: ChangeState
): Promise<boolean> {
  // Check all file hashes match
  for (const file of original.files) {
    const currentFile = current.files.find(f => f.path === file.path);
    if (!currentFile || currentFile.hash !== file.hash) {
      return false;
    }
  }
  return true;
}
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/rollback/manager.ts` | Create | Pending |
| `packages/meta/src/rollback/policies.ts` | Create | Pending |
| `packages/meta/src/rollback/history.ts` | Create | Pending |
| `packages/meta/src/rollback/types.ts` | Create | Pending |
| `packages/meta/src/rollback/index.ts` | Create | Pending |
| `packages/meta/src/rollback/__tests__/manager.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Single change rollback works
- [ ] Chain rollback works
- [ ] Auto-rollback triggers correctly
- [ ] Policies configurable
- [ ] History tracked
- [ ] Verification passes
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Single change rollback works
- [ ] Chain rollback works
- [ ] Auto-rollback triggers correctly
- [ ] Policies configurable
- [ ] History tracked
- [ ] Verification passes
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
