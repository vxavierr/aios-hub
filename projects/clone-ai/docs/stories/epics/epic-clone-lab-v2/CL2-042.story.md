# Story CL2-042: Snapshot System

**Story ID:** CL2-042
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 3 - Meta-Cognition
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar o **Snapshot System** - sistema de captura e restauração de estados do sistema para suportar rollback e comparação de estados.

### Problem Statement
O Clone Lab precisa de capacidade de capturar e restaurar estados do sistema. O Snapshot System permite criar restore points antes de mudanças e restaurá-los quando necessário.

---

## Acceptance Criteria

```gherkin
Given a snapshot is requested
When the snapshot is created
Then all relevant state is captured

Given a snapshot exists
When restoration is requested
Then the system returns to the captured state

Given multiple snapshots exist
When listing snapshots
Then they are ordered by creation time

Given snapshots accumulate
When cleanup is triggered
Then old snapshots are removed based on policy
```

---

## Technical Requirements

### Snapshot Manager

```typescript
// packages/meta/src/snapshot/manager.ts

export interface Snapshot {
  id: string;
  createdAt: Date;
  type: 'full' | 'incremental';
  targets: string[];
  metadata: SnapshotMetadata;
  status: 'creating' | 'complete' | 'failed' | 'restoring';
  size: number;
  checksum: string;
}

export interface SnapshotMetadata {
  reason: string;
  changeId?: string;
  component: string;
  tags: string[];
}

export interface RestorePoint {
  id: string;
  snapshotId: string;
  createdAt: Date;
  targets: string[];
}

export class SnapshotManager {
  private readonly storage: SnapshotStorage;
  private readonly fileSystem: FileSystemAccess;
  private readonly config: SnapshotConfig;

  constructor(
    storage: SnapshotStorage,
    fileSystem: FileSystemAccess,
    config: SnapshotConfig
  ) {
    this.storage = storage;
    this.fileSystem = fileSystem;
    this.config = config;
  }

  async createSnapshot(params: {
    id: string;
    targets: string[];
    reason: string;
    changeId?: string;
  }): Promise<Snapshot> {
    const snapshot: Snapshot = {
      id: params.id,
      createdAt: new Date(),
      type: 'full',
      targets: params.targets,
      metadata: {
        reason: params.reason,
        changeId: params.changeId,
        component: 'snapshot-manager',
        tags: []
      },
      status: 'creating',
      size: 0,
      checksum: ''
    };

    try {
      // Capture each target
      const capturedData: CapturedTarget[] = [];

      for (const target of params.targets) {
        const data = await this.captureTarget(target);
        capturedData.push(data);
      }

      // Store the snapshot data
      const snapshotData = {
        snapshot,
        capturedData,
        version: 1
      };

      const serialized = JSON.stringify(snapshotData);
      await this.storage.save(snapshot.id, serialized);

      // Calculate size and checksum
      snapshot.size = serialized.length;
      snapshot.checksum = this.calculateChecksum(serialized);
      snapshot.status = 'complete';

      // Update snapshot with final metadata
      await this.storage.update(snapshot.id, JSON.stringify({ snapshot, capturedData }));

      return snapshot;

    } catch (error) {
      snapshot.status = 'failed';
      throw new SnapshotError(`Failed to create snapshot: ${error}`);
    }
  }

  async createRestorePoint(params: {
    id: string;
    targets: string[];
    reason: string;
  }): Promise<RestorePoint> {
    // Create a snapshot first
    const snapshot = await this.createSnapshot({
      id: `rp-snapshot-${params.id}`,
      targets: params.targets,
      reason: `Restore point: ${params.reason}`
    });

    return {
      id: params.id,
      snapshotId: snapshot.id,
      createdAt: new Date(),
      targets: params.targets
    };
  }

  async restore(restorePoint: RestorePoint): Promise<RestoreResult> {
    const snapshot = await this.getSnapshot(restorePoint.snapshotId);
    if (!snapshot) {
      throw new SnapshotError(`Snapshot not found: ${restorePoint.snapshotId}`);
    }

    const restored: string[] = [];
    const failed: string[] = [];

    // Load snapshot data
    const data = await this.storage.load(restorePoint.snapshotId);
    const snapshotData = JSON.parse(data);

    // Restore each captured target
    for (const captured of snapshotData.capturedData) {
      try {
        await this.restoreTarget(captured);
        restored.push(captured.target);
      } catch (error) {
        console.error(`Failed to restore ${captured.target}: ${error}`);
        failed.push(captured.target);
      }
    }

    return {
      success: failed.length === 0,
      restored,
      failed,
      snapshotId: snapshot.id
    };
  }

  async getSnapshot(id: string): Promise<Snapshot | null> {
    const data = await this.storage.load(id);
    if (!data) return null;

    const snapshotData = JSON.parse(data);
    return snapshotData.snapshot;
  }

  async listSnapshots(options?: ListOptions): Promise<Snapshot[]> {
    const allIds = await this.storage.list();

    let snapshots: Snapshot[] = [];
    for (const id of allIds) {
      const snapshot = await this.getSnapshot(id);
      if (snapshot) {
        snapshots.push(snapshot);
      }
    }

    // Sort by creation date (newest first)
    snapshots.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());

    // Apply filters
    if (options?.tags) {
      snapshots = snapshots.filter(s =>
        options.tags!.some(t => s.metadata.tags.includes(t))
      );
    }

    if (options?.changeId) {
      snapshots = snapshots.filter(s => s.metadata.changeId === options.changeId);
    }

    // Apply pagination
    if (options?.offset) {
      snapshots = snapshots.slice(options.offset);
    }

    if (options?.limit) {
      snapshots = snapshots.slice(0, options.limit);
    }

    return snapshots;
  }

  async deleteSnapshot(id: string): Promise<void> {
    await this.storage.delete(id);
  }

  async cleanup(policy: CleanupPolicy): Promise<CleanupResult> {
    const snapshots = await this.listSnapshots();
    const toDelete: string[] = [];

    for (const snapshot of snapshots) {
      const age = Date.now() - snapshot.createdAt.getTime();
      const ageDays = age / (1000 * 60 * 60 * 24);

      // Delete if older than retention period
      if (ageDays > policy.retentionDays) {
        toDelete.push(snapshot.id);
        continue;
      }

      // Delete if exceeds max count
      if (policy.maxCount && snapshots.indexOf(snapshot) >= policy.maxCount) {
        toDelete.push(snapshot.id);
      }
    }

    for (const id of toDelete) {
      await this.deleteSnapshot(id);
    }

    return {
      deleted: toDelete.length,
      remaining: snapshots.length - toDelete.length
    };
  }

  private async captureTarget(target: string): Promise<CapturedTarget> {
    const resolvedPath = this.resolvePath(target);

    if (await this.fileSystem.exists(resolvedPath)) {
      const content = await this.fileSystem.read(resolvedPath);
      const stats = await this.fileSystem.stats(resolvedPath);

      return {
        target,
        type: 'file',
        path: resolvedPath,
        content,
        hash: this.calculateChecksum(content),
        permissions: stats?.mode,
        modifiedAt: stats?.mtime
      };
    } else {
      return {
        target,
        type: 'absent',
        path: resolvedPath,
        exists: false
      };
    }
  }

  private async restoreTarget(captured: CapturedTarget): Promise<void> {
    if (captured.type === 'absent') {
      // Target didn't exist, remove if it exists now
      if (await this.fileSystem.exists(captured.path)) {
        await this.fileSystem.remove(captured.path);
      }
      return;
    }

    // Restore file content
    await this.fileSystem.write(captured.path, captured.content);

    // Restore permissions if available
    if (captured.permissions) {
      await this.fileSystem.chmod(captured.path, captured.permissions);
    }
  }

  private resolvePath(target: string): string {
    // Convert target notation to actual file path
    // e.g., "minds/tim/prompts" -> "packages/minds/src/minds/tim/prompts"
    const mappings: Record<string, string> = {
      'minds/': 'packages/minds/src/minds/',
      'validation/': 'packages/validation/src/',
      'checkpoints/': 'packages/checkpoints/src/',
      'config/': 'config/'
    };

    for (const [prefix, path] of Object.entries(mappings)) {
      if (target.startsWith(prefix)) {
        return path + target.slice(prefix.length);
      }
    }

    return target;
  }

  private calculateChecksum(data: string): string {
    const crypto = require('crypto');
    return crypto.createHash('sha256').update(data).digest('hex');
  }
}
```

### Snapshot Storage

```typescript
// packages/meta/src/snapshot/storage.ts

export interface SnapshotStorage {
  save(id: string, data: string): Promise<void>;
  load(id: string): Promise<string | null>;
  update(id: string, data: string): Promise<void>;
  delete(id: string): Promise<void>;
  list(): Promise<string[]>;
}

export class FileSnapshotStorage implements SnapshotStorage {
  private readonly basePath: string;

  constructor(basePath: string) {
    this.basePath = basePath;
  }

  async save(id: string, data: string): Promise<void> {
    const filePath = this.getFilePath(id);
    const dir = path.dirname(filePath);

    await fs.mkdir(dir, { recursive: true });
    await fs.writeFile(filePath, data, 'utf-8');
  }

  async load(id: string): Promise<string | null> {
    const filePath = this.getFilePath(id);

    try {
      return await fs.readFile(filePath, 'utf-8');
    } catch {
      return null;
    }
  }

  async update(id: string, data: string): Promise<void> {
    await this.save(id, data);
  }

  async delete(id: string): Promise<void> {
    const filePath = this.getFilePath(id);

    try {
      await fs.unlink(filePath);
    } catch {
      // Ignore if doesn't exist
    }
  }

  async list(): Promise<string[]> {
    const files = await fs.readdir(this.basePath);
    return files
      .filter(f => f.endsWith('.snapshot'))
      .map(f => f.replace('.snapshot', ''));
  }

  private getFilePath(id: string): string {
    // Organize by date for easier management
    const date = new Date().toISOString().slice(0, 10); // YYYY-MM-DD
    return path.join(this.basePath, date, `${id}.snapshot`);
  }
}
```

### Snapshot Configuration

```yaml
# packages/meta/src/snapshot/config.yaml

snapshot:
  basePath: '.snapshots'

  retention:
    days: 30              # Keep snapshots for 30 days
    maxCount: 100         # Maximum 100 snapshots

  cleanup:
    schedule: '0 2 * * *' # Run at 2 AM daily
    dryRun: false

  compression:
    enabled: true
    algorithm: 'gzip'

  verification:
    enabled: true
    onRestore: true       # Verify checksum before restore
```

---

## Business Value

O Snapshot System fornece **capacidade de ponto de restauração** para o sistema, essencial para rollback seguro e comparação de estados.

**Benefícios:**
- Restore points automáticos antes de mudanças
- Rollback rápido quando necessário
- Histórico de estados para debugging
- Limpeza automática de snapshots antigos

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Storage growth | High | Low | Retention + cleanup |
| Snapshot corruption | Low | High | Checksum verification |
| Restore failure | Low | Critical | Atomic restore + logging |

---

## Scope

### In Scope
- SnapshotManager class
- File-based snapshot storage
- Target capture and restore
- Cleanup policy
- Restore point creation

### Out of Scope
- Cloud storage
- Incremental snapshots
- Distributed snapshots

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-028 (Meta Package Setup) | Package | Pending |
| @clone-lab/core | Package | Available |

---

## Dev Notes

### Snapshot Organization

```
.snapshots/
├── 2026-02-20/
│   ├── rp-snapshot-abc123.snapshot
│   └── rp-snapshot-def456.snapshot
├── 2026-02-19/
│   └── rp-snapshot-xyz789.snapshot
└── metadata.json
```

### Restore Verification

```typescript
async function verifyRestore(snapshot: Snapshot, restored: CapturedTarget[]): Promise<boolean> {
  for (const captured of restored) {
    const currentHash = await this.fileSystem.hash(captured.path);
    if (currentHash !== captured.hash) {
      return false;
    }
  }
  return true;
}
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/snapshot/manager.ts` | Create | Pending |
| `packages/meta/src/snapshot/storage.ts` | Create | Pending |
| `packages/meta/src/snapshot/config.yaml` | Create | Pending |
| `packages/meta/src/snapshot/types.ts` | Create | Pending |
| `packages/meta/src/snapshot/index.ts` | Create | Pending |
| `packages/meta/src/snapshot/__tests__/manager.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Snapshots created correctly
- [ ] Restore works correctly
- [ ] Cleanup policy enforced
- [ ] Restore points created before changes
- [ ] Checksum verification works
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Snapshots created correctly
- [ ] Restore works correctly
- [ ] Cleanup policy enforced
- [ ] Restore points created before changes
- [ ] Checksum verification works
- [ ] All tests pass

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
