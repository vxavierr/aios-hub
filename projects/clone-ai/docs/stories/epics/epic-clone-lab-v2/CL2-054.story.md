# Story CL2-054: Error Recovery Integration

**Story ID:** CL2-054
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 4 - Integration
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Integrar sistema de recuperacao de erros com o pipeline. O sistema deve detectar, classificar, recuperar e reportar erros de forma robusta, permitindo que o pipeline continue ou falhe graciosamente.

### Problem Statement
O pipeline Clone Lab precisa lidar com diversos tipos de erros (rede, API, validacao, etc.) de forma consistente, com estrategias de recuperacao apropriadas para cada tipo.

---

## Acceptance Criteria

```gherkin
Given a recoverable error occurs
When the error handler processes it
Then automatic retry or recovery is attempted

Given an unrecoverable error occurs
When the error handler processes it
Then the pipeline fails gracefully with clear error message

Given multiple errors occur
When error recovery runs
Then errors are prioritized and handled appropriately

Given an error is recovered
When logging occurs
Then recovery action is recorded for audit
```

---

## Technical Requirements

### Error Types

```typescript
// packages/errors/src/types.ts

export type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical';

export type ErrorCategory =
  | 'network'           // Network connectivity issues
  | 'api'               // External API errors
  | 'validation'        // Data validation failures
  | 'processing'        // Processing logic errors
  | 'resource'          // Resource exhaustion
  | 'configuration'     // Configuration errors
  | 'authentication'    // Auth/authz failures
  | 'timeout'           // Operation timeouts
  | 'unknown';          // Unclassified errors

export type RecoveryStrategy =
  | 'retry'             // Retry the operation
  | 'fallback'          // Use fallback value/approach
  | 'skip'              // Skip and continue
  | 'abort'             // Abort pipeline
  | 'escalate';         // Escalate to human

export interface PipelineError extends Error {
  id: string;
  code: string;
  category: ErrorCategory;
  severity: ErrorSeverity;
  recoverable: boolean;
  context: ErrorContext;
  recoveryStrategy?: RecoveryStrategy;
  retryCount?: number;
  maxRetries?: number;
  timestamp: Date;
}

export interface ErrorContext {
  sessionId?: string;
  cloneId?: string;
  phase?: PipelinePhase;
  step?: string;
  operation?: string;
  input?: any;
  metadata?: Record<string, any>;
}

export interface RecoveryResult {
  success: boolean;
  action: RecoveryStrategy;
  attempts: number;
  recoveredAt?: Date;
  fallbackValue?: any;
  error?: PipelineError;
}
```

### Error Classifier

```typescript
// packages/errors/src/classifier.ts

export class ErrorClassifier {
  private readonly patterns: ErrorPattern[] = [
    { pattern: /ECONNREFUSED|ENOTFOUND|ETIMEDOUT/, category: 'network' },
    { pattern: /429|rate limit|quota exceeded/, category: 'api', severity: 'medium' },
    { pattern: /401|403|unauthorized|forbidden/, category: 'authentication' },
    { pattern: /500|502|503|internal server error/, category: 'api', severity: 'high' },
    { pattern: /validation failed|invalid|malformed/, category: 'validation' },
    { pattern: /timeout|timed out/, category: 'timeout' },
    { pattern: /out of memory|heap exhausted/, category: 'resource', severity: 'critical' },
    { pattern: /config|configuration/, category: 'configuration' }
  ];

  classify(error: Error, context?: ErrorContext): PipelineError {
    const pipelineError = error as PipelineError;
    pipelineError.id = generateId();
    pipelineError.timestamp = new Date();
    pipelineError.context = context || {};

    // Classify by pattern matching
    for (const { pattern, category, severity } of this.patterns) {
      if (pattern.test(error.message) || pattern.test(error.name)) {
        pipelineError.category = category;
        pipelineError.severity = severity || this.getDefaultSeverity(category);
        break;
      }
    }

    // Default classification
    if (!pipelineError.category) {
      pipelineError.category = 'unknown';
      pipelineError.severity = 'medium';
    }

    // Determine recoverability
    pipelineError.recoverable = this.isRecoverable(pipelineError);

    // Assign recovery strategy
    pipelineError.recoveryStrategy = this.getRecoveryStrategy(pipelineError);

    return pipelineError;
  }

  private getDefaultSeverity(category: ErrorCategory): ErrorSeverity {
    const severities: Record<ErrorCategory, ErrorSeverity> = {
      network: 'medium',
      api: 'medium',
      validation: 'low',
      processing: 'high',
      resource: 'critical',
      configuration: 'high',
      authentication: 'high',
      timeout: 'medium',
      unknown: 'medium'
    };
    return severities[category];
  }

  private isRecoverable(error: PipelineError): boolean {
    const unrecoverable: ErrorCategory[] = [
      'configuration',
      'authentication'
    ];

    if (unrecoverable.includes(error.category)) {
      return false;
    }

    if (error.severity === 'critical') {
      return false;
    }

    return true;
  }

  private getRecoveryStrategy(error: PipelineError): RecoveryStrategy {
    switch (error.category) {
      case 'network':
      case 'timeout':
        return 'retry';
      case 'api':
        return error.severity === 'high' ? 'escalate' : 'retry';
      case 'validation':
        return 'skip';
      case 'processing':
        return 'fallback';
      case 'resource':
        return 'abort';
      default:
        return 'abort';
    }
  }
}
```

### Error Recovery Manager

```typescript
// packages/errors/src/recovery-manager.ts

export class ErrorRecoveryManager {
  private readonly retryConfig: RetryConfig;

  constructor(
    private readonly classifier: ErrorClassifier,
    private readonly logger: ErrorLogger
  ) {
    this.retryConfig = {
      maxRetries: 3,
      baseDelay: 1000,
      maxDelay: 30000,
      backoffMultiplier: 2
    };
  }

  async handleError(
    error: Error,
    context: ErrorContext,
    operation?: () => Promise<any>
  ): Promise<RecoveryResult> {
    const pipelineError = this.classifier.classify(error, context);

    // Log the error
    await this.logger.log(pipelineError);

    // Check if recoverable
    if (!pipelineError.recoverable) {
      return {
        success: false,
        action: 'abort',
        attempts: 0,
        error: pipelineError
      };
    }

    // Execute recovery strategy
    switch (pipelineError.recoveryStrategy) {
      case 'retry':
        return this.retryOperation(pipelineError, operation!);
      case 'fallback':
        return this.applyFallback(pipelineError);
      case 'skip':
        return this.skipOperation(pipelineError);
      case 'escalate':
        return this.escalateError(pipelineError);
      default:
        return {
          success: false,
          action: 'abort',
          attempts: 0,
          error: pipelineError
        };
    }
  }

  private async retryOperation(
    error: PipelineError,
    operation: () => Promise<any>
  ): Promise<RecoveryResult> {
    const maxRetries = error.maxRetries ?? this.retryConfig.maxRetries;
    let attempt = error.retryCount ?? 0;

    while (attempt < maxRetries) {
      attempt++;
      const delay = this.calculateDelay(attempt);

      await this.sleep(delay);

      try {
        const result = await operation();

        await this.logger.logRecovery(error, {
          action: 'retry',
          attempts: attempt,
          success: true
        });

        return {
          success: true,
          action: 'retry',
          attempts: attempt,
          recoveredAt: new Date()
        };
      } catch (retryError) {
        await this.logger.logRetry(error, attempt, retryError);
      }
    }

    return {
      success: false,
      action: 'retry',
      attempts: attempt,
      error
    };
  }

  private async applyFallback(error: PipelineError): Promise<RecoveryResult> {
    const fallback = this.getFallbackValue(error);

    await this.logger.logRecovery(error, {
      action: 'fallback',
      fallbackValue: fallback,
      success: true
    });

    return {
      success: true,
      action: 'fallback',
      attempts: 1,
      recoveredAt: new Date(),
      fallbackValue: fallback
    };
  }

  private async skipOperation(error: PipelineError): Promise<RecoveryResult> {
    await this.logger.logRecovery(error, {
      action: 'skip',
      success: true
    });

    return {
      success: true,
      action: 'skip',
      attempts: 1,
      recoveredAt: new Date()
    };
  }

  private async escalateError(error: PipelineError): Promise<RecoveryResult> {
    await this.logger.logRecovery(error, {
      action: 'escalate',
      success: false
    });

    // Would integrate with notification system
    // await this.notifier.notify(error);

    return {
      success: false,
      action: 'escalate',
      attempts: 0,
      error
    };
  }

  private calculateDelay(attempt: number): number {
    const delay = this.retryConfig.baseDelay *
      Math.pow(this.retryConfig.backoffMultiplier, attempt - 1);
    return Math.min(delay, this.retryConfig.maxDelay);
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private getFallbackValue(error: PipelineError): any {
    // Return appropriate fallback based on context
    switch (error.context.phase) {
      case 'extraction':
        return []; // Empty extraction result
      case 'analysis':
        return { confidence: 0 }; // Low confidence analysis
      default:
        return null;
    }
  }
}
```

### Pipeline Error Handler

```typescript
// packages/errors/src/pipeline-handler.ts

export class PipelineErrorHandler {
  constructor(
    private readonly recoveryManager: ErrorRecoveryManager,
    private readonly contextManager: ContextManager
  ) {}

  wrapOperation<T>(
    operation: () => Promise<T>,
    context: ErrorContext
  ): () => Promise<T> {
    return async () => {
      try {
        return await operation();
      } catch (error) {
        const result = await this.recoveryManager.handleError(
          error as Error,
          context,
          operation
        );

        if (result.success) {
          if (result.action === 'skip') {
            // Return appropriate empty/default value
            return this.getDefaultValue<T>(context);
          }
          if (result.action === 'fallback') {
            return result.fallbackValue as T;
          }
          // Retry succeeded - operation already returned
          return this.getDefaultValue<T>(context);
        }

        // Recovery failed - rethrow
        throw this.enrichError(error as Error, result);
      }
    };
  }

  async executeWithRecovery<T>(
    operation: () => Promise<T>,
    context: ErrorContext
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      const result = await this.recoveryManager.handleError(
        error as Error,
        context,
        operation
      );

      if (result.success) {
        if (result.action === 'fallback' && result.fallbackValue !== undefined) {
          return result.fallbackValue as T;
        }
        if (result.action === 'skip') {
          return this.getDefaultValue<T>(context);
        }
        throw new Error('Recovery succeeded but no value returned');
      }

      throw this.enrichError(error as Error, result);
    }
  }

  private getDefaultValue<T>(context: ErrorContext): T {
    // Return phase-appropriate default values
    const defaults: Record<string, any> = {
      extraction: [],
      analysis: { traits: [], confidence: 0 },
      synthesis: null,
      validation: { status: 'warning', issues: [] },
      generation: ''
    };

    return (defaults[context.phase || ''] ?? null) as T;
  }

  private enrichError(error: Error, result: RecoveryResult): Error {
    (error as any).recoveryResult = result;
    (error as any).isRecoverable = result.success;
    return error;
  }
}
```

### Error Logger

```typescript
// packages/errors/src/logger.ts

export class ErrorLogger {
  constructor(private readonly storage: ErrorLogStorage) {}

  async log(error: PipelineError): Promise<void> {
    const entry: ErrorLogEntry = {
      id: error.id,
      timestamp: error.timestamp,
      code: error.code,
      message: error.message,
      category: error.category,
      severity: error.severity,
      recoverable: error.recoverable,
      recoveryStrategy: error.recoveryStrategy,
      context: error.context,
      stack: error.stack
    };

    await this.storage.save(entry);
  }

  async logRecovery(
    error: PipelineError,
    recovery: RecoveryAction
  ): Promise<void> {
    await this.storage.appendRecovery(error.id, recovery);
  }

  async logRetry(
    error: PipelineError,
    attempt: number,
    retryError: Error
  ): Promise<void> {
    await this.storage.appendRetry(error.id, {
      attempt,
      error: retryError.message,
      timestamp: new Date()
    });
  }

  async getHistory(
    filter?: ErrorLogFilter
  ): Promise<ErrorLogEntry[]> {
    return this.storage.query(filter);
  }
}
```

---

## Business Value

Sistema de recuperacao de erros torna o pipeline mais robusto e confiavel, lidando com falhas automaticamente quando possivel.

**Beneficios:**
- Recuperacao automatica de erros
- Classificacao inteligente
- Retry com backoff
- Logs detalhados para debug
- Pipeline mais confiavel

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Retry infinito | Low | High | Max retries + backoff |
| Fallback inadequado | Medium | Medium | Validacao de fallback |
| Logs muito grandes | Medium | Low | Rotacao + retencao |
| Classificacao errada | Medium | Medium | Override manual |

---

## Scope

### In Scope
- ErrorClassifier for categorization
- ErrorRecoveryManager with strategies
- PipelineErrorHandler wrapper
- ErrorLogger for audit
- Retry with exponential backoff
- Fallback values

### Out of Scope
- External notification systems
- Distributed error handling
- ML-based classification

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| Clone Pipeline | Package | Available |
| CL2-051 (Shared Context) | Package | Pending |

---

## Dev Notes

### Retry Configuration

```yaml
retry:
  max_retries: 3
  base_delay_ms: 1000
  max_delay_ms: 30000
  backoff_multiplier: 2
  jitter: true
```

### Error Severity Actions

| Severity | Default Action |
|----------|---------------|
| low | skip or fallback |
| medium | retry |
| high | retry + alert |
| critical | abort + alert |

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/errors/src/types.ts` | Create | Pending |
| `packages/errors/src/classifier.ts` | Create | Pending |
| `packages/errors/src/recovery-manager.ts` | Create | Pending |
| `packages/errors/src/pipeline-handler.ts` | Create | Pending |
| `packages/errors/src/logger.ts` | Create | Pending |
| `packages/errors/src/storage.ts` | Create | Pending |
| `packages/errors/src/index.ts` | Create | Pending |
| `packages/errors/src/__tests__/recovery.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] ErrorClassifier categorizes correctly
- [ ] Recovery strategies work
- [ ] Retry with backoff functional
- [ ] Fallback values appropriate
- [ ] Pipeline wrapper works
- [ ] Error logging complete
- [ ] All severity levels handled
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Errors classified correctly
- [ ] Retry strategy works
- [ ] Backoff timing correct
- [ ] Fallback values valid
- [ ] Logging captures details
- [ ] Pipeline continues after recovery

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
