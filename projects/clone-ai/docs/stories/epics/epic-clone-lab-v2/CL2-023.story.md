# Story CL2-023: CP-2 Analysis Review Checkpoint

**Story ID:** CL2-023
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 2 - Validation
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar o **Checkpoint 2 (CP-2)** - Analysis Review, que revisa os resultados da analise das Minds antes de prosseguir para sintese do DNA.

### Problem Statement
Apos a analise das 8 Minds, eh importante validar se os resultados sao consistentes e completos antes de sintetizar o DNA da personalidade.

---

## Acceptance Criteria

```gherkin
Given analysis results from all 8 Minds
When CP-2 evaluates the analysis
Then it returns an assessment of analysis quality

Given inconsistent results across Minds
When CP-2 evaluates
Then it identifies and highlights inconsistencies

Given analysis with low confidence scores
When CP-2 evaluates
Then it recommends additional data or rejects

Given CP-2 evaluation complete
When human reviews the checkpoint
Then clear summary of analysis quality is available
```

---

## Technical Requirements

### Checkpoint Implementation

```typescript
// packages/validation/src/checkpoints/cp-2-analysis-review.ts

import { ICheckpoint, CheckpointDefinition, CheckpointContext, CheckpointResult, CheckpointDetail } from './checkpoint.interface';

export class CP2AnalysisReview implements ICheckpoint {
  readonly definition: CheckpointDefinition = {
    id: 'CP-2',
    name: 'Analysis Review',
    description: 'Reviews the analysis results from all 8 Minds before DNA synthesis',
    triggerPhase: 'analysis',
    requiredApprovals: 1,
    autoApproveConditions: [
      'allMindsCompleted',
      'averageConfidence >= 0.7',
      'noCriticalInconsistencies',
      'dimensionCoverage >= 80%'
    ],
    timeout: 60 * 60 * 1000  // 1 hour
  };

  async evaluate(context: CheckpointContext): Promise<CheckpointResult> {
    const details: CheckpointDetail[] = [];
    const recommendations: string[] = [];

    // Get behavioral, values, and cognitive task results
    const behavioralResults = this.getResultsByPrefix(context.taskResults, 'BH-');
    const valuesResults = this.getResultsByPrefix(context.taskResults, 'VL-');
    const cognitiveResults = this.getResultsByPrefix(context.taskResults, 'CG-');

    // 1. Mind Coverage Assessment
    const coverageAssessment = this.assessMindCoverage(context);
    details.push({
      category: 'Mind Coverage',
      status: coverageAssessment.status,
      message: coverageAssessment.message,
      evidence: `Minds analyzed: ${coverageAssessment.mindsCovered}/8`
    });

    // 2. Confidence Assessment
    const confidenceAssessment = this.assessConfidence(behavioralResults, valuesResults, cognitiveResults);
    details.push({
      category: 'Analysis Confidence',
      status: confidenceAssessment.status,
      message: confidenceAssessment.message,
      evidence: `Average confidence: ${(confidenceAssessment.averageConfidence * 100).toFixed(1)}%`
    });

    // 3. Dimension Balance
    const balanceAssessment = this.assessDimensionBalance(behavioralResults, valuesResults, cognitiveResults);
    details.push({
      category: 'Dimension Balance',
      status: balanceAssessment.status,
      message: balanceAssessment.message,
      evidence: `Behavioral: ${balanceAssessment.behavioral}%, Values: ${balanceAssessment.values}%, Cognitive: ${balanceAssessment.cognitive}%`
    });

    // 4. Consistency Check
    const consistencyAssessment = this.assessConsistency(context);
    details.push({
      category: 'Cross-Mind Consistency',
      status: consistencyAssessment.status,
      message: consistencyAssessment.message,
      evidence: consistencyAssessment.inconsistencies.length > 0
        ? `Found ${consistencyAssessment.inconsistencies.length} inconsistencies`
        : 'No significant inconsistencies'
    });

    // 5. Data Quality Assessment
    const dataQualityAssessment = this.assessDataQuality(behavioralResults, valuesResults, cognitiveResults);
    details.push({
      category: 'Data Quality',
      status: dataQualityAssessment.status,
      message: dataQualityAssessment.message,
      evidence: `Evidence items: ${dataQualityAssessment.evidenceCount}, Sources used: ${dataQualityAssessment.sourcesUsed}`
    });

    // Calculate overall score
    const score = this.calculateScore([
      coverageAssessment,
      confidenceAssessment,
      balanceAssessment,
      consistencyAssessment,
      dataQualityAssessment
    ]);

    // Generate recommendations
    if (coverageAssessment.status !== 'pass') {
      recommendations.push('Ensure all 8 Minds have completed their analysis');
    }
    if (confidenceAssessment.averageConfidence < 0.7) {
      recommendations.push('Consider adding more source content to improve analysis confidence');
    }
    if (consistencyAssessment.inconsistencies.length > 0) {
      recommendations.push('Review and resolve cross-mind inconsistencies before proceeding');
    }
    if (balanceAssessment.status === 'warn') {
      recommendations.push('Some dimensions have less coverage. Consider补充 data sources.');
    }

    const hasFail = details.some(d => d.status === 'fail');
    const hasWarn = details.some(d => d.status === 'warn');

    return {
      checkpointId: this.definition.id,
      status: hasFail ? 'waiting_approval' : (hasWarn ? 'waiting_approval' : 'pending'),
      score,
      summary: this.generateSummary(score, details),
      details,
      recommendations,
      timestamp: new Date()
    };
  }

  canAutoApprove(result: CheckpointResult): boolean {
    const hasFail = result.details.some(d => d.status === 'fail');
    return result.score >= 75 && !hasFail;
  }

  async getReviewData(context: CheckpointContext): Promise<Record<string, unknown>> {
    return {
      mindResults: this.getMindSummaries(context),
      dimensionScores: this.getDimensionScores(context),
      inconsistencies: this.getHighlightedInconsistencies(context),
      lowConfidenceAreas: this.getLowConfidenceAreas(context)
    };
  }

  validateApproval(approval: ApprovalInfo): boolean {
    return !!approval.approvedBy && !!approval.approvedAt;
  }

  private getResultsByPrefix(results: Map<TaskId, TaskResult>, prefix: string): TaskResult[] {
    const filtered: TaskResult[] = [];
    for (const [taskId, result] of results) {
      if (taskId.startsWith(prefix)) {
        filtered.push(result);
      }
    }
    return filtered;
  }

  private assessMindCoverage(context: CheckpointContext): AssessmentResult {
    const expectedMinds = ['tim', 'daniel', 'brene', 'barbara', 'charlie', 'constantin', 'quinn', 'victoria'];
    const coveredMinds = expectedMinds.filter(mind => {
      // Check if any task result references this mind
      for (const [, result] of context.taskResults) {
        if (result.metadata?.mindId === mind || result.metadata?.relatedMind === mind) {
          return true;
        }
      }
      return false;
    });

    const coverage = coveredMinds.length / expectedMinds.length;

    return {
      status: coverage >= 1 ? 'pass' : (coverage >= 0.75 ? 'warn' : 'fail'),
      message: coverage >= 1
        ? 'All Minds have contributed to analysis'
        : `${expectedMinds.length - coveredMinds.length} Minds have not contributed`,
      mindsCovered: coveredMinds.length,
      score: coverage * 100
    };
  }

  private assessConfidence(
    behavioral: TaskResult[],
    values: TaskResult[],
    cognitive: TaskResult[]
  ): AssessmentResult {
    const allResults = [...behavioral, ...values, ...cognitive];
    const confidences = allResults.map(r => r.confidence).filter(c => c !== undefined);
    const averageConfidence = confidences.length > 0
      ? confidences.reduce((a, b) => a + b) / confidences.length
      : 0;

    return {
      status: averageConfidence >= 0.7 ? 'pass' : (averageConfidence >= 0.5 ? 'warn' : 'fail'),
      message: averageConfidence >= 0.7
        ? 'Analysis confidence is good'
        : 'Analysis confidence is low',
      averageConfidence,
      score: averageConfidence * 100
    };
  }

  private assessDimensionBalance(
    behavioral: TaskResult[],
    values: TaskResult[],
    cognitive: TaskResult[]
  ): AssessmentResult {
    const behavioralScore = this.calculateAverageScore(behavioral);
    const valuesScore = this.calculateAverageScore(values);
    const cognitiveScore = this.calculateAverageScore(cognitive);

    const scores = [behavioralScore, valuesScore, cognitiveScore];
    const avg = scores.reduce((a, b) => a + b) / scores.length;
    const variance = scores.reduce((sum, s) => sum + Math.pow(s - avg, 2), 0) / scores.length;
    const balanceScore = Math.max(0, 100 - Math.sqrt(variance));

    return {
      status: balanceScore >= 70 ? 'pass' : (balanceScore >= 50 ? 'warn' : 'fail'),
      message: balanceScore >= 70
        ? 'Dimensions are well balanced'
        : 'Some dimensions have more coverage than others',
      behavioral: behavioralScore,
      values: valuesScore,
      cognitive: cognitiveScore,
      score: balanceScore
    };
  }

  private assessConsistency(context: CheckpointContext): AssessmentResult {
    const inconsistencies: Inconsistency[] = [];

    // Check for contradictions between dimensions
    const syResults = this.getResultsByPrefix(context.taskResults, 'SY-');
    const consistencyResult = syResults.find(r => r.taskId === 'SY-002');

    if (consistencyResult?.metadata?.conflicts) {
      inconsistencies.push(...consistencyResult.metadata.conflicts);
    }

    const consistencyScore = Math.max(0, 100 - inconsistencies.length * 10);

    return {
      status: inconsistencies.length === 0 ? 'pass' : (inconsistencies.length <= 3 ? 'warn' : 'fail'),
      message: inconsistencies.length === 0
        ? 'No significant inconsistencies detected'
        : `${inconsistencies.length} potential inconsistencies found`,
      inconsistencies,
      score: consistencyScore
    };
  }

  private assessDataQuality(
    behavioral: TaskResult[],
    values: TaskResult[],
    cognitive: TaskResult[]
  ): AssessmentResult {
    const allResults = [...behavioral, ...values, ...cognitive];

    let evidenceCount = 0;
    let sourcesUsed = new Set<string>();

    for (const result of allResults) {
      evidenceCount += result.findings.length;
      if (result.metadata?.sources) {
        (result.metadata.sources as string[]).forEach(s => sourcesUsed.add(s));
      }
    }

    const qualityScore = Math.min(100, (evidenceCount * 2) + (sourcesUsed.size * 5));

    return {
      status: evidenceCount >= 20 ? 'pass' : (evidenceCount >= 10 ? 'warn' : 'fail'),
      message: evidenceCount >= 20
        ? 'Good evidence base for analysis'
        : 'Limited evidence for analysis',
      evidenceCount,
      sourcesUsed: sourcesUsed.size,
      score: qualityScore
    };
  }

  private calculateScore(assessments: AssessmentResult[]): number {
    return Math.round(
      assessments.reduce((sum, a) => sum + a.score, 0) / assessments.length
    );
  }

  private calculateAverageScore(results: TaskResult[]): number {
    if (results.length === 0) return 0;
    return Math.round(results.reduce((sum, r) => sum + r.score, 0) / results.length);
  }

  private generateSummary(score: number, details: CheckpointDetail[]): string {
    const status = score >= 75 ? 'EXCELLENT' : (score >= 60 ? 'GOOD' : (score >= 50 ? 'ADEQUATE' : 'NEEDS REVIEW'));
    const issues = details.filter(d => d.status === 'fail').length;
    const warnings = details.filter(d => d.status === 'warn').length;

    return `Analysis Review: ${status} (Score: ${score}%). ${issues} issues, ${warnings} warnings.`;
  }

  private getMindSummaries(context: CheckpointContext): Record<string, unknown> {
    // Return summary of each mind's contribution
    return {};
  }

  private getDimensionScores(context: CheckpointContext): Record<string, number> {
    return {
      behavioral: this.calculateAverageScore(this.getResultsByPrefix(context.taskResults, 'BH-')),
      values: this.calculateAverageScore(this.getResultsByPrefix(context.taskResults, 'VL-')),
      cognitive: this.calculateAverageScore(this.getResultsByPrefix(context.taskResults, 'CG-'))
    };
  }

  private getHighlightedInconsistencies(context: CheckpointContext): unknown[] {
    const syResults = this.getResultsByPrefix(context.taskResults, 'SY-');
    const consistencyResult = syResults.find(r => r.taskId === 'SY-002');
    return consistencyResult?.metadata?.conflicts || [];
  }

  private getLowConfidenceAreas(context: CheckpointContext): string[] {
    const areas: string[] = [];
    for (const [taskId, result] of context.taskResults) {
      if (result.confidence < 0.5) {
        areas.push(taskId);
      }
    }
    return areas;
  }
}

interface AssessmentResult {
  status: 'pass' | 'warn' | 'fail';
  message: string;
  score: number;
  [key: string]: unknown;
}

interface Inconsistency {
  dimension1: string;
  dimension2: string;
  description: string;
  severity: string;
}
```

### File Structure

```
packages/validation/src/checkpoints/
├── cp-2-analysis-review.ts
└── __tests__/
    └── cp-2-analysis-review.test.ts
```

---

## Business Value

CP-2 valida a **qualidade da analise** antes da sintese, garantindo que o DNA seja construido sobre uma base solida e consistente.

**Beneficios:**
- Detecta inconsistencias entre Minds
- Valida cobertura de dimensoes
- Garante confianca adequada
- Previne DNA mal formado

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Falsos positivos de inconsistencia | Medium | Medium | Thresholds configuraveis |
| Atraso por revisao | Medium | Low | Auto-approve conditions |

---

## Scope

### In Scope
- CP-2 checkpoint implementation
- Mind coverage assessment
- Consistency checking
- Unit tests

### Out of Scope
- Other checkpoints
- Checkpoint manager modifications
- CLI integration

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-014 to CL2-016 (BH, VL, CG Tasks) | Package | Pending |
| CL2-017 (Synthesis Tasks) | Package | Pending |
| CL2-021 (Checkpoint Interface) | Package | Pending |
| CL2-022 (CP-1) | Package | Pending |

---

## Dev Notes

- Coordinate with Mind results structure
- Add detailed inconsistency explanations
- Consider dimensional weighting

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/validation/src/checkpoints/cp-2-analysis-review.ts` | Create | Pending |
| `packages/validation/src/checkpoints/__tests__/cp-2-analysis-review.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Implements ICheckpoint correctly
- [ ] Evaluates all analysis results
- [ ] Returns valid CheckpointResult
- [ ] Auto-approve logic works
- [ ] Unit tests pass (coverage > 80%)
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Evaluation returns correct status
- [ ] Score calculation is accurate
- [ ] Inconsistencies detected
- [ ] Recommendations are helpful
- [ ] Edge cases handled

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
