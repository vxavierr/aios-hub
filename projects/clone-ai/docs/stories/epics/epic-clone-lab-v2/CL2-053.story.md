# Story CL2-053: Progress Reporting

**Story ID:** CL2-053
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 4 - Integration
**Status:** Ready
**Points:** 3
**Author:** Morgan (PM)

---

## Description

Implementar sistema de relatorios de progresso para acompanhar execucao do pipeline. Usuarios devem poder ver progresso em tempo real e relatorios historicos de sessoes.

### Problem Statement
Usuarios precisam visibilidade sobre o progresso de criacao de clones, incluindo quais fases foram completadas, tempo decorrido e estimativas.

---

## Acceptance Criteria

```gherkin
Given a pipeline is running
When progress is requested
Then current phase and completion percentage is returned

Given a pipeline completes
When final report is generated
Then full summary with timing and results is available

Given multiple pipelines have run
When history is requested
Then past executions are listed with details

Given a progress subscription exists
When pipeline advances
Then subscriber receives progress updates
```

---

## Technical Requirements

### Progress Types

```typescript
// packages/progress/src/types.ts

export interface ProgressStatus {
  sessionId: string;
  cloneId: string;
  state: 'idle' | 'running' | 'paused' | 'completed' | 'failed';
  currentPhase: PipelinePhase;
  phases: PhaseProgress[];
  startedAt: Date;
  estimatedCompletion?: Date;
  progress: number;              // 0-100
  elapsedMs: number;
}

export interface PhaseProgress {
  phase: PipelinePhase;
  status: 'pending' | 'in-progress' | 'completed' | 'failed' | 'skipped';
  startedAt?: Date;
  completedAt?: Date;
  duration?: number;
  progress: number;              // 0-100
  steps?: StepProgress[];
}

export interface StepProgress {
  stepId: string;
  name: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  progress: number;
  message?: string;
}

export interface ProgressReport {
  sessionId: string;
  cloneId: string;
  generatedAt: Date;
  summary: ProgressSummary;
  phases: PhaseReport[];
  timing: TimingReport;
  metrics: ProgressMetrics;
}

export interface ProgressSummary {
  status: 'success' | 'partial' | 'failed';
  totalDuration: number;
  phasesCompleted: number;
  phasesTotal: number;
  fidelity?: number;
}

export interface TimingReport {
  startedAt: Date;
  completedAt?: Date;
  phases: PhaseTiming[];
}

export interface PhaseTiming {
  phase: PipelinePhase;
  duration: number;
  percentage: number;            // Of total time
}

export interface ProgressMetrics {
  dataProcessed: number;
  mindsUsed: number;
  validationsRun: number;
  checkpointsPassed: number;
}
```

### Progress Tracker

```typescript
// packages/progress/src/progress-tracker.ts

export class ProgressTracker {
  private statuses: Map<string, ProgressStatus> = new Map();
  private subscribers: Map<string, ProgressSubscriber[]> = new Map();

  start(sessionId: string, cloneId: string): ProgressStatus {
    const status: ProgressStatus = {
      sessionId,
      cloneId,
      state: 'running',
      currentPhase: 'extraction',
      phases: this.initializePhases(),
      startedAt: new Date(),
      progress: 0,
      elapsedMs: 0
    };

    this.statuses.set(sessionId, status);
    this.notifySubscribers(sessionId, status);

    return status;
  }

  updatePhase(
    sessionId: string,
    phase: PipelinePhase,
    update: Partial<PhaseProgress>
  ): void {
    const status = this.statuses.get(sessionId);
    if (!status) return;

    const phaseIndex = status.phases.findIndex(p => p.phase === phase);
    if (phaseIndex === -1) return;

    status.phases[phaseIndex] = {
      ...status.phases[phaseIndex],
      ...update
    };

    // Update current phase if needed
    if (update.status === 'in-progress') {
      status.currentPhase = phase;
    }

    // Recalculate overall progress
    status.progress = this.calculateOverallProgress(status);
    status.elapsedMs = Date.now() - status.startedAt.getTime();

    // Estimate completion
    status.estimatedCompletion = this.estimateCompletion(status);

    this.notifySubscribers(sessionId, status);
  }

  updateStep(
    sessionId: string,
    phase: PipelinePhase,
    stepId: string,
    update: Partial<StepProgress>
  ): void {
    const status = this.statuses.get(sessionId);
    if (!status) return;

    const phaseProgress = status.phases.find(p => p.phase === phase);
    if (!phaseProgress || !phaseProgress.steps) return;

    const stepIndex = phaseProgress.steps.findIndex(s => s.stepId === stepId);
    if (stepIndex === -1) return;

    phaseProgress.steps[stepIndex] = {
      ...phaseProgress.steps[stepIndex],
      ...update
    };

    // Recalculate phase progress
    phaseProgress.progress = this.calculatePhaseProgress(phaseProgress);

    // Recalculate overall progress
    status.progress = this.calculateOverallProgress(status);

    this.notifySubscribers(sessionId, status);
  }

  complete(sessionId: string): ProgressStatus {
    const status = this.statuses.get(sessionId);
    if (!status) throw new Error(`Session ${sessionId} not found`);

    status.state = 'completed';
    status.progress = 100;

    const lastPhase = status.phases[status.phases.length - 1];
    lastPhase.status = 'completed';
    lastPhase.completedAt = new Date();
    lastPhase.duration = lastPhase.completedAt.getTime() -
      (lastPhase.startedAt?.getTime() || status.startedAt.getTime());

    this.notifySubscribers(sessionId, status);

    return status;
  }

  fail(sessionId: string, error: Error): ProgressStatus {
    const status = this.statuses.get(sessionId);
    if (!status) throw new Error(`Session ${sessionId} not found`);

    status.state = 'failed';

    const currentPhase = status.phases.find(p => p.phase === status.currentPhase);
    if (currentPhase) {
      currentPhase.status = 'failed';
      currentPhase.completedAt = new Date();
    }

    this.notifySubscribers(sessionId, status);

    return status;
  }

  getStatus(sessionId: string): ProgressStatus | undefined {
    return this.statuses.get(sessionId);
  }

  // Subscriptions
  subscribe(
    sessionId: string,
    callback: (status: ProgressStatus) => void
  ): () => void {
    if (!this.subscribers.has(sessionId)) {
      this.subscribers.set(sessionId, []);
    }

    const subscriber: ProgressSubscriber = {
      id: generateId(),
      callback
    };

    this.subscribers.get(sessionId)!.push(subscriber);

    // Return unsubscribe function
    return () => {
      const subs = this.subscribers.get(sessionId);
      if (subs) {
        const index = subs.findIndex(s => s.id === subscriber.id);
        if (index !== -1) {
          subs.splice(index, 1);
        }
      }
    };
  }

  private initializePhases(): PhaseProgress[] {
    const phases: PipelinePhase[] = [
      'extraction',
      'analysis',
      'synthesis',
      'validation',
      'checkpoint',
      'generation',
      'finalization'
    ];

    return phases.map(phase => ({
      phase,
      status: 'pending',
      progress: 0
    }));
  }

  private calculateOverallProgress(status: ProgressStatus): number {
    const weights: Record<PipelinePhase, number> = {
      extraction: 15,
      analysis: 25,
      synthesis: 15,
      validation: 20,
      checkpoint: 10,
      generation: 10,
      finalization: 5
    };

    let total = 0;
    for (const phase of status.phases) {
      const weight = weights[phase.phase] || 0;
      total += (phase.progress / 100) * weight;
    }

    return Math.round(total);
  }

  private calculatePhaseProgress(phase: PhaseProgress): number {
    if (!phase.steps || phase.steps.length === 0) {
      return phase.status === 'completed' ? 100 : 0;
    }

    const completed = phase.steps.filter(s => s.status === 'completed').length;
    return Math.round((completed / phase.steps.length) * 100);
  }

  private estimateCompletion(status: ProgressStatus): Date | undefined {
    if (status.progress === 0) return undefined;

    const elapsed = status.elapsedMs;
    const estimatedTotal = (elapsed / status.progress) * 100;

    return new Date(status.startedAt.getTime() + estimatedTotal);
  }

  private notifySubscribers(sessionId: string, status: ProgressStatus): void {
    const subscribers = this.subscribers.get(sessionId);
    if (!subscribers) return;

    for (const sub of subscribers) {
      try {
        sub.callback(status);
      } catch (error) {
        console.error('Progress subscriber error:', error);
      }
    }
  }
}
```

### Report Generator

```typescript
// packages/progress/src/report-generator.ts

export class ProgressReportGenerator {
  constructor(
    private readonly tracker: ProgressTracker,
    private readonly historyStore: HistoryStore
  ) {}

  async generateReport(sessionId: string): Promise<ProgressReport> {
    const status = this.tracker.getStatus(sessionId);
    if (!status) {
      throw new Error(`Session ${sessionId} not found`);
    }

    const phases = this.buildPhaseReports(status);
    const timing = this.buildTimingReport(status);
    const metrics = await this.gatherMetrics(sessionId);

    return {
      sessionId,
      cloneId: status.cloneId,
      generatedAt: new Date(),
      summary: {
        status: this.determineSummaryStatus(status),
        totalDuration: status.elapsedMs,
        phasesCompleted: status.phases.filter(p => p.status === 'completed').length,
        phasesTotal: status.phases.length,
        fidelity: metrics.fidelity
      },
      phases,
      timing,
      metrics
    };
  }

  async getHistory(options: HistoryOptions = {}): Promise<ProgressReport[]> {
    const sessions = await this.historyStore.list(options);

    return Promise.all(
      sessions.map(s => this.generateReport(s.sessionId))
    );
  }

  private buildPhaseReports(status: ProgressStatus): PhaseReport[] {
    return status.phases.map(phase => ({
      phase: phase.phase,
      status: phase.status,
      progress: phase.progress,
      duration: phase.duration,
      steps: phase.steps?.map(step => ({
        stepId: step.stepId,
        name: step.name,
        status: step.status,
        progress: step.progress,
        message: step.message
      }))
    }));
  }

  private buildTimingReport(status: ProgressStatus): TimingReport {
    const phases: PhaseTiming[] = status.phases
      .filter(p => p.duration)
      .map(p => ({
        phase: p.phase,
        duration: p.duration!,
        percentage: 0 // Calculated below
      }));

    const totalDuration = phases.reduce((a, p) => a + p.duration, 0);

    for (const phase of phases) {
      phase.percentage = Math.round((phase.duration / totalDuration) * 100);
    }

    return {
      startedAt: status.startedAt,
      completedAt: status.state === 'completed'
        ? new Date(status.startedAt.getTime() + status.elapsedMs)
        : undefined,
      phases
    };
  }

  private async gatherMetrics(sessionId: string): Promise<ProgressMetrics> {
    // Would gather from context store or other sources
    return {
      dataProcessed: 0,
      mindsUsed: 8,
      validationsRun: 63,
      checkpointsPassed: 6
    };
  }

  private determineSummaryStatus(status: ProgressStatus): 'success' | 'partial' | 'failed' {
    if (status.state === 'failed') return 'failed';
    if (status.state === 'completed') return 'success';

    const completed = status.phases.filter(p => p.status === 'completed').length;
    const total = status.phases.length;

    if (completed === 0) return 'failed';
    if (completed < total) return 'partial';
    return 'success';
  }
}
```

### CLI Integration

```typescript
// packages/progress/src/cli.ts

export function formatProgressCLI(status: ProgressStatus): string {
  const lines: string[] = [];

  // Header
  lines.push(chalk.bold(`Clone Progress: ${status.cloneId}`));
  lines.push(chalk.gray(`Session: ${status.sessionId}`));
  lines.push('');

  // Overall progress bar
  const progressBar = createProgressBar(status.progress, 40);
  lines.push(`${progressBar} ${status.progress}%`);
  lines.push('');

  // State
  const stateColor = {
    running: chalk.blue,
    completed: chalk.green,
    failed: chalk.red,
    paused: chalk.yellow,
    idle: chalk.gray
  }[status.state] || chalk.gray;

  lines.push(`State: ${stateColor(status.state)}`);
  lines.push(`Current Phase: ${status.currentPhase}`);
  lines.push(`Elapsed: ${formatDuration(status.elapsedMs)}`);

  if (status.estimatedCompletion) {
    const remaining = status.estimatedCompletion.getTime() - Date.now();
    lines.push(`Estimated remaining: ${formatDuration(remaining)}`);
  }

  lines.push('');

  // Phase breakdown
  lines.push(chalk.bold('Phases:'));
  for (const phase of status.phases) {
    const icon = {
      completed: chalk.green('✓'),
      'in-progress': chalk.blue('●'),
      failed: chalk.red('✗'),
      pending: chalk.gray('○'),
      skipped: chalk.gray('→')
    }[phase.status] || chalk.gray('?');

    const bar = createProgressBar(phase.progress, 20);
    lines.push(`  ${icon} ${phase.phase.padEnd(14)} ${bar} ${phase.progress}%`);
  }

  return lines.join('\n');
}

function createProgressBar(progress: number, width: number): string {
  const filled = Math.round((progress / 100) * width);
  const empty = width - filled;
  return chalk.green('█'.repeat(filled)) + chalk.gray('░'.repeat(empty));
}

function formatDuration(ms: number): string {
  if (ms < 1000) return `${ms}ms`;
  if (ms < 60000) return `${Math.round(ms / 1000)}s`;
  if (ms < 3600000) {
    const mins = Math.floor(ms / 60000);
    const secs = Math.round((ms % 60000) / 1000);
    return `${mins}m ${secs}s`;
  }
  const hours = Math.floor(ms / 3600000);
  const mins = Math.round((ms % 3600000) / 60000);
  return `${hours}h ${mins}m`;
}
```

---

## Business Value

Sistema de progress reporting oferece visibilidade completa sobre execucao do pipeline, melhorando experiencia do usuario e debug.

**Beneficios:**
- Visibilidade em tempo real
- Estimativas de tempo
- Relatorios historicos
- Subscriptions para UI
- Debug facilitado

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Overhead de tracking | Low | Low | Updates throttled |
| Historico muito grande | Medium | Low | Limite + cleanup |
| Estimativas imprecisas | Medium | Low | Refinamento com ML |
| Subscriber travado | Low | Low | Error handling |

---

## Scope

### In Scope
- ProgressTracker for real-time tracking
- ProgressReportGenerator
- CLI formatting
- Subscriptions
- History storage

### Out of Scope
- Web UI components
- Distributed progress
- Real-time streaming (WebSocket)

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| Clone Pipeline | Package | Available |
| CLI Package | Package | Available |

---

## Dev Notes

### Progress Update Throttling

```typescript
// Maximum 1 update per second per session
const THROTTLE_MS = 1000;
```

### History Retention

```yaml
history:
  retention_days: 30
  max_entries: 1000
  cleanup_interval_hours: 24
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/progress/src/types.ts` | Create | Pending |
| `packages/progress/src/progress-tracker.ts` | Create | Pending |
| `packages/progress/src/report-generator.ts` | Create | Pending |
| `packages/progress/src/history-store.ts` | Create | Pending |
| `packages/progress/src/cli.ts` | Create | Pending |
| `packages/progress/src/index.ts` | Create | Pending |
| `packages/progress/src/__tests__/progress.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] ProgressTracker tracks phases
- [ ] Progress calculated correctly
- [ ] Estimations reasonable
- [ ] Subscriptions deliver updates
- [ ] Reports generate correctly
- [ ] CLI formatting works
- [ ] History available
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Progress updates accurate
- [ ] Phase transitions tracked
- [ ] Progress bar displays correctly
- [ ] Time estimates reasonable
- [ ] Subscriptions receive updates
- [ ] Reports complete and accurate

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
