# Story CL2-059: Constitution Evolution

**Story ID:** CL2-059
**Epic:** EPIC-CLONE-LAB-V2
**Phase:** 5 - Self-Evolution
**Status:** Ready
**Points:** 5
**Author:** Morgan (PM)

---

## Description

Implementar o sistema de **Constitution Evolution** - permite que a própria constitution (regras de auto-modificação) evolua ao longo do tempo, mas de forma extremamente controlada e sempre com aprovação humana.

### Problem Statement
A constitution inicial pode ser muito restritiva ou muito permissiva. O sistema precisa poder ajustá-la, mas de forma segura e sempre com supervisão humana.

---

## Acceptance Criteria

```gherkin
Given a constitution change is proposed
When it passes all safety checks
Then it is queued for human approval

Given a constitution change is approved
When applied
Then the change is versioned and logged

Given a constitution change causes issues
When rollback is triggered
Then the previous constitution version is restored

Given multiple constitution versions exist
When querying history
Then all changes are visible with reasons
```

---

## Technical Requirements

### Constitution Evolution Manager

```typescript
// packages/meta/src/constitution/evolution-manager.ts

export interface ConstitutionVersion {
  version: string;
  content: string;
  checksum: string;
  createdAt: Date;
  createdBy: 'initial' | 'human' | 'system';
  changeReason: string;
  changeDescription: string;
  parentVersion?: string;
}

export interface ConstitutionChangeProposal {
  id: string;
  proposedVersion: string;
  changes: ConstitutionDiff[];
  rationale: string;
  riskAssessment: RiskAssessment;
  status: 'pending' | 'approved' | 'rejected' | 'applied';
  submittedAt: Date;
  reviewedAt?: Date;
  reviewer?: string;
}

export interface ConstitutionDiff {
  type: 'add' | 'remove' | 'modify';
  section: string;
  oldValue?: string;
  newValue?: string;
  impact: 'low' | 'medium' | 'high' | 'critical';
}

export class ConstitutionEvolutionManager {
  private readonly current: ConstitutionVersion;
  private readonly history: ConstitutionVersion[];
  private readonly proposals: Map<string, ConstitutionChangeProposal>;
  private readonly safetyChecks: SafetyCheck[];

  constructor(
    initialConstitution: string,
    safetyChecks: SafetyCheck[]
  ) {
    this.current = {
      version: '1.0.0',
      content: initialConstitution,
      checksum: this.calculateChecksum(initialConstitution),
      createdAt: new Date(),
      createdBy: 'initial',
      changeReason: 'Initial constitution',
      changeDescription: 'Initial constitution created during system setup'
    };
    this.history = [this.current];
    this.proposals = new Map();
    this.safetyChecks = safetyChecks;
  }

  async proposeChange(
    newContent: string,
    rationale: string
  ): Promise<ConstitutionChangeProposal> {
    // 1. Calculate diff
    const changes = this.calculateDiff(this.current.content, newContent);

    // 2. Assess risk
    const riskAssessment = this.assessRisk(changes);

    // 3. Run safety checks
    const safetyResults = await this.runSafetyChecks(newContent, changes);

    if (!safetyResults.passed) {
      throw new Error(`Safety checks failed: ${safetyResults.failures.join(', ')}`);
    }

    // 4. Create proposal
    const proposal: ConstitutionChangeProposal = {
      id: generateId(),
      proposedVersion: this.incrementVersion(this.current.version),
      changes,
      rationale,
      riskAssessment,
      status: 'pending',
      submittedAt: new Date()
    };

    this.proposals.set(proposal.id, proposal);

    // 5. ALWAYS requires human approval for constitution changes
    await this.queueForHumanApproval(proposal);

    return proposal;
  }

  async applyChange(proposalId: string, reviewer: string): Promise<void> {
    const proposal = this.proposals.get(proposalId);
    if (!proposal) throw new Error(`Proposal not found: ${proposalId}`);
    if (proposal.status !== 'approved') {
      throw new Error(`Proposal not approved: ${proposal.status}`);
    }

    // Create new version
    const newVersion: ConstitutionVersion = {
      version: proposal.proposedVersion,
      content: proposal.changes.reduce(
        (content, change) => this.applyChangeToContent(content, change),
        this.current.content
      ),
      checksum: '', // Will be calculated
      createdAt: new Date(),
      createdBy: 'human',
      changeReason: proposal.rationale,
      changeDescription: this.formatChangeDescription(proposal.changes),
      parentVersion: this.current.version
    };

    newVersion.checksum = this.calculateChecksum(newVersion.content);

    // Backup current version
    await this.backupCurrentVersion();

    // Apply new version
    this.history.push(this.current);
    Object.assign(this.current, newVersion);

    // Update proposal status
    proposal.status = 'applied';
    proposal.reviewedAt = new Date();
    proposal.reviewer = reviewer;

    // Log the change
    await this.logConstitutionChange(proposal, newVersion);
  }

  async rollback(targetVersion: string): Promise<void> {
    const target = this.history.find(v => v.version === targetVersion);
    if (!target) throw new Error(`Version not found: ${targetVersion}`);

    // Backup current
    await this.backupCurrentVersion();

    // Restore target
    this.history.push({ ...this.current });
    Object.assign(this.current, target);

    await this.logRollback(targetVersion);
  }

  getVersionHistory(): ConstitutionVersion[] {
    return [...this.history].reverse();
  }

  getCurrentVersion(): ConstitutionVersion {
    return { ...this.current };
  }

  private calculateDiff(oldContent: string, newContent: string): ConstitutionDiff[] {
    // Parse YAML and calculate structured diff
    const oldParsed = yaml.parse(oldContent);
    const newParsed = yaml.parse(newContent);
    const diffs: ConstitutionDiff[] = [];

    // Compare sections
    for (const section of Object.keys(newParsed)) {
      if (!oldParsed[section]) {
        diffs.push({
          type: 'add',
          section,
          newValue: yaml.stringify(newParsed[section]),
          impact: this.assessSectionImpact(section, 'add')
        });
      } else if (JSON.stringify(oldParsed[section]) !== JSON.stringify(newParsed[section])) {
        diffs.push({
          type: 'modify',
          section,
          oldValue: yaml.stringify(oldParsed[section]),
          newValue: yaml.stringify(newParsed[section]),
          impact: this.assessSectionImpact(section, 'modify')
        });
      }
    }

    for (const section of Object.keys(oldParsed)) {
      if (!newParsed[section]) {
        diffs.push({
          type: 'remove',
          section,
          oldValue: yaml.stringify(oldParsed[section]),
          impact: this.assessSectionImpact(section, 'remove')
        });
      }
    }

    return diffs;
  }

  private assessSectionImpact(section: string, changeType: string): 'low' | 'medium' | 'high' | 'critical' {
    const criticalSections = ['forbidden', 'rate_limits', 'approval_requirements'];
    const highSections = ['auto_applicable', 'thresholds'];

    if (criticalSections.includes(section)) return 'critical';
    if (highSections.includes(section)) return 'high';
    return 'medium';
  }

  private async runSafetyChecks(
    content: string,
    changes: ConstitutionDiff[]
  ): Promise<{ passed: boolean; failures: string[] }> {
    const failures: string[] = [];

    for (const check of this.safetyChecks) {
      const result = await check.run(content, changes);
      if (!result.passed) {
        failures.push(result.reason);
      }
    }

    return {
      passed: failures.length === 0,
      failures
    };
  }
}
```

### Required Safety Checks

```typescript
// packages/meta/src/constitution/safety-checks.ts

export const REQUIRED_SAFETY_CHECKS: SafetyCheck[] = [
  {
    name: 'no-remove-rollback-capability',
    run: async (content, changes) => {
      const hasRollbackRemoval = changes.some(
        c => c.section === 'rollback' && c.type === 'remove'
      );
      return {
        passed: !hasRollbackRemoval,
        reason: hasRollbackRemoval ? 'Cannot remove rollback capability' : ''
      };
    }
  },
  {
    name: 'no-disable-audit-log',
    run: async (content, changes) => {
      const parsed = yaml.parse(content);
      return {
        passed: parsed.audit_logging !== false,
        reason: parsed.audit_logging === false ? 'Cannot disable audit logging' : ''
      };
    }
  },
  {
    name: 'no-remove-all-checkpoints',
    run: async (content, changes) => {
      const parsed = yaml.parse(content);
      const checkpointCount = Object.keys(parsed.checkpoints || {}).length;
      return {
        passed: checkpointCount >= 1,
        reason: checkpointCount < 1 ? 'Must have at least one checkpoint' : ''
      };
    }
  },
  {
    name: 'valid-yaml-syntax',
    run: async (content) => {
      try {
        yaml.parse(content);
        return { passed: true, reason: '' };
      } catch {
        return { passed: false, reason: 'Invalid YAML syntax' };
      }
    }
  }
];
```

---

## Business Value

A Constitution Evolution permite que o sistema **ajuste suas próprias regras** de forma segura, aprendendo com a experiência enquanto mantém salvaguardas essenciais.

**Benefícios:**
- Sistema pode se adaptar a novos cenários
- Ajuste fino de restrições baseado em experiência
- Versionamento completo de mudanças
- Rollback sempre disponível
- Auditoria completa de evolução

---

## Risks

| Risk | Probability | Impact | Mitigation |
|------|-------------|--------|------------|
| Mudança remove salvaguarda | Low | Critical | Safety checks obrigatórios |
| Proposta maliciosa | Low | Critical | Aprovação humana obrigatória |
| Versionamento corrompido | Low | High | Checksums + backup |

---

## Scope

### In Scope
- ConstitutionEvolutionManager class
- Diff calculation
- Safety checks
- Version history
- Rollback capability

### Out of Scope
- Automatic constitution proposals
- Distributed constitution
- Constitution templates

---

## Dependencies

| Dependency | Type | Status |
|------------|------|--------|
| CL2-034 (Constitution Rules) | Package | Pending |
| CL2-038 (Rollback Manager) | Package | Pending |
| CL2-056 (Human Approval) | Package | Pending |

---

## Dev Notes

### Initial Constitution

```yaml
# meta/constitution.md
version: 1.0.0

# Auto-applicable changes (no approval needed)
auto_applicable:
  - pattern: "validation/tasks/EX-*"
    max_risk: 20
  - pattern: "minds/*/prompts"
    max_risk: 30

# Requires human approval
requires_approval:
  - pattern: "constitution/*"
    urgency: critical
  - pattern: "checkpoints/*"
    urgency: high

# Forbidden changes (never allowed)
forbidden:
  - pattern: "checkpoints/all"
  - pattern: "constitution/forbidden"
  - pattern: "audit-trail/*"

# Rate limits
rate_limits:
  max_changes_per_day: 5
  max_changes_per_week: 20
  cooldown_hours: 4

# Audit settings
audit_logging: true
audit_retention_days: 365
```

---

## File List

| File | Action | Status |
|------|--------|--------|
| `packages/meta/src/constitution/evolution-manager.ts` | Create | Pending |
| `packages/meta/src/constitution/safety-checks.ts` | Create | Pending |
| `packages/meta/src/constitution/types.ts` | Create | Pending |
| `packages/meta/src/constitution/index.ts` | Update | Pending |
| `packages/meta/src/constitution/__tests__/evolution.test.ts` | Create | Pending |

---

## Definition of Done

- [ ] Constitution changes can be proposed
- [ ] Safety checks run on all proposals
- [ ] Human approval required
- [ ] Version history maintained
- [ ] Rollback works correctly
- [ ] Lint passa sem erros
- [ ] Code review aprovado

---

## QA Checklist

- [ ] Proposals created correctly
- [ ] Safety checks prevent dangerous changes
- [ ] Approval workflow works
- [ ] Version history accurate
- [ ] Rollback restores previous version

---

## Change Log

| Date | Author | Description |
|------|--------|-------------|
| 2026-02-20 | Morgan (PM) | Story created |

---

*Story generated by Morgan (PM Agent) - AIOS Framework*
